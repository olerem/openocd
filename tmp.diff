diff --git b/Doxyfile.in a/Doxyfile.in
deleted file mode 100644
index 13b0c24f6..000000000
--- b/Doxyfile.in
+++ /dev/null
@@ -1,1517 +0,0 @@
-# Doxyfile 1.5.8
-
-# This file describes the settings to be used by the documentation system
-# doxygen (www.doxygen.org) for a project
-#
-# All text after a hash (#) is considered a comment and will be ignored
-# The format is:
-#       TAG = value [value, ...]
-# For lists items can also be appended using:
-#       TAG += value [value, ...]
-# Values that contain spaces should be placed between quotes (" ")
-
-#---------------------------------------------------------------------------
-# Project related configuration options
-#---------------------------------------------------------------------------
-
-# This tag specifies the encoding used for all characters in the config file
-# that follow. The default is UTF-8 which is also the encoding used for all
-# text before the first occurrence of this tag. Doxygen uses libiconv (or the
-# iconv built into libc) for the transcoding. See
-# http://www.gnu.org/software/libiconv for the list of possible encodings.
-
-DOXYFILE_ENCODING      = UTF-8
-
-# The PROJECT_NAME tag is a single word (or a sequence of words surrounded
-# by quotes) that should identify the project.
-
-PROJECT_NAME           = OpenOCD
-
-# The PROJECT_NUMBER tag can be used to enter a project or revision number.
-# This could be handy for archiving the generated documentation or
-# if some version control system is used.
-
-PROJECT_NUMBER         =
-
-# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute)
-# base path where the generated documentation will be put.
-# If a relative path is entered, it will be relative to the location
-# where doxygen was started. If left blank the current directory will be used.
-
-OUTPUT_DIRECTORY       = doxygen
-
-# If the CREATE_SUBDIRS tag is set to YES, then doxygen will create
-# 4096 sub-directories (in 2 levels) under the output directory of each output
-# format and will distribute the generated files over these directories.
-# Enabling this option can be useful when feeding doxygen a huge amount of
-# source files, where putting all generated files in the same directory would
-# otherwise cause performance problems for the file system.
-
-CREATE_SUBDIRS         = NO
-
-# The OUTPUT_LANGUAGE tag is used to specify the language in which all
-# documentation generated by doxygen is written. Doxygen will use this
-# information to generate all constant output in the proper language.
-# The default language is English, other supported languages are:
-# Afrikaans, Arabic, Brazilian, Catalan, Chinese, Chinese-Traditional,
-# Croatian, Czech, Danish, Dutch, Farsi, Finnish, French, German, Greek,
-# Hungarian, Italian, Japanese, Japanese-en (Japanese with English messages),
-# Korean, Korean-en, Lithuanian, Norwegian, Macedonian, Persian, Polish,
-# Portuguese, Romanian, Russian, Serbian, Serbian-Cyrilic, Slovak, Slovene, 
-# Spanish, Swedish, and Ukrainian.
-
-OUTPUT_LANGUAGE        = English
-
-# If the BRIEF_MEMBER_DESC tag is set to YES (the default) Doxygen will
-# include brief member descriptions after the members that are listed in
-# the file and class documentation (similar to JavaDoc).
-# Set to NO to disable this.
-
-BRIEF_MEMBER_DESC      = YES
-
-# If the REPEAT_BRIEF tag is set to YES (the default) Doxygen will prepend
-# the brief description of a member or function before the detailed description.
-# Note: if both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the
-# brief descriptions will be completely suppressed.
-
-REPEAT_BRIEF           = YES
-
-# This tag implements a quasi-intelligent brief description abbreviator
-# that is used to form the text in various listings. Each string
-# in this list, if found as the leading text of the brief description, will be
-# stripped from the text and the result after processing the whole list, is
-# used as the annotated text. Otherwise, the brief description is used as-is.
-# If left blank, the following values are used ("$name" is automatically
-# replaced with the name of the entity): "The $name class" "The $name widget"
-# "The $name file" "is" "provides" "specifies" "contains"
-# "represents" "a" "an" "the"
-
-ABBREVIATE_BRIEF       =
-
-# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then
-# Doxygen will generate a detailed section even if there is only a brief
-# description.
-
-ALWAYS_DETAILED_SEC    = NO
-
-# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all
-# inherited members of a class in the documentation of that class as if those
-# members were ordinary class members. Constructors, destructors and assignment
-# operators of the base classes will not be shown.
-
-INLINE_INHERITED_MEMB  = YES
-
-# If the FULL_PATH_NAMES tag is set to YES then Doxygen will prepend the full
-# path before files name in the file list and in the header files. If set
-# to NO the shortest path that makes the file name unique will be used.
-
-FULL_PATH_NAMES        = NO
-
-# If the FULL_PATH_NAMES tag is set to YES then the STRIP_FROM_PATH tag
-# can be used to strip a user-defined part of the path. Stripping is
-# only done if one of the specified strings matches the left-hand part of
-# the path. The tag can be used to show relative paths in the file list.
-# If left blank the directory from which doxygen is run is used as the
-# path to strip.
-
-STRIP_FROM_PATH        =
-
-# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of
-# the path mentioned in the documentation of a class, which tells
-# the reader which header file to include in order to use a class.
-# If left blank only the name of the header file containing the class
-# definition is used. Otherwise one should specify the include paths that
-# are normally passed to the compiler using the -I flag.
-
-STRIP_FROM_INC_PATH    =
-
-# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter
-# (but less readable) file names. This can be useful is your file systems
-# doesn't support long names like on DOS, Mac, or CD-ROM.
-
-SHORT_NAMES            = NO
-
-# If the JAVADOC_AUTOBRIEF tag is set to YES then Doxygen
-# will interpret the first line (until the first dot) of a JavaDoc-style
-# comment as the brief description. If set to NO, the JavaDoc
-# comments will behave just like regular Qt-style comments
-# (thus requiring an explicit @brief command for a brief description.)
-
-JAVADOC_AUTOBRIEF      = YES
-
-# If the QT_AUTOBRIEF tag is set to YES then Doxygen will
-# interpret the first line (until the first dot) of a Qt-style
-# comment as the brief description. If set to NO, the comments
-# will behave just like regular Qt-style comments (thus requiring
-# an explicit \brief command for a brief description.)
-
-QT_AUTOBRIEF           = NO
-
-# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make Doxygen
-# treat a multi-line C++ special comment block (i.e. a block of //! or ///
-# comments) as a brief description. This used to be the default behaviour.
-# The new default is to treat a multi-line C++ comment block as a detailed
-# description. Set this tag to YES if you prefer the old behaviour instead.
-
-MULTILINE_CPP_IS_BRIEF = NO
-
-# If the INHERIT_DOCS tag is set to YES (the default) then an undocumented
-# member inherits the documentation from any documented member that it
-# re-implements.
-
-INHERIT_DOCS           = YES
-
-# If the SEPARATE_MEMBER_PAGES tag is set to YES, then doxygen will produce
-# a new page for each member. If set to NO, the documentation of a member will
-# be part of the file/class/namespace that contains it.
-
-SEPARATE_MEMBER_PAGES  = NO
-
-# The TAB_SIZE tag can be used to set the number of spaces in a tab.
-# Doxygen uses this value to replace tabs by spaces in code fragments.
-
-TAB_SIZE               = 4
-
-# This tag can be used to specify a number of aliases that acts
-# as commands in the documentation. An alias has the form "name=value".
-# For example adding "sideeffect=\par Side Effects:\n" will allow you to
-# put the command \sideeffect (or @sideeffect) in the documentation, which
-# will result in a user-defined paragraph with heading "Side Effects:".
-# You can put \n's in the value part of an alias to insert newlines.
-
-ALIASES                =
-
-# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C
-# sources only. Doxygen will then generate output that is more tailored for C.
-# For instance, some of the names that are used will be different. The list
-# of all members will be omitted, etc.
-
-OPTIMIZE_OUTPUT_FOR_C  = YES
-
-# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java
-# sources only. Doxygen will then generate output that is more tailored for
-# Java. For instance, namespaces will be presented as packages, qualified
-# scopes will look different, etc.
-
-OPTIMIZE_OUTPUT_JAVA   = NO
-
-# Set the OPTIMIZE_FOR_FORTRAN tag to YES if your project consists of Fortran
-# sources only. Doxygen will then generate output that is more tailored for
-# Fortran.
-
-OPTIMIZE_FOR_FORTRAN   = NO
-
-# Set the OPTIMIZE_OUTPUT_VHDL tag to YES if your project consists of VHDL
-# sources. Doxygen will then generate output that is tailored for
-# VHDL.
-
-OPTIMIZE_OUTPUT_VHDL   = NO
-
-# Doxygen selects the parser to use depending on the extension of the files it parses. 
-# With this tag you can assign which parser to use for a given extension. 
-# Doxygen has a built-in mapping, but you can override or extend it using this tag. 
-# The format is ext=language, where ext is a file extension, and language is one of 
-# the parsers supported by doxygen: IDL, Java, Javascript, C#, C, C++, D, PHP, 
-# Objective-C, Python, Fortran, VHDL, C, C++. For instance to make doxygen treat 
-# .inc files as Fortran files (default is PHP), and .f files as C (default is Fortran), 
-# use: inc=Fortran f=C
-
-EXTENSION_MAPPING      = 
-
-# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want
-# to include (a tag file for) the STL sources as input, then you should
-# set this tag to YES in order to let doxygen match functions declarations and
-# definitions whose arguments contain STL classes (e.g. func(std::string); v.s.
-# func(std::string) {}). This also make the inheritance and collaboration
-# diagrams that involve STL classes more complete and accurate.
-
-BUILTIN_STL_SUPPORT    = NO
-
-# If you use Microsoft's C++/CLI language, you should set this option to YES to
-# enable parsing support.
-
-CPP_CLI_SUPPORT        = NO
-
-# Set the SIP_SUPPORT tag to YES if your project consists of sip sources only.
-# Doxygen will parse them like normal C++ but will assume all classes use public
-# instead of private inheritance when no explicit protection keyword is present.
-
-SIP_SUPPORT            = NO
-
-# For Microsoft's IDL there are propget and propput attributes to indicate getter 
-# and setter methods for a property. Setting this option to YES (the default) 
-# will make doxygen to replace the get and set methods by a property in the 
-# documentation. This will only work if the methods are indeed getting or 
-# setting a simple type. If this is not the case, or you want to show the 
-# methods anyway, you should set this option to NO.
-
-IDL_PROPERTY_SUPPORT   = NO
-
-# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC
-# tag is set to YES, then doxygen will reuse the documentation of the first
-# member in the group (if any) for the other members of the group. By default
-# all members of a group must be documented explicitly.
-
-DISTRIBUTE_GROUP_DOC   = NO
-
-# Set the SUBGROUPING tag to YES (the default) to allow class member groups of
-# the same type (for instance a group of public functions) to be put as a
-# subgroup of that type (e.g. under the Public Functions section). Set it to
-# NO to prevent subgrouping. Alternatively, this can be done per class using
-# the \nosubgrouping command.
-
-SUBGROUPING            = YES
-
-# When TYPEDEF_HIDES_STRUCT is enabled, a typedef of a struct, union, or enum
-# is documented as struct, union, or enum with the name of the typedef. So
-# typedef struct TypeS {} TypeT, will appear in the documentation as a struct
-# with name TypeT. When disabled the typedef will appear as a member of a file,
-# namespace, or class. And the struct will be named TypeS. This can typically
-# be useful for C code in case the coding convention dictates that all compound
-# types are typedef'ed and only the typedef is referenced, never the tag name.
-
-TYPEDEF_HIDES_STRUCT   = NO
-
-# The SYMBOL_CACHE_SIZE determines the size of the internal cache use to 
-# determine which symbols to keep in memory and which to flush to disk. 
-# When the cache is full, less often used symbols will be written to disk. 
-# For small to medium size projects (<1000 input files) the default value is 
-# probably good enough. For larger projects a too small cache size can cause 
-# doxygen to be busy swapping symbols to and from disk most of the time 
-# causing a significant performance penality. 
-# If the system has enough physical memory increasing the cache will improve the 
-# performance by keeping more symbols in memory. Note that the value works on 
-# a logarithmic scale so increasing the size by one will rougly double the 
-# memory usage. The cache size is given by this formula: 
-# 2^(16+SYMBOL_CACHE_SIZE). The valid range is 0..9, the default is 0, 
-# corresponding to a cache size of 2^16 = 65536 symbols
-
-SYMBOL_CACHE_SIZE      = 0
-
-#---------------------------------------------------------------------------
-# Build related configuration options
-#---------------------------------------------------------------------------
-
-# If the EXTRACT_ALL tag is set to YES doxygen will assume all entities in
-# documentation are documented, even if no documentation was available.
-# Private class members and static file members will be hidden unless
-# the EXTRACT_PRIVATE and EXTRACT_STATIC tags are set to YES
-
-EXTRACT_ALL            = YES
-
-# If the EXTRACT_PRIVATE tag is set to YES all private members of a class
-# will be included in the documentation.
-
-EXTRACT_PRIVATE        = NO
-
-# If the EXTRACT_STATIC tag is set to YES all static members of a file
-# will be included in the documentation.
-
-EXTRACT_STATIC         = YES
-
-# If the EXTRACT_LOCAL_CLASSES tag is set to YES classes (and structs)
-# defined locally in source files will be included in the documentation.
-# If set to NO only classes defined in header files are included.
-
-EXTRACT_LOCAL_CLASSES  = YES
-
-# This flag is only useful for Objective-C code. When set to YES local
-# methods, which are defined in the implementation section but not in
-# the interface are included in the documentation.
-# If set to NO (the default) only methods in the interface are included.
-
-EXTRACT_LOCAL_METHODS  = NO
-
-# If this flag is set to YES, the members of anonymous namespaces will be
-# extracted and appear in the documentation as a namespace called
-# 'anonymous_namespace{file}', where file will be replaced with the base
-# name of the file that contains the anonymous namespace. By default
-# anonymous namespace are hidden.
-
-EXTRACT_ANON_NSPACES   = NO
-
-# If the HIDE_UNDOC_MEMBERS tag is set to YES, Doxygen will hide all
-# undocumented members of documented classes, files or namespaces.
-# If set to NO (the default) these members will be included in the
-# various overviews, but no documentation section is generated.
-# This option has no effect if EXTRACT_ALL is enabled.
-
-HIDE_UNDOC_MEMBERS     = NO
-
-# If the HIDE_UNDOC_CLASSES tag is set to YES, Doxygen will hide all
-# undocumented classes that are normally visible in the class hierarchy.
-# If set to NO (the default) these classes will be included in the various
-# overviews. This option has no effect if EXTRACT_ALL is enabled.
-
-HIDE_UNDOC_CLASSES     = NO
-
-# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, Doxygen will hide all
-# friend (class|struct|union) declarations.
-# If set to NO (the default) these declarations will be included in the
-# documentation.
-
-HIDE_FRIEND_COMPOUNDS  = NO
-
-# If the HIDE_IN_BODY_DOCS tag is set to YES, Doxygen will hide any
-# documentation blocks found inside the body of a function.
-# If set to NO (the default) these blocks will be appended to the
-# function's detailed documentation block.
-
-HIDE_IN_BODY_DOCS      = NO
-
-# The INTERNAL_DOCS tag determines if documentation
-# that is typed after a \internal command is included. If the tag is set
-# to NO (the default) then the documentation will be excluded.
-# Set it to YES to include the internal documentation.
-
-INTERNAL_DOCS          = NO
-
-# If the CASE_SENSE_NAMES tag is set to NO then Doxygen will only generate
-# file names in lower-case letters. If set to YES upper-case letters are also
-# allowed. This is useful if you have classes or files whose names only differ
-# in case and if your file system supports case sensitive file names. Windows
-# and Mac users are advised to set this option to NO.
-
-CASE_SENSE_NAMES       = YES
-
-# If the HIDE_SCOPE_NAMES tag is set to NO (the default) then Doxygen
-# will show members with their full class and namespace scopes in the
-# documentation. If set to YES the scope will be hidden.
-
-HIDE_SCOPE_NAMES       = NO
-
-# If the SHOW_INCLUDE_FILES tag is set to YES (the default) then Doxygen
-# will put a list of the files that are included by a file in the documentation
-# of that file.
-
-SHOW_INCLUDE_FILES     = NO
-
-# If the INLINE_INFO tag is set to YES (the default) then a tag [inline]
-# is inserted in the documentation for inline members.
-
-INLINE_INFO            = YES
-
-# If the SORT_MEMBER_DOCS tag is set to YES (the default) then doxygen
-# will sort the (detailed) documentation of file and class members
-# alphabetically by member name. If set to NO the members will appear in
-# declaration order.
-
-SORT_MEMBER_DOCS       = YES
-
-# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the
-# brief documentation of file, namespace and class members alphabetically
-# by member name. If set to NO (the default) the members will appear in
-# declaration order.
-
-SORT_BRIEF_DOCS        = YES
-
-# If the SORT_GROUP_NAMES tag is set to YES then doxygen will sort the
-# hierarchy of group names into alphabetical order. If set to NO (the default)
-# the group names will appear in their defined order.
-
-SORT_GROUP_NAMES       = NO
-
-# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be
-# sorted by fully-qualified names, including namespaces. If set to
-# NO (the default), the class list will be sorted only by class name,
-# not including the namespace part.
-# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.
-# Note: This option applies only to the class list, not to the
-# alphabetical list.
-
-SORT_BY_SCOPE_NAME     = NO
-
-# The GENERATE_TODOLIST tag can be used to enable (YES) or
-# disable (NO) the todo list. This list is created by putting \todo
-# commands in the documentation.
-
-GENERATE_TODOLIST      = YES
-
-# The GENERATE_TESTLIST tag can be used to enable (YES) or
-# disable (NO) the test list. This list is created by putting \test
-# commands in the documentation.
-
-GENERATE_TESTLIST      = YES
-
-# The GENERATE_BUGLIST tag can be used to enable (YES) or
-# disable (NO) the bug list. This list is created by putting \bug
-# commands in the documentation.
-
-GENERATE_BUGLIST       = YES
-
-# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or
-# disable (NO) the deprecated list. This list is created by putting
-# \deprecated commands in the documentation.
-
-GENERATE_DEPRECATEDLIST= YES
-
-# The ENABLED_SECTIONS tag can be used to enable conditional
-# documentation sections, marked by \if sectionname ... \endif.
-
-ENABLED_SECTIONS       =
-
-# The MAX_INITIALIZER_LINES tag determines the maximum number of lines
-# the initial value of a variable or define consists of for it to appear in
-# the documentation. If the initializer consists of more lines than specified
-# here it will be hidden. Use a value of 0 to hide initializers completely.
-# The appearance of the initializer of individual variables and defines in the
-# documentation can be controlled using \showinitializer or \hideinitializer
-# command in the documentation regardless of this setting.
-
-MAX_INITIALIZER_LINES  = 30
-
-# Set the SHOW_USED_FILES tag to NO to disable the list of files generated
-# at the bottom of the documentation of classes and structs. If set to YES the
-# list will mention the files that were used to generate the documentation.
-
-SHOW_USED_FILES        = YES
-
-# If the sources in your project are distributed over multiple directories
-# then setting the SHOW_DIRECTORIES tag to YES will show the directory hierarchy
-# in the documentation. The default is NO.
-
-SHOW_DIRECTORIES       = YES
-
-# Set the SHOW_FILES tag to NO to disable the generation of the Files page. 
-# This will remove the Files entry from the Quick Index and from the 
-# Folder Tree View (if specified). The default is YES.
-
-SHOW_FILES             = YES
-
-# Set the SHOW_NAMESPACES tag to NO to disable the generation of the 
-# Namespaces page. 
-# This will remove the Namespaces entry from the Quick Index 
-# and from the Folder Tree View (if specified). The default is YES.
-
-SHOW_NAMESPACES        = YES
-
-# The FILE_VERSION_FILTER tag can be used to specify a program or script that
-# doxygen should invoke to get the current version for each file (typically from
-# the version control system). Doxygen will invoke the program by executing (via
-# popen()) the command <command> <input-file>, where <command> is the value of
-# the FILE_VERSION_FILTER tag, and <input-file> is the name of an input file
-# provided by doxygen. Whatever the program writes to standard output
-# is used as the file version. See the manual for examples.
-
-FILE_VERSION_FILTER    =
-
-# The LAYOUT_FILE tag can be used to specify a layout file which will be parsed by 
-# doxygen. The layout file controls the global structure of the generated output files 
-# in an output format independent way. The create the layout file that represents 
-# doxygen's defaults, run doxygen with the -l option. You can optionally specify a 
-# file name after the option, if omitted DoxygenLayout.xml will be used as the name 
-# of the layout file.
-
-LAYOUT_FILE            = 
-
-#---------------------------------------------------------------------------
-# configuration options related to warning and progress messages
-#---------------------------------------------------------------------------
-
-# The QUIET tag can be used to turn on/off the messages that are generated
-# by doxygen. Possible values are YES and NO. If left blank NO is used.
-
-QUIET                  = NO
-
-# The WARNINGS tag can be used to turn on/off the warning messages that are
-# generated by doxygen. Possible values are YES and NO. If left blank
-# NO is used.
-
-WARNINGS               = YES
-
-# If WARN_IF_UNDOCUMENTED is set to YES, then doxygen will generate warnings
-# for undocumented members. If EXTRACT_ALL is set to YES then this flag will
-# automatically be disabled.
-
-WARN_IF_UNDOCUMENTED   = YES
-
-# If WARN_IF_DOC_ERROR is set to YES, doxygen will generate warnings for
-# potential errors in the documentation, such as not documenting some
-# parameters in a documented function, or documenting parameters that
-# don't exist or using markup commands wrongly.
-
-WARN_IF_DOC_ERROR      = YES
-
-# This WARN_NO_PARAMDOC option can be abled to get warnings for
-# functions that are documented, but have no documentation for their parameters
-# or return value. If set to NO (the default) doxygen will only warn about
-# wrong or incomplete parameter documentation, but not about the absence of
-# documentation.
-
-WARN_NO_PARAMDOC       = NO
-
-# The WARN_FORMAT tag determines the format of the warning messages that
-# doxygen can produce. The string should contain the $file, $line, and $text
-# tags, which will be replaced by the file and line number from which the
-# warning originated and the warning text. Optionally the format may contain
-# $version, which will be replaced by the version of the file (if it could
-# be obtained via FILE_VERSION_FILTER)
-
-WARN_FORMAT            = "$file:$line: $text   "
-
-# The WARN_LOGFILE tag can be used to specify a file to which warning
-# and error messages should be written. If left blank the output is written
-# to stderr.
-
-WARN_LOGFILE           =
-
-#---------------------------------------------------------------------------
-# configuration options related to the input files
-#---------------------------------------------------------------------------
-
-# The INPUT tag can be used to specify the files and/or directories that contain
-# documented source files. You may enter file names like "myfile.cpp" or
-# directories like "/usr/src/myproject". Separate the files or directories
-# with spaces.
-
-INPUT                  = @srcdir@/doc/manual \
-                         @srcdir@/TODO \
-                         @srcdir@/BUGS \
-                         @srcdir@/HACKING \
-                         @srcdir@/src \
-                         @builddir@/config.h
-
-# This tag can be used to specify the character encoding of the source files
-# that doxygen parses. Internally doxygen uses the UTF-8 encoding, which is
-# also the default input encoding. Doxygen uses libiconv (or the iconv built
-# into libc) for the transcoding. See http://www.gnu.org/software/libiconv for
-# the list of possible encodings.
-
-INPUT_ENCODING         = UTF-8
-
-# If the value of the INPUT tag contains directories, you can use the
-# FILE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp
-# and *.h) to filter out the source-files in the directories. If left
-# blank the following patterns are tested:
-# *.c *.cc *.cxx *.cpp *.c++ *.java *.ii *.ixx *.ipp *.i++ *.inl *.h *.hh *.hxx
-# *.hpp *.h++ *.idl *.odl *.cs *.php *.php3 *.inc *.m *.mm *.py *.f90
-
-FILE_PATTERNS          = *.h \
-                         *.c \
-			 *.txt
-
-# The RECURSIVE tag can be used to turn specify whether or not subdirectories
-# should be searched for input files as well. Possible values are YES and NO.
-# If left blank NO is used.
-
-RECURSIVE              = YES
-
-# The EXCLUDE tag can be used to specify files and/or directories that should
-# excluded from the INPUT source files. This way you can easily exclude a
-# subdirectory from a directory tree whose root is specified with the INPUT tag.
-
-EXCLUDE                =
-
-# The EXCLUDE_SYMLINKS tag can be used select whether or not files or
-# directories that are symbolic links (a Unix filesystem feature) are excluded
-# from the input.
-
-EXCLUDE_SYMLINKS       = NO
-
-# If the value of the INPUT tag contains directories, you can use the
-# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude
-# certain files from those directories. Note that the wildcards are matched
-# against the file with absolute path, so to exclude all test directories
-# for example use the pattern */test/*
-
-EXCLUDE_PATTERNS       =
-
-# The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names
-# (namespaces, classes, functions, etc.) that should be excluded from the
-# output. The symbol name can be a fully qualified name, a word, or if the
-# wildcard * is used, a substring. Examples: ANamespace, AClass,
-# AClass::ANamespace, ANamespace::*Test
-
-EXCLUDE_SYMBOLS        =
-
-# The EXAMPLE_PATH tag can be used to specify one or more files or
-# directories that contain example code fragments that are included (see
-# the \include command).
-
-EXAMPLE_PATH           =
-
-# If the value of the EXAMPLE_PATH tag contains directories, you can use the
-# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp
-# and *.h) to filter out the source-files in the directories. If left
-# blank all files are included.
-
-EXAMPLE_PATTERNS       =
-
-# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be
-# searched for input files to be used with the \include or \dontinclude
-# commands irrespective of the value of the RECURSIVE tag.
-# Possible values are YES and NO. If left blank NO is used.
-
-EXAMPLE_RECURSIVE      = NO
-
-# The IMAGE_PATH tag can be used to specify one or more files or
-# directories that contain image that are included in the documentation (see
-# the \image command).
-
-IMAGE_PATH             = @srcdir@/doc/manual/images
-
-# The INPUT_FILTER tag can be used to specify a program that doxygen should
-# invoke to filter for each input file. Doxygen will invoke the filter program
-# by executing (via popen()) the command <filter> <input-file>, where <filter>
-# is the value of the INPUT_FILTER tag, and <input-file> is the name of an
-# input file. Doxygen will then use the output that the filter program writes
-# to standard output. 
-# If FILTER_PATTERNS is specified, this tag will be 
-# ignored.
-
-INPUT_FILTER           =
-
-# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern
-# basis. 
-# Doxygen will compare the file name with each pattern and apply the 
-# filter if there is a match. 
-# The filters are a list of the form: 
-# pattern=filter (like *.cpp=my_cpp_filter). See INPUT_FILTER for further
-# info on how filters are used. If FILTER_PATTERNS is empty, INPUT_FILTER
-# is applied to all files.
-
-FILTER_PATTERNS        =
-
-# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using
-# INPUT_FILTER) will be used to filter the input files when producing source
-# files to browse (i.e. when SOURCE_BROWSER is set to YES).
-
-FILTER_SOURCE_FILES    = NO
-
-#---------------------------------------------------------------------------
-# configuration options related to source browsing
-#---------------------------------------------------------------------------
-
-# If the SOURCE_BROWSER tag is set to YES then a list of source files will
-# be generated. Documented entities will be cross-referenced with these sources.
-# Note: To get rid of all source code in the generated output, make sure also
-# VERBATIM_HEADERS is set to NO.
-
-SOURCE_BROWSER         = YES
-
-# Setting the INLINE_SOURCES tag to YES will include the body
-# of functions and classes directly in the documentation.
-
-INLINE_SOURCES         = NO
-
-# Setting the STRIP_CODE_COMMENTS tag to YES (the default) will instruct
-# doxygen to hide any special comment blocks from generated source code
-# fragments. Normal C and C++ comments will always remain visible.
-
-STRIP_CODE_COMMENTS    = YES
-
-# If the REFERENCED_BY_RELATION tag is set to YES 
-# then for each documented function all documented
-# functions referencing it will be listed.
-
-REFERENCED_BY_RELATION = YES
-
-# If the REFERENCES_RELATION tag is set to YES 
-# then for each documented function all documented entities
-# called/used by that function will be listed.
-
-REFERENCES_RELATION    = YES
-
-# If the REFERENCES_LINK_SOURCE tag is set to YES (the default)
-# and SOURCE_BROWSER tag is set to YES, then the hyperlinks from
-# functions in REFERENCES_RELATION and REFERENCED_BY_RELATION lists will
-# link to the source code. 
-# Otherwise they will link to the documentation.
-
-REFERENCES_LINK_SOURCE = YES
-
-# If the USE_HTAGS tag is set to YES then the references to source code
-# will point to the HTML generated by the htags(1) tool instead of doxygen
-# built-in source browser. The htags tool is part of GNU's global source
-# tagging system (see http://www.gnu.org/software/global/global.html). You
-# will need version 4.8.6 or higher.
-
-USE_HTAGS              = NO
-
-# If the VERBATIM_HEADERS tag is set to YES (the default) then Doxygen
-# will generate a verbatim copy of the header file for each class for
-# which an include is specified. Set to NO to disable this.
-
-VERBATIM_HEADERS       = YES
-
-#---------------------------------------------------------------------------
-# configuration options related to the alphabetical class index
-#---------------------------------------------------------------------------
-
-# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index
-# of all compounds will be generated. Enable this if the project
-# contains a lot of classes, structs, unions or interfaces.
-
-ALPHABETICAL_INDEX     = YES
-
-# If the alphabetical index is enabled (see ALPHABETICAL_INDEX) then
-# the COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns
-# in which this list will be split (can be a number in the range [1..20])
-
-COLS_IN_ALPHA_INDEX    = 5
-
-# In case all classes in a project start with a common prefix, all
-# classes will be put under the same header in the alphabetical index.
-# The IGNORE_PREFIX tag can be used to specify one or more prefixes that
-# should be ignored while generating the index headers.
-
-IGNORE_PREFIX          =
-
-#---------------------------------------------------------------------------
-# configuration options related to the HTML output
-#---------------------------------------------------------------------------
-
-# If the GENERATE_HTML tag is set to YES (the default) Doxygen will
-# generate HTML output.
-
-GENERATE_HTML          = @doxygen_as_html@
-
-# The HTML_OUTPUT tag is used to specify where the HTML docs will be put.
-# If a relative path is entered the value of OUTPUT_DIRECTORY will be
-# put in front of it. If left blank `html' will be used as the default path.
-
-HTML_OUTPUT            = html
-
-# The HTML_FILE_EXTENSION tag can be used to specify the file extension for
-# each generated HTML page (for example: .htm,.php,.asp). If it is left blank
-# doxygen will generate files with .html extension.
-
-HTML_FILE_EXTENSION    = .html
-
-# The HTML_HEADER tag can be used to specify a personal HTML header for
-# each generated HTML page. If it is left blank doxygen will generate a
-# standard header.
-
-HTML_HEADER            =
-
-# The HTML_FOOTER tag can be used to specify a personal HTML footer for
-# each generated HTML page. If it is left blank doxygen will generate a
-# standard footer.
-
-HTML_FOOTER            =
-
-# The HTML_STYLESHEET tag can be used to specify a user-defined cascading
-# style sheet that is used by each HTML page. It can be used to
-# fine-tune the look of the HTML output. If the tag is left blank doxygen
-# will generate a default style sheet. Note that doxygen will try to copy
-# the style sheet file to the HTML output directory, so don't put your own
-# stylesheet in the HTML output directory as well, or it will be erased!
-
-HTML_STYLESHEET        =
-
-# If the HTML_ALIGN_MEMBERS tag is set to YES, the members of classes,
-# files or namespaces will be aligned in HTML using tables. If set to
-# NO a bullet list will be used.
-
-HTML_ALIGN_MEMBERS     = YES
-
-# If the HTML_DYNAMIC_SECTIONS tag is set to YES then the generated HTML 
-# documentation will contain sections that can be hidden and shown after the 
-# page has loaded. For this to work a browser that supports 
-# JavaScript and DHTML is required (for instance Mozilla 1.0+, Firefox 
-# Netscape 6.0+, Internet explorer 5.0+, Konqueror, or Safari).
-
-HTML_DYNAMIC_SECTIONS  = NO
-
-# If the GENERATE_DOCSET tag is set to YES, additional index files
-# will be generated that can be used as input for Apple's Xcode 3
-# integrated development environment, introduced with OSX 10.5 (Leopard).
-# To create a documentation set, doxygen will generate a Makefile in the
-# HTML output directory. Running make will produce the docset in that
-# directory and running "make install" will install the docset in
-# ~/Library/Developer/Shared/Documentation/DocSets so that Xcode will find
-# it at startup.
-# See http://developer.apple.com/tools/creatingdocsetswithdoxygen.html for more information.
-
-GENERATE_DOCSET        = NO
-
-# When GENERATE_DOCSET tag is set to YES, this tag determines the name of the
-# feed. A documentation feed provides an umbrella under which multiple
-# documentation sets from a single provider (such as a company or product suite)
-# can be grouped.
-
-DOCSET_FEEDNAME        = "Doxygen generated docs"
-
-# When GENERATE_DOCSET tag is set to YES, this tag specifies a string that
-# should uniquely identify the documentation set bundle. This should be a
-# reverse domain-name style string, e.g. com.mycompany.MyDocSet. Doxygen
-# will append .docset to the name.
-
-DOCSET_BUNDLE_ID       = org.doxygen.Project
-
-# If the GENERATE_HTMLHELP tag is set to YES, additional index files 
-# will be generated that can be used as input for tools like the 
-# Microsoft HTML help workshop to generate a compiled HTML help file (.chm) 
-# of the generated HTML documentation.
-
-GENERATE_HTMLHELP      = NO
-
-# If the GENERATE_HTMLHELP tag is set to YES, the CHM_FILE tag can
-# be used to specify the file name of the resulting .chm file. You
-# can add a path in front of the file if the result should not be
-# written to the html output directory.
-
-CHM_FILE               =
-
-# If the GENERATE_HTMLHELP tag is set to YES, the HHC_LOCATION tag can
-# be used to specify the location (absolute path including file name) of
-# the HTML help compiler (hhc.exe). If non-empty doxygen will try to run
-# the HTML help compiler on the generated index.hhp.
-
-HHC_LOCATION           =
-
-# If the GENERATE_HTMLHELP tag is set to YES, the GENERATE_CHI flag
-# controls if a separate .chi index file is generated (YES) or that
-# it should be included in the master .chm file (NO).
-
-GENERATE_CHI           = NO
-
-# If the GENERATE_HTMLHELP tag is set to YES, the CHM_INDEX_ENCODING 
-# is used to encode HtmlHelp index (hhk), content (hhc) and project file 
-# content.
-
-CHM_INDEX_ENCODING     = 
-
-# If the GENERATE_HTMLHELP tag is set to YES, the BINARY_TOC flag
-# controls whether a binary table of contents is generated (YES) or a
-# normal table of contents (NO) in the .chm file.
-
-BINARY_TOC             = NO
-
-# The TOC_EXPAND flag can be set to YES to add extra items for group members
-# to the contents of the HTML help documentation and to the tree view.
-
-TOC_EXPAND             = NO
-
-# If the GENERATE_QHP tag is set to YES and both QHP_NAMESPACE and QHP_VIRTUAL_FOLDER 
-# are set, an additional index file will be generated that can be used as input for 
-# Qt's qhelpgenerator to generate a Qt Compressed Help (.qch) of the generated 
-# HTML documentation.
-
-GENERATE_QHP           = NO
-
-# If the QHG_LOCATION tag is specified, the QCH_FILE tag can 
-# be used to specify the file name of the resulting .qch file. 
-# The path specified is relative to the HTML output folder.
-
-QCH_FILE               = 
-
-# The QHP_NAMESPACE tag specifies the namespace to use when generating 
-# Qt Help Project output. For more information please see 
-# http://doc.trolltech.com/qthelpproject.html#namespace
-
-QHP_NAMESPACE          = 
-
-# The QHP_VIRTUAL_FOLDER tag specifies the namespace to use when generating 
-# Qt Help Project output. For more information please see 
-# http://doc.trolltech.com/qthelpproject.html#virtual-folders
-
-QHP_VIRTUAL_FOLDER     = doc
-
-# If QHP_CUST_FILTER_NAME is set, it specifies the name of a custom filter to add. 
-# For more information please see 
-# http://doc.trolltech.com/qthelpproject.html#custom-filters
-
-QHP_CUST_FILTER_NAME   = 
-
-# The QHP_CUST_FILT_ATTRS tag specifies the list of the attributes of the custom filter to add.For more information please see 
-# <a href="http://doc.trolltech.com/qthelpproject.html#custom-filters">Qt Help Project / Custom Filters</a>.
-
-QHP_CUST_FILTER_ATTRS  = 
-
-# The QHP_SECT_FILTER_ATTRS tag specifies the list of the attributes this project's 
-# filter section matches. 
-# <a href="http://doc.trolltech.com/qthelpproject.html#filter-attributes">Qt Help Project / Filter Attributes</a>.
-
-QHP_SECT_FILTER_ATTRS  = 
-
-# If the GENERATE_QHP tag is set to YES, the QHG_LOCATION tag can 
-# be used to specify the location of Qt's qhelpgenerator. 
-# If non-empty doxygen will try to run qhelpgenerator on the generated 
-# .qhp file.
-
-QHG_LOCATION           = 
-
-# The DISABLE_INDEX tag can be used to turn on/off the condensed index at
-# top of each HTML page. The value NO (the default) enables the index and
-# the value YES disables it.
-
-DISABLE_INDEX          = NO
-
-# This tag can be used to set the number of enum values (range [1..20])
-# that doxygen will group on one line in the generated HTML documentation.
-
-ENUM_VALUES_PER_LINE   = 4
-
-# The GENERATE_TREEVIEW tag is used to specify whether a tree-like index 
-# structure should be generated to display hierarchical information. 
-# If the tag value is set to FRAME, a side panel will be generated 
-# containing a tree-like index structure (just like the one that 
-# is generated for HTML Help). For this to work a browser that supports
-# JavaScript, DHTML, CSS and frames is required (for instance Mozilla 1.0+,
-# Netscape 6.0+, Internet explorer 5.0+, or Konqueror). Windows users are
-# probably better off using the HTML help feature. Other possible values 
-# for this tag are: HIERARCHIES, which will generate the Groups, Directories, 
-# and Class Hierarchy pages using a tree view instead of an ordered list; 
-# ALL, which combines the behavior of FRAME and HIERARCHIES; and NONE, which 
-# disables this behavior completely. For backwards compatibility with previous 
-# releases of Doxygen, the values YES and NO are equivalent to FRAME and NONE 
-# respectively.
-
-GENERATE_TREEVIEW      = YES
-
-# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be
-# used to set the initial width (in pixels) of the frame in which the tree
-# is shown.
-
-TREEVIEW_WIDTH         = 250
-
-# Use this tag to change the font size of Latex formulas included 
-# as images in the HTML documentation. The default is 10. Note that 
-# when you change the font size after a successful doxygen run you need 
-# to manually remove any form_*.png images from the HTML output directory 
-# to force them to be regenerated.
-
-FORMULA_FONTSIZE       = 10
-
-#---------------------------------------------------------------------------
-# configuration options related to the LaTeX output
-#---------------------------------------------------------------------------
-
-# If the GENERATE_LATEX tag is set to YES (the default) Doxygen will
-# generate Latex output.
-
-GENERATE_LATEX         = @doxygen_as_pdf@
-
-# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put.
-# If a relative path is entered the value of OUTPUT_DIRECTORY will be
-# put in front of it. If left blank `latex' will be used as the default path.
-
-LATEX_OUTPUT           = latex
-
-# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be
-# invoked. If left blank `latex' will be used as the default command name.
-
-LATEX_CMD_NAME         = pdflatex
-
-# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to
-# generate index for LaTeX. If left blank `makeindex' will be used as the
-# default command name.
-
-MAKEINDEX_CMD_NAME     = makeindex
-
-# If the COMPACT_LATEX tag is set to YES Doxygen generates more compact
-# LaTeX documents. This may be useful for small projects and may help to
-# save some trees in general.
-
-COMPACT_LATEX          = YES
-
-# The PAPER_TYPE tag can be used to set the paper type that is used
-# by the printer. Possible values are: a4, a4wide, letter, legal and
-# executive. If left blank a4wide will be used.
-
-PAPER_TYPE             = a4wide
-
-# The EXTRA_PACKAGES tag can be to specify one or more names of LaTeX
-# packages that should be included in the LaTeX output.
-
-EXTRA_PACKAGES         =
-
-# The LATEX_HEADER tag can be used to specify a personal LaTeX header for
-# the generated latex document. The header should contain everything until
-# the first chapter. If it is left blank doxygen will generate a
-# standard header. Notice: only use this tag if you know what you are doing!
-
-LATEX_HEADER           =
-
-# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated
-# is prepared for conversion to pdf (using ps2pdf). The pdf file will
-# contain links (just like the HTML output) instead of page references
-# This makes the output suitable for online browsing using a pdf viewer.
-
-PDF_HYPERLINKS         = YES
-
-# If the USE_PDFLATEX tag is set to YES, pdflatex will be used instead of
-# plain latex in the generated Makefile. Set this option to YES to get a
-# higher quality PDF documentation.
-
-USE_PDFLATEX           = YES
-
-# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \\batchmode.
-# command to the generated LaTeX files. This will instruct LaTeX to keep
-# running if errors occur, instead of asking the user for help.
-# This option is also used when generating formulas in HTML.
-
-LATEX_BATCHMODE        = YES
-
-# If LATEX_HIDE_INDICES is set to YES then doxygen will not
-# include the index chapters (such as File Index, Compound Index, etc.)
-# in the output.
-
-LATEX_HIDE_INDICES     = NO
-
-#---------------------------------------------------------------------------
-# configuration options related to the RTF output
-#---------------------------------------------------------------------------
-
-# If the GENERATE_RTF tag is set to YES Doxygen will generate RTF output
-# The RTF output is optimized for Word 97 and may not look very pretty with
-# other RTF readers or editors.
-
-GENERATE_RTF           = NO
-
-# The RTF_OUTPUT tag is used to specify where the RTF docs will be put.
-# If a relative path is entered the value of OUTPUT_DIRECTORY will be
-# put in front of it. If left blank `rtf' will be used as the default path.
-
-RTF_OUTPUT             = rtf
-
-# If the COMPACT_RTF tag is set to YES Doxygen generates more compact
-# RTF documents. This may be useful for small projects and may help to
-# save some trees in general.
-
-COMPACT_RTF            = NO
-
-# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated
-# will contain hyperlink fields. The RTF file will
-# contain links (just like the HTML output) instead of page references.
-# This makes the output suitable for online browsing using WORD or other
-# programs which support those fields.
-# Note: wordpad (write) and others do not support links.
-
-RTF_HYPERLINKS         = NO
-
-# Load stylesheet definitions from file. Syntax is similar to doxygen's
-# config file, i.e. a series of assignments. You only have to provide
-# replacements, missing definitions are set to their default value.
-
-RTF_STYLESHEET_FILE    =
-
-# Set optional variables used in the generation of an rtf document.
-# Syntax is similar to doxygen's config file.
-
-RTF_EXTENSIONS_FILE    =
-
-#---------------------------------------------------------------------------
-# configuration options related to the man page output
-#---------------------------------------------------------------------------
-
-# If the GENERATE_MAN tag is set to YES (the default) Doxygen will
-# generate man pages
-
-GENERATE_MAN           = NO
-
-# The MAN_OUTPUT tag is used to specify where the man pages will be put.
-# If a relative path is entered the value of OUTPUT_DIRECTORY will be
-# put in front of it. If left blank `man' will be used as the default path.
-
-MAN_OUTPUT             = man
-
-# The MAN_EXTENSION tag determines the extension that is added to
-# the generated man pages (default is the subroutine's section .3)
-
-MAN_EXTENSION          = .3
-
-# If the MAN_LINKS tag is set to YES and Doxygen generates man output,
-# then it will generate one additional man file for each entity
-# documented in the real man page(s). These additional files
-# only source the real man page, but without them the man command
-# would be unable to find the correct page. The default is NO.
-
-MAN_LINKS              = NO
-
-#---------------------------------------------------------------------------
-# configuration options related to the XML output
-#---------------------------------------------------------------------------
-
-# If the GENERATE_XML tag is set to YES Doxygen will
-# generate an XML file that captures the structure of
-# the code including all documentation.
-
-GENERATE_XML           = NO
-
-# The XML_OUTPUT tag is used to specify where the XML pages will be put.
-# If a relative path is entered the value of OUTPUT_DIRECTORY will be
-# put in front of it. If left blank `xml' will be used as the default path.
-
-XML_OUTPUT             = xml
-
-# The XML_SCHEMA tag can be used to specify an XML schema,
-# which can be used by a validating XML parser to check the
-# syntax of the XML files.
-
-XML_SCHEMA             =
-
-# The XML_DTD tag can be used to specify an XML DTD,
-# which can be used by a validating XML parser to check the
-# syntax of the XML files.
-
-XML_DTD                =
-
-# If the XML_PROGRAMLISTING tag is set to YES Doxygen will
-# dump the program listings (including syntax highlighting
-# and cross-referencing information) to the XML output. Note that
-# enabling this will significantly increase the size of the XML output.
-
-XML_PROGRAMLISTING     = YES
-
-#---------------------------------------------------------------------------
-# configuration options for the AutoGen Definitions output
-#---------------------------------------------------------------------------
-
-# If the GENERATE_AUTOGEN_DEF tag is set to YES Doxygen will
-# generate an AutoGen Definitions (see autogen.sf.net) file
-# that captures the structure of the code including all
-# documentation. Note that this feature is still experimental
-# and incomplete at the moment.
-
-GENERATE_AUTOGEN_DEF   = NO
-
-#---------------------------------------------------------------------------
-# configuration options related to the Perl module output
-#---------------------------------------------------------------------------
-
-# If the GENERATE_PERLMOD tag is set to YES Doxygen will
-# generate a Perl module file that captures the structure of
-# the code including all documentation. Note that this
-# feature is still experimental and incomplete at the
-# moment.
-
-GENERATE_PERLMOD       = NO
-
-# If the PERLMOD_LATEX tag is set to YES Doxygen will generate
-# the necessary Makefile rules, Perl scripts and LaTeX code to be able
-# to generate PDF and DVI output from the Perl module output.
-
-PERLMOD_LATEX          = NO
-
-# If the PERLMOD_PRETTY tag is set to YES the Perl module output will be
-# nicely formatted so it can be parsed by a human reader. 
-# This is useful 
-# if you want to understand what is going on. 
-# On the other hand, if this 
-# tag is set to NO the size of the Perl module output will be much smaller
-# and Perl will parse it just the same.
-
-PERLMOD_PRETTY         = YES
-
-# The names of the make variables in the generated doxyrules.make file
-# are prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX.
-# This is useful so different doxyrules.make files included by the same
-# Makefile don't overwrite each other's variables.
-
-PERLMOD_MAKEVAR_PREFIX =
-
-#---------------------------------------------------------------------------
-# Configuration options related to the preprocessor
-#---------------------------------------------------------------------------
-
-# If the ENABLE_PREPROCESSING tag is set to YES (the default) Doxygen will
-# evaluate all C-preprocessor directives found in the sources and include
-# files.
-
-ENABLE_PREPROCESSING   = YES
-
-# If the MACRO_EXPANSION tag is set to YES Doxygen will expand all macro
-# names in the source code. If set to NO (the default) only conditional
-# compilation will be performed. Macro expansion can be done in a controlled
-# way by setting EXPAND_ONLY_PREDEF to YES.
-
-MACRO_EXPANSION        = NO
-
-# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES
-# then the macro expansion is limited to the macros specified with the
-# PREDEFINED and EXPAND_AS_DEFINED tags.
-
-EXPAND_ONLY_PREDEF     = NO
-
-# If the SEARCH_INCLUDES tag is set to YES (the default) the includes files
-# in the INCLUDE_PATH (see below) will be search if a #include is found.
-
-SEARCH_INCLUDES        = YES
-
-# The INCLUDE_PATH tag can be used to specify one or more directories that
-# contain include files that are not input files but should be processed by
-# the preprocessor.
-
-INCLUDE_PATH           =
-
-# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard
-# patterns (like *.h and *.hpp) to filter out the header-files in the
-# directories. If left blank, the patterns specified with FILE_PATTERNS will
-# be used.
-
-INCLUDE_FILE_PATTERNS  = *.h
-
-# The PREDEFINED tag can be used to specify one or more macro names that
-# are defined before the preprocessor is started (similar to the -D option of
-# gcc). The argument of the tag is a list of macros of the form: name
-# or name=definition (no spaces). If the definition and the = are
-# omitted =1 is assumed. To prevent a macro definition from being
-# undefined via #undef or recursively expanded use the := operator
-# instead of the = operator.
-
-PREDEFINED             = HAVE_CONFIG_H
-
-# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then
-# this tag can be used to specify a list of macro names that should be expanded.
-# The macro definition that is found in the sources will be used.
-# Use the PREDEFINED tag if you want to use a different macro definition.
-
-EXPAND_AS_DEFINED      =
-
-# If the SKIP_FUNCTION_MACROS tag is set to YES (the default) then
-# doxygen's preprocessor will remove all function-like macros that are alone
-# on a line, have an all uppercase name, and do not end with a semicolon. Such
-# function macros are typically used for boiler-plate code, and will confuse
-# the parser if not removed.
-
-SKIP_FUNCTION_MACROS   = YES
-
-#---------------------------------------------------------------------------
-# Configuration::additions related to external references
-#---------------------------------------------------------------------------
-
-# The TAGFILES option can be used to specify one or more tagfiles.
-# Optionally an initial location of the external documentation
-# can be added for each tagfile. The format of a tag file without
-# this location is as follows:
-#  
-#   TAGFILES = file1 file2 ...
-# Adding location for the tag files is done as follows:
-#  
-#   TAGFILES = file1=loc1 "file2 = loc2" ...
-# where "loc1" and "loc2" can be relative or absolute paths or
-# URLs. If a location is present for each tag, the installdox tool
-# does not have to be run to correct the links.
-# Note that each tag file must have a unique name
-# (where the name does NOT include the path)
-# If a tag file is not located in the directory in which doxygen
-# is run, you must also specify the path to the tagfile here.
-
-TAGFILES               =
-
-# When a file name is specified after GENERATE_TAGFILE, doxygen will create
-# a tag file that is based on the input files it reads.
-
-GENERATE_TAGFILE       =
-
-# If the ALLEXTERNALS tag is set to YES all external classes will be listed
-# in the class index. If set to NO only the inherited external classes
-# will be listed.
-
-ALLEXTERNALS           = NO
-
-# If the EXTERNAL_GROUPS tag is set to YES all external groups will be listed
-# in the modules index. If set to NO, only the current project's groups will
-# be listed.
-
-EXTERNAL_GROUPS        = YES
-
-# The PERL_PATH should be the absolute path and name of the perl script
-# interpreter (i.e. the result of `which perl').
-
-PERL_PATH              = /usr/bin/perl
-
-#---------------------------------------------------------------------------
-# Configuration options related to the dot tool
-#---------------------------------------------------------------------------
-
-# If the CLASS_DIAGRAMS tag is set to YES (the default) Doxygen will
-# generate a inheritance diagram (in HTML, RTF and LaTeX) for classes with base
-# or super classes. Setting the tag to NO turns the diagrams off. Note that
-# this option is superseded by the HAVE_DOT option below. This is only a
-# fallback. It is recommended to install and use dot, since it yields more
-# powerful graphs.
-
-CLASS_DIAGRAMS         = YES
-
-# You can define message sequence charts within doxygen comments using the \msc
-# command. Doxygen will then run the mscgen tool (see
-# http://www.mcternan.me.uk/mscgen/) to produce the chart and insert it in the
-# documentation. The MSCGEN_PATH tag allows you to specify the directory where
-# the mscgen tool resides. If left empty the tool is assumed to be found in the
-# default search path.
-
-MSCGEN_PATH            =
-
-# If set to YES, the inheritance and collaboration graphs will hide
-# inheritance and usage relations if the target is undocumented
-# or is not a class.
-
-HIDE_UNDOC_RELATIONS   = YES
-
-# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is
-# available from the path. This tool is part of Graphviz, a graph visualization
-# toolkit from AT&T and Lucent Bell Labs. The other options in this section
-# have no effect if this option is set to NO (the default)
-
-HAVE_DOT               = YES
-
-# By default doxygen will write a font called FreeSans.ttf to the output 
-# directory and reference it in all dot files that doxygen generates. This 
-# font does not include all possible unicode characters however, so when you need 
-# these (or just want a differently looking font) you can specify the font name 
-# using DOT_FONTNAME. You need need to make sure dot is able to find the font, 
-# which can be done by putting it in a standard location or by setting the 
-# DOTFONTPATH environment variable or by setting DOT_FONTPATH to the directory 
-# containing the font.
-
-DOT_FONTNAME           = FreeSans
-
-# The DOT_FONTSIZE tag can be used to set the size of the font of dot graphs. 
-# The default size is 10pt.
-
-DOT_FONTSIZE           = 10
-
-# By default doxygen will tell dot to use the output directory to look for the 
-# FreeSans.ttf font (which doxygen will put there itself). If you specify a 
-# different font using DOT_FONTNAME you can set the path where dot 
-# can find it using this tag.
-
-DOT_FONTPATH           = 
-
-# If the CLASS_GRAPH and HAVE_DOT tags are set to YES then doxygen
-# will generate a graph for each documented class showing the direct and
-# indirect inheritance relations. Setting this tag to YES will force the
-# the CLASS_DIAGRAMS tag to NO.
-
-CLASS_GRAPH            = YES
-
-# If the COLLABORATION_GRAPH and HAVE_DOT tags are set to YES then doxygen
-# will generate a graph for each documented class showing the direct and
-# indirect implementation dependencies (inheritance, containment, and
-# class references variables) of the class with other documented classes.
-
-COLLABORATION_GRAPH    = YES
-
-# If the GROUP_GRAPHS and HAVE_DOT tags are set to YES then doxygen
-# will generate a graph for groups, showing the direct groups dependencies
-
-GROUP_GRAPHS           = YES
-
-# If the UML_LOOK tag is set to YES doxygen will generate inheritance and
-# collaboration diagrams in a style similar to the OMG's Unified Modeling
-# Language.
-
-UML_LOOK               = NO
-
-# If set to YES, the inheritance and collaboration graphs will show the
-# relations between templates and their instances.
-
-TEMPLATE_RELATIONS     = YES
-
-# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDE_GRAPH, and HAVE_DOT
-# tags are set to YES then doxygen will generate a graph for each documented
-# file showing the direct and indirect include dependencies of the file with
-# other documented files.
-
-INCLUDE_GRAPH          = YES
-
-# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDED_BY_GRAPH, and
-# HAVE_DOT tags are set to YES then doxygen will generate a graph for each
-# documented header file showing the documented files that directly or
-# indirectly include this file.
-
-INCLUDED_BY_GRAPH      = YES
-
-# If the CALL_GRAPH and HAVE_DOT options are set to YES then
-# doxygen will generate a call dependency graph for every global function
-# or class method. Note that enabling this option will significantly increase
-# the time of a run. So in most cases it will be better to enable call graphs
-# for selected functions only using the \callgraph command.
-
-CALL_GRAPH             = NO
-
-# If the CALLER_GRAPH and HAVE_DOT tags are set to YES then
-# doxygen will generate a caller dependency graph for every global function
-# or class method. Note that enabling this option will significantly increase
-# the time of a run. So in most cases it will be better to enable caller
-# graphs for selected functions only using the \callergraph command.
-
-CALLER_GRAPH           = NO
-
-# If the GRAPHICAL_HIERARCHY and HAVE_DOT tags are set to YES then doxygen
-# will graphical hierarchy of all classes instead of a textual one.
-
-GRAPHICAL_HIERARCHY    = YES
-
-# If the DIRECTORY_GRAPH, SHOW_DIRECTORIES and HAVE_DOT tags are set to YES
-# then doxygen will show the dependencies a directory has on other directories
-# in a graphical way. The dependency relations are determined by the #include
-# relations between the files in the directories.
-
-DIRECTORY_GRAPH        = YES
-
-# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images
-# generated by dot. Possible values are png, jpg, or gif
-# If left blank png will be used.
-
-DOT_IMAGE_FORMAT       = png
-
-# The tag DOT_PATH can be used to specify the path where the dot tool can be
-# found. If left blank, it is assumed the dot tool can be found in the path.
-
-DOT_PATH               =
-
-# The DOTFILE_DIRS tag can be used to specify one or more directories that
-# contain dot files that are included in the documentation (see the
-# \dotfile command).
-
-DOTFILE_DIRS           =
-
-# The DOT_GRAPH_MAX_NODES tag can be used to set the maximum number of 
-# nodes that will be shown in the graph. If the number of nodes in a graph
-# becomes larger than this value, doxygen will truncate the graph, which is
-# visualized by representing a node as a red box. Note that doxygen if the
-# number of direct children of the root node in a graph is already larger than
-# DOT_GRAPH_MAX_NODES then the graph will not be shown at all. Also note
-# that the size of a graph can be further restricted by MAX_DOT_GRAPH_DEPTH.
-
-DOT_GRAPH_MAX_NODES    = 50
-
-# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the
-# graphs generated by dot. A depth value of 3 means that only nodes reachable
-# from the root by following a path via at most 3 edges will be shown. Nodes
-# that lay further from the root node will be omitted. Note that setting this
-# option to 1 or 2 may greatly reduce the computation time needed for large
-# code bases. Also note that the size of a graph can be further restricted by
-# DOT_GRAPH_MAX_NODES. Using a depth of 0 means no depth restriction.
-
-MAX_DOT_GRAPH_DEPTH    = 0
-
-# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent
-# background. This is disabled by default, because dot on Windows does not 
-# seem to support this out of the box. Warning: Depending on the platform used, 
-# enabling this option may lead to badly anti-aliased labels on the edges of 
-# a graph (i.e. they become hard to read).
-
-DOT_TRANSPARENT        = NO
-
-# Set the DOT_MULTI_TARGETS tag to YES allow dot to generate multiple output
-# files in one run (i.e. multiple -o and -T options on the command line). This
-# makes dot run faster, but since only newer versions of dot (>1.8.10)
-# support this, this feature is disabled by default.
-
-DOT_MULTI_TARGETS      = NO
-
-# If the GENERATE_LEGEND tag is set to YES (the default) Doxygen will
-# generate a legend page explaining the meaning of the various boxes and
-# arrows in the dot generated graphs.
-
-GENERATE_LEGEND        = YES
-
-# If the DOT_CLEANUP tag is set to YES (the default) Doxygen will
-# remove the intermediate dot files that are used to generate
-# the various graphs.
-
-DOT_CLEANUP            = YES
-
-#---------------------------------------------------------------------------
-# Options related to the search engine
-#---------------------------------------------------------------------------
-
-# The SEARCHENGINE tag specifies whether or not a search engine should be
-# used. If set to NO the values of all tags below this one will be ignored.
-
-SEARCHENGINE           = NO
diff --git b/Makefile.am a/Makefile.am
index 2ddc96d3d..452442a62 100644
--- b/Makefile.am
+++ a/Makefile.am
@@ -10,6 +10,11 @@ nobase_dist_pkgdata_DATA = \
 	contrib/libdcc/dcc_stdio.h \
 	contrib/libdcc/example.c \
 	contrib/libdcc/README \
+	contrib/libfdc/fdc.h \
+	contrib/libfdc/fdc_printf.c \
+	contrib/libfdc/fdc_putchar.c \
+	contrib/libfdc/fdc_putchar.h \
+	contrib/libfdc/Makefile \
 	contrib/99-openocd.rules
 
 if INTERNAL_JIMTCL
diff --git b/README.md a/README.md
new file mode 100644
index 000000000..81ccfb2a7
--- /dev/null
+++ a/README.md
@@ -0,0 +1,4 @@
+mips_mAptiv
+===========
+
+Added support for MIPS microAptiv core -
diff --git b/configure.ac a/configure.ac
index 36058466b..2fb42d0d8 100644
--- b/configure.ac
+++ a/configure.ac
@@ -1,5 +1,5 @@
 AC_PREREQ(2.64)
-AC_INIT([openocd], [0.9.0-dev],
+AC_INIT([openocd], [0.10.0.3-imagination],
   [OpenOCD Mailing List <openocd-devel@lists.sourceforge.net>])
 AC_CONFIG_SRCDIR([src/openocd.c])
 
diff --git b/contrib/libfdc/fdc.h a/contrib/libfdc/fdc.h
new file mode 100644
index 000000000..5747c728f
--- /dev/null
+++ a/contrib/libfdc/fdc.h
@@ -0,0 +1,36 @@
+#ifndef FDC_H
+#define FDC_H
+
+typedef int FDC_S32;
+typedef unsigned int FDC_U32;
+typedef unsigned char FDC_U8;
+typedef unsigned short FDC_U16;
+typedef signed short FDC_S16;
+
+enum {
+	FDC_SUCCESS=0,
+	FDC_ERR_UNSPECIFIED=-1,
+	FDC_ERR_INVALID_ARG=-2,
+	FDC_ERR_CHANNEL_ALREADY_CLAIMED=-3,
+	FDC_ERR_NO_MIPS_PROBE_ATTACHED=-4,		
+	FDC_ERR_FDC_EMULATION_SYSCALL_NOT_INTERCEPTED=-5,
+	FDC_ERR_PROCESSOR_HAS_NO_CDMM=-6,
+	FDC_ERR_CDMM_BASE_ADDR_BAD_ALIGNMENT=-7,
+	FDC_ERR_CDMM_BASE_ADDR_NOT_ACCESSIBLE_VIA_KSEG1=-8,	
+	FDC_ERR_NO_FDC_HW_FOUND=-9,
+	FDC_ERR_INVALID_PROCESSOR_NUMBER=-10,
+	FDC_ERR_INVALID_VPE_NUMBER=-11,			
+};
+
+enum {
+	false=-1,
+	true=0
+};
+
+int fdc_init(void);
+int fdc_printf(const char *format, ...);
+int fdc_sprintf(char *out, const char *format, ...);
+void fdc_flush (void) __attribute__ ((noinline));;
+void fdc_putchar(int c) __attribute__ ((noinline));
+
+#endif	/*FDC_H*/
diff --git b/contrib/libfdc/fdc_printf.c a/contrib/libfdc/fdc_printf.c
new file mode 100644
index 000000000..6db804fd6
--- /dev/null
+++ a/contrib/libfdc/fdc_printf.c
@@ -0,0 +1,330 @@
+/*
+	Copyright 2001, 2002 Georges Menie (www.menie.org)
+	stdarg version contributed by Christian Ettinger
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+/*
+	putchar (fdc_putchar for now) is the only external dependency for this file,
+	if you have a working putchar, leave it commented out. If not, uncomment the define below and
+	replace outbyte(c) by your own function call.
+
+*/
+
+#include <stdarg.h>
+#include "fdc.h"
+
+void fdc_printchar(char **str, int c) __attribute__ ((noinline));
+void fdc_printchar(char **str, int c)
+{
+
+	if (str)
+	{
+		**str = c;
+		++(*str);
+	}
+	else
+		fdc_putchar(c);
+}
+
+#define PAD_RIGHT 1
+#define PAD_ZERO 2
+int fdc_prints(char **out, const char *string, int width, int pad)
+{
+	register int pc = 0, padchar = ' ';
+
+	if (width > 0)
+	{
+		register int len = 0;
+		register const char *ptr;
+
+		for (ptr = string; *ptr; ++ptr)
+			++len;
+
+		if (len >= width)
+			width = 0;
+
+		else
+			width -= len;
+
+		if (pad & PAD_ZERO)
+			padchar = '0';
+	}
+
+	if (!(pad & PAD_RIGHT))
+	{
+		for ( ; width > 0; --width)
+		{
+			fdc_printchar (out, padchar);
+			++pc;
+		}
+	}
+
+	for ( ; *string ; ++string)
+	{
+		fdc_printchar (out, *string);
+		++pc;
+	}
+
+	for ( ; width > 0; --width)
+	{
+		fdc_printchar (out, padchar);
+		++pc;
+	}
+
+	return pc;
+}
+
+/* the following should be enough for 32 bit int */
+#define PRINT_BUF_LEN 24
+
+int fdc_printi(char **out, int i, int b, int sg, int width, int pad, int letbase)
+{
+	char print_buf[PRINT_BUF_LEN];
+	register char *s;
+	register int t, neg = 0, pc = 0;
+	register unsigned int u = i;
+
+	if (i == 0)
+	{
+		print_buf[0] = '0';
+		print_buf[1] = '\0';
+		return fdc_prints (out, print_buf, width, pad);
+	}
+
+	if (sg && b == 10 && i < 0)
+	{
+		neg = 1;
+		u = -i;
+	}
+
+	s = print_buf + PRINT_BUF_LEN-1;
+	*s = '\0';
+
+	while (u)
+	{
+		t = u % b;
+		if( t >= 10 )
+			t += letbase - '0' - 10;
+		*--s = t + '0';
+		u /= b;
+	}
+
+	if (neg)
+  {
+		if( width && (pad & PAD_ZERO) )
+		{
+			fdc_printchar (out, '-');
+			++pc;
+			--width;
+		}
+		else
+		{
+			*--s = '-';
+		}
+	}
+
+	return pc + fdc_prints (out, s, width, pad);
+}
+
+int fdc_print(char **out, const char *format, va_list args )
+{
+	register int width, pad;
+	register int pc = 0;
+	char scr[2];
+
+	int i = 0;
+
+	for (; *format != 0; ++format)
+	{
+		i++;
+
+		if (*format == '%')
+		{
+			++format;
+			width = pad = 0;
+
+			if (*format == '\0')
+				break;
+
+			if (*format == '%')
+				goto out;
+
+
+			if (*format == '-')
+			{
+				++format;
+				pad = PAD_RIGHT;
+			}
+
+			while (*format == '0')
+			{
+				++format;
+				pad |= PAD_ZERO;
+			}
+
+			for ( ; *format >= '0' && *format <= '9'; ++format)
+			{
+				width *= 10;
+				width += *format - '0';
+			}
+
+			if( *format == 's' )
+			{
+				register char *s = (char *)va_arg( args, int );
+				pc += fdc_prints (out, s?s:"(null)", width, pad);
+				continue;
+			}
+
+			if( *format == 'd' )
+			{
+				pc += fdc_printi (out, va_arg( args, int ), 10, 1, width, pad, 'a');
+				continue;
+			}
+
+			if( *format == 'x' )
+			{
+				pc += fdc_printi (out, va_arg( args, int ), 16, 0, width, pad, 'a');
+				continue;
+			}
+
+			if( *format == 'X' )
+			{
+				pc += fdc_printi (out, va_arg( args, int ), 16, 0, width, pad, 'A');
+				continue;
+			}
+
+			if( *format == 'u' )
+			{
+				pc += fdc_printi (out, va_arg( args, int ), 10, 0, width, pad, 'a');
+				continue;
+			}
+
+			if( *format == 'c' )
+			{
+				/* char are converted to int then pushed on the stack */
+				scr[0] = (char)va_arg( args, int );
+				scr[1] = '\0';
+				pc += fdc_prints (out, scr, width, pad);
+				continue;
+			}
+		}
+		else
+		{
+		out:
+			fdc_printchar (out, *format);
+			++pc;
+		}
+	}
+
+	if (out)
+		**out = '\0';
+
+	va_end( args );
+	return pc;
+}
+
+int fdc_printf(const char *format, ...)
+{
+	va_list args;
+	int status;
+	va_start( args, format );
+
+	status = fdc_print( 0, format, args );
+
+	/* Flush the buffer */
+	fdc_printchar (0, '\0');
+	return status;
+}
+void fdc_flush (void)
+{
+	fdc_printchar (0, '\0');
+}
+
+int fdc_sprintf(char *out, const char *format, ...)
+{
+	va_list args;
+        
+	va_start( args, format );
+	return fdc_print( &out, format, args );
+}
+
+#ifdef TEST_PRINTF
+int main(void)
+{
+	char *ptr = "Hello world!";
+	char *np = 0;
+	int i = 5;
+	unsigned int bs = sizeof(int)*8;
+	int mi;
+	char buf[80];
+
+	mi = (1 << (bs-1)) + 1;
+	printf("%s\n", ptr);
+	printf("printf test\n");
+	printf("%s is null pointer\n", np);
+	printf("%d = 5\n", i);
+	printf("%d = - max int\n", mi);
+	printf("char %c = 'a'\n", 'a');
+	printf("hex %x = ff\n", 0xff);
+	printf("hex %02x = 00\n", 0);
+	printf("signed %d = unsigned %u = hex %x\n", -3, -3, -3);
+	printf("%d %s(s)%", 0, "message");
+	printf("\n");
+	printf("%d %s(s) with %%\n", 0, "message");
+	sprintf(buf, "justif: \"%-10s\"\n", "left"); printf("%s", buf);
+	sprintf(buf, "justif: \"%10s\"\n", "right"); printf("%s", buf);
+	sprintf(buf, " 3: %04d zero padded\n", 3); printf("%s", buf);
+	sprintf(buf, " 3: %-4d left justif.\n", 3); printf("%s", buf);
+	sprintf(buf, " 3: %4d right justif.\n", 3); printf("%s", buf);
+	sprintf(buf, "-3: %04d zero padded\n", -3); printf("%s", buf);
+	sprintf(buf, "-3: %-4d left justif.\n", -3); printf("%s", buf);
+	sprintf(buf, "-3: %4d right justif.\n", -3); printf("%s", buf);
+
+	return 0;
+}
+
+/*
+ * if you compile this file with
+ *   gcc -Wall $(YOUR_C_OPTIONS) -DTEST_PRINTF -c printf.c
+ * you will get a normal warning:
+ *   printf.c:214: warning: spurious trailing `%' in format
+ * this line is testing an invalid % at the end of the format string.
+ *
+ * this should display (on 32bit int machine) :
+ *
+ * Hello world!
+ * printf test
+ * (null) is null pointer
+ * 5 = 5
+ * -2147483647 = - max int
+ * char a = 'a'
+ * hex ff = ff
+ * hex 00 = 00
+ * signed -3 = unsigned 4294967293 = hex fffffffd
+ * 0 message(s)
+ * 0 message(s) with %
+ * justif: "left      "
+ * justif: "     right"
+ *  3: 0003 zero padded
+ *  3: 3    left justif.
+ *  3:    3 right justif.
+ * -3: -003 zero padded
+ * -3: -3   left justif.
+ * -3:   -3 right justif.
+ */
+
+#endif
diff --git b/contrib/libfdc/fdc_putchar.c a/contrib/libfdc/fdc_putchar.c
new file mode 100644
index 000000000..96bab9c00
--- /dev/null
+++ a/contrib/libfdc/fdc_putchar.c
@@ -0,0 +1,171 @@
+#include "fdc.h"
+#include "fdc_putchar.h"
+
+static unsigned long fdcBaseAddr;
+static int cdmm_was_mapped = 0;
+static FDC_U32 gCDMMBase;
+static int fdc_char_count = 0;
+
+void fdc_putchar(int c) __attribute__ ((noinline));
+
+
+/********************************************************************************************
+ *                                                                                          *
+ * fdc_hw_find_base_addr - is used to locate the base address of the FDC memory mapped       *
+ * registers. The FDC memory-mapped registers are located in the common device memory       *
+ * map (CDMM) region. FDC has a device ID of 0xFD. If FDC not found return                  *
+ * FDC_ERR_NO_FDC_HW_FOUND otherwise return FDC_SUCCESS.                                    *
+ *                                                                                          *
+ ********************************************************************************************/
+int fdc_hw_find_base_addr(unsigned long *fdcBaseAddr) {
+	int result;
+	int found = 0;
+	FDC_U32 CDMMBase;
+	FDC_U32 CDMMBaseAddr;
+	FDC_U32 numdrbs;
+	CDMM_DEVICE_RESOURCE_BLOCK *drb_begin;
+	CDMM_DEVICE_RESOURCE_BLOCK *drb_end;
+	CDMM_DEVICE_RESOURCE_BLOCK *drb_cur;			
+
+	CDMMBase = gCDMMBase;
+	CDMMBaseAddr = (CDMMBase >> 11) << 15;
+	numdrbs = (CDMMBase & 0x1FF);
+	drb_begin = (CDMM_DEVICE_RESOURCE_BLOCK*)CDMMBaseAddr;
+	drb_end = drb_begin + numdrbs;
+
+	drb_cur = ((CDMMBase & (1 << 9)) == 0) ? drb_begin : drb_begin+1;
+	while (drb_cur < drb_end) {
+		FDC_U32 acsr = drb_cur->primary.acsr;
+		FDC_U32 extradrbs;
+
+		if (CDMM_DEV_TYPE(acsr) == 0xFD) {
+			found = 1;
+			break;
+		} 
+		extradrbs = CDMM_DEV_SIZE(acsr);
+		drb_cur += extradrbs;
+	}
+	if (found) {
+		*fdcBaseAddr = (unsigned long) drb_cur;
+		result = FDC_SUCCESS;
+	} else {
+		result = FDC_ERR_NO_FDC_HW_FOUND;
+	}
+	
+	return result;
+} // end of fdc_hw_find_base_addr
+
+/********************************************************************************************
+ *                                                                                          *
+ * fdc_init is called to emable the Common Device Memory Map and save global pointer to     *
+ * CDMM.                                                                                    *
+ *                                                                                          *
+ *                                                                                          *
+ ********************************************************************************************/
+int fdc_init(void) {
+	int result = FDC_SUCCESS;
+	FDC_U32 CDMMOverlayPhysicalAddr = 0x1fc10000;
+
+	if (!IS_PHYSICAL_ADDRESS_ADDRESSABLE_VIA_KSEG1(CDMMOverlayPhysicalAddr))
+		result = FDC_ERR_CDMM_BASE_ADDR_NOT_ACCESSIBLE_VIA_KSEG1;
+
+	if (result == FDC_SUCCESS) {
+		if ((CDMMOverlayPhysicalAddr & ((1 << 15)-1)) != 0) {
+			result = FDC_ERR_CDMM_BASE_ADDR_BAD_ALIGNMENT;
+		}
+	}
+
+	if (result == FDC_SUCCESS) {
+
+		FDC_U32 kseg1Addr = MAKE_KSEG1_ADDR(CDMMOverlayPhysicalAddr);
+		FDC_U32 config3 = ReadConfig3();
+
+		if ((config3 & 0x8) != 0) {
+
+			FDC_U32 CDMMBase = ReadCDMMBase();
+
+			/* Is Memory-Mapped I/O enabled */
+			if (((CDMMBase & 0x400) >> 10) != 1)
+			{
+				// set address
+				cdmm_was_mapped = (CDMMBase & (1 << 10)) != 0;
+
+				// enable
+				CDMMBase |= (1 << 10);				
+				WriteCDMMBase(CDMMBase);
+				CDMMBase |= ((kseg1Addr >> 15) << 11);
+			}
+
+			gCDMMBase = CDMMBase;
+
+		} else {
+			result = FDC_ERR_PROCESSOR_HAS_NO_CDMM;
+		}
+
+	}
+
+	fdc_hw_find_base_addr(&fdcBaseAddr);
+	fdc_char_count = 0;
+	return result;
+} // end of fdc_init
+
+//********************************************************************************************
+// fdc_putchar
+//
+// Function writes a character to the next most significant byte of a 4 byte char buffer.
+// Once buffer has 4 characters, checks for FIFO not full.  If it is not, it writes the word
+// to channel 0 of FDC transmit port.
+// If the FDC FIFO is full then it polls waiting for it to be not full. While polling, it
+// counts up and if the count exceeds a constant, it sets static variable "timeout" which
+// means the openOCD host is not polling for characters.  From then on if the function is called
+// it is immediately bypassed so as not to waste time with each call.  The program has
+// to be restarted to reset the timeout variable.
+//
+// Future enhancement could add a control channel to pass info like semi-hosting enable/disable.                                                       *
+//
+// FDC Channel Zero only with Polling. Interrupts not support at this time.
+//
+//********************************************************************************************/
+#define FDC_PUTCHAR_TIMEOUT 1000000  //max spin count waiting to write to FIFO
+
+static volatile int timeout = 0;    //initialize to no timeout
+static volatile unsigned int fdc_buff;
+static volatile unsigned int waitcount = 0;  //accumulated count waiting for FIFO to be not full, for analysis of performance purposes
+
+void fdc_putchar(int c)
+{
+    volatile FDC_REGS *fdc = (FDC_REGS *)fdcBaseAddr;
+    volatile unsigned long i;
+
+    if (timeout == 1)
+        return;  // once a timeout occurs, bypass the function to reduce the overhead of calling this
+                 // function when the host-side semihosting is not enabled
+    // Insert Char. in buffer
+    fdc_buff = (fdc_buff >> 8) | (c << 24);
+
+    // if char is null, this means flush out any remaining characters by shifting them right
+    if (c == '\0') {
+        if (fdc_char_count == 0)  
+            return;                 // no char's accumulated, return
+        while (fdc_char_count < 3) {
+            fdc_buff >>= 8;
+            fdc_char_count++;
+        }
+    } else {
+        fdc_char_count++;  // non-null character, increment count
+    }
+    if ((fdc_char_count > 3) || (c == '\0')) { // write buffer to FDC outgoing FIFO
+        i = 0;
+        while (((fdc->fdstat) & 0x1) == 1) { // If Tx FIFO full, wait for not full or set timeout
+            i++;
+            waitcount++;
+            if (i >= FDC_PUTCHAR_TIMEOUT) {
+                timeout = 1;  // set timeout so this function is bypassed from now on, or until user program is restarted
+                return;
+            }
+        }
+        fdc->fdtx = fdc_buff;  // output word to FDC FIFO
+        fdc_buff = 0;
+        fdc_char_count = 0;
+    }
+} // end of fdc_putchar()
diff --git b/contrib/libfdc/fdc_putchar.h a/contrib/libfdc/fdc_putchar.h
new file mode 100644
index 000000000..25062e70c
--- /dev/null
+++ a/contrib/libfdc/fdc_putchar.h
@@ -0,0 +1,106 @@
+#ifndef FDC_PUTCHAR_H
+#define FDC_PUTCHAR_H
+
+#define MHZ     50            /* Digilent 4 DDR CPU clock. */
+
+
+enum {
+	SEMI_HOSTING_DISABLED = 0,
+	SEMI_HOSTING_ENABLED = 1
+};
+
+typedef struct {
+	unsigned long fdacsr;
+	unsigned long reserved_0;
+	unsigned long fdcfg;
+	unsigned long reserved_1;
+	unsigned long fdstat;
+	unsigned long reserved_2;
+	unsigned long fdrx;
+	unsigned long reserved_3;
+	unsigned long fdtx;
+} FDC_REGS;
+
+
+#define BYTES_PER_CDMM_DEVICE_RESOURCE_BLOCK 64
+#define IS_PHYSICAL_ADDRESS_ADDRESSABLE_VIA_KSEG1(addr)  (((addr) & 0xE0000000) == 0)
+#define MAKE_KSEG1_ADDR(addr)  (((addr) & 0x1FFFFFFF)|0xA0000000)
+
+/********************************************************************************************
+ *                                                                                          *
+ * Software on the core accesses FDC through memory mapped registers. These memory mapped   *
+ * registers are located within the Common Device Memory Map (CDMM). The CDMM is a region   *
+ * of physical address space that is reserved for mapping IO device configuration registers *
+ * within a MIPS processor. The base address and enabling of this region is controlled by   *
+ * the CDMMBase CP0 register.                                                               *
+ *                                                                                          *
+ ********************************************************************************************/
+typedef union {
+	struct {
+		FDC_U32 acsr;
+		unsigned char data[BYTES_PER_CDMM_DEVICE_RESOURCE_BLOCK-sizeof(FDC_U32)];
+	} primary;
+	struct {
+		unsigned char data[BYTES_PER_CDMM_DEVICE_RESOURCE_BLOCK];
+	} secondary;
+} CDMM_DEVICE_RESOURCE_BLOCK;
+
+#define CDMM_DEV_TYPE(acsr) ((FDC_U32)(((acsr) >> 24) & 0xFF))
+#define CDMM_DEV_SIZE(acsr) ((FDC_U32)(((acsr) >> 16) & 0x3F))
+
+/********************************************************************************************
+ *                                                                                          *
+ * Read Config3 register                                                                    *
+ *                                                                                          *
+ ********************************************************************************************/
+FDC_U32 ReadConfig3(void) {
+	FDC_U32 val;
+	__asm("mfc0 %0, $16, 3" : "=r"(val));	
+	return val;
+}
+
+/********************************************************************************************
+ *                                                                                          *
+ * Read Common Device Memory Map Base register                                              *
+ *                                                                                          *
+ ********************************************************************************************/
+static FDC_U32 ReadCDMMBase(void) {
+	FDC_U32 val;
+	__asm("mfc0 %0, $15, 2" : "=r"(val));	
+	return val;
+}
+
+/********************************************************************************************
+ *                                                                                          *
+ * Write Common Device Memory Map Base register                                             *
+ *                                                                                          *
+ ********************************************************************************************/
+void WriteCDMMBase(FDC_U32 val) {
+	__asm("mtc0 %0, $15, 2" : : "r"(val));	
+
+}
+
+/********************************************************************************************
+ *                                                                                          *
+ * Read Cause register                                                                    *
+ *                                                                                          *
+ ********************************************************************************************/
+FDC_U32 ReadCause(void) {
+	FDC_U32 val;
+	__asm("mfc0 %0, $13, 0" : "=r"(val));	
+	return val;
+}
+
+/********************************************************************************************
+ *                                                                                          *
+ * Read Count register                                                                    *
+ *                                                                                          *
+ ********************************************************************************************/
+volatile FDC_U32 ReadCount(void) {
+	FDC_U32 val;
+	__asm("mfc0 %0, $9, 1" : "=r"(val));	
+	return val;
+}
+
+#endif	/*FDC_PUTCHAR_H*/
+
diff --git b/contrib/libfdc/main.c a/contrib/libfdc/main.c
new file mode 100644
index 000000000..ede9aace3
--- /dev/null
+++ a/contrib/libfdc/main.c
@@ -0,0 +1,106 @@
+#include <stdint.h>
+#include "fdc.h"
+
+void delay();
+
+//-------------------------------------------------------
+// main()
+//
+// Test code for the fdc_printf routines.  This is designed for the Digilent Nexys4 DDR board,
+// running the microAptiv MIPS32 core.  The program uses the 5 pushbuttons and 16 LEDs.
+//
+//-------------------------------------------------------
+
+int main()
+{
+        volatile int *IO_LEDR = (int*)0xbf800000;
+        volatile int *IO_PUSHBUTTONS = (int*)0xbf80000c;
+
+        volatile unsigned int pushbutton;
+        volatile unsigned short count = 0;
+
+        fdc_init();  // initialize the CDMM hardware which memory maps the FDC FIFO and status regs
+
+        while (1) {
+           pushbutton = *IO_PUSHBUTTONS;
+
+           switch (pushbutton) {
+                   case 0x1: { // right
+                        if (count==0) count = 0xf000;
+                        else count = count >> 1;
+                        fdc_printf("1");
+                        fdc_printf("1\n");
+                        fdc_printf("12\n");
+                        fdc_printf("123\n");
+                        break;
+                        }
+                   case 0x2: { // middle
+                        if (count==0) count = ~count;
+                        else count = 0;
+                        
+                        char *ptr = "Hello world!";
+                        char *np = 0;
+                        int i = 5;
+                        unsigned int bs = sizeof(int)*8;
+                        int mi;
+                        char buf[80];
+
+                        mi = (1 << (bs-1)) + 1;
+                        fdc_printf("%s\n", ptr);
+                        fdc_printf("printf test\n");
+                        fdc_printf("%s is null pointer\n", np);
+                        fdc_printf("%d = 5\n", i);
+                        fdc_printf("%d = - max int\n", mi);
+                        fdc_printf("char %c = 'a'\n", 'a');
+                        fdc_printf("hex %x = ff\n", 0xff);
+                        fdc_printf("hex %02x = 00\n", 0);
+                        fdc_printf("signed %d = unsigned %u = hex %x\n", -3, -3, -3);
+                        fdc_printf("%d %s(s)%", 0, "message");
+                        fdc_printf("\n");
+                        fdc_printf("%d %s(s) with %%\n", 0, "message");
+                        fdc_printf("justif: \"%-10s\"\n", "left");
+                        fdc_sprintf(buf, "justif: \"%-10s\"\n", "left");
+                        fdc_printf("%s", buf);
+                        fdc_sprintf(buf, "justif: \"%10s\"\n", "right");
+                        fdc_printf("%s", buf);
+                        fdc_sprintf(buf, " 3: %04d zero padded\n", 3); fdc_printf("%s", buf);
+                        fdc_sprintf(buf, " 3: %-4d left justif.\n", 3); fdc_printf("%s", buf);
+                        fdc_sprintf(buf, " 3: %4d right justif.\n", 3); fdc_printf("%s", buf);
+                        fdc_sprintf(buf, "-3: %04d zero padded\n", -3); fdc_printf("%s", buf);
+                        fdc_sprintf(buf, "-3: %-4d left justif.\n", -3); fdc_printf("%s", buf);
+                        fdc_sprintf(buf, "-3: %4d right justif.\n", -3); fdc_printf("%s", buf);
+                        
+                        break;
+                             }
+                   case 0x4: { // left
+                        count--;
+                        fdc_printf("ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 0123456789\n");
+                        break;
+                        }
+                   case 0x8: { // bottom
+                        // test speed of output - 1000 outputs of fixed length
+                        for (count = 64000; count < 65000; count++) {
+                            fdc_printf("%d\n", count);              
+                           }
+                        break;
+                        }
+                   case 0x10: { //top
+                        fdc_printf("count = %d\n", count++);
+                        break;
+                        }
+                   default: if (count==0) count = 0xf;
+                             else count = count << 1;
+                } //end switch
+           *IO_LEDR = count;            // write to green LEDs
+
+           delay();
+
+        } // end while(1)
+        return 0;
+} // end of main()
+
+void delay() {
+   volatile unsigned int j;
+
+   for (j = 0; j < (120000); j++) ;  // set for caches enabled
+} // end of delay()
diff --git b/contrib/libfdc/start.S a/contrib/libfdc/start.S
new file mode 100644
index 000000000..fa877d852
--- /dev/null
+++ a/contrib/libfdc/start.S
@@ -0,0 +1,28 @@
+#include <mips/regdef.h>
+#include <mips/m32c0.h>
+
+		.text
+		.globl	__start
+		.ent __start
+
+__start:
+		lui sp, 0xA000
+		ori sp, sp, __stack
+		sw  zero, 0(sp)
+		move a0, zero
+		move a1, zero
+
+		lui gp, 0xa001
+		ori gp, gp, _gp
+
+		jal main
+		nop
+
+		.end __start
+
+		.data
+		.globl __stack
+stack_end:
+		.space  4000,0		
+__stack:
+		.long 		1
diff --git b/contrib/loaders/flash/pic32mz.s a/contrib/loaders/flash/pic32mz.s
new file mode 100644
index 000000000..ff8a035a2
--- /dev/null
+++ a/contrib/loaders/flash/pic32mz.s
@@ -0,0 +1,132 @@
+/***************************************************************************
+ *   Copyright (C) 2010 by Spencer Oliver                                  *
+ *   spen@spen-soft.co.uk                                                  *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ ***************************************************************************/
+
+	.text
+#	.arch m4k
+	.set noreorder
+	.set noat
+
+/* params:
+ * $a0 src adr - ram + result
+ * $a1 dest adr - flash
+ * $a2 count (32bit words)
+ * vars
+ *
+ * temps:
+ * $t0, $t1, $t2, $t3, $t4, $t5
+ * $s0, $s1, $s3, $s4, $s5
+ */
+
+	.type main, @function
+	.global main
+
+.ent main
+main:
+	/* setup constants */
+	lui		$t0, 0xaa99
+	ori		$t0, 0x6655				/* NVMKEY1 */
+	lui		$t1, 0x5566
+	ori		$t1, 0x99AA				/* NVMKEY2 */
+	lui		$t2, 0xBF80
+	ori		$t2, 0x0600				/* NVMCON */
+	ori		$t3, $zero, 0x4003		/* NVMCON row write cmd */
+	ori		$t4, $zero, 0x8000		/* NVMCON start cmd */
+
+write_row:
+	/* can we perform a row write: 512 32bit words */
+	sltiu	$s3, $a2, 512
+	bne		$s3, $zero, write_word
+	ori		$t5, $zero, 0x4000		/* NVMCON clear cmd */
+
+	/* perform row write 2048 bytes */
+	sw		$a1, 32($t2)	/* set NVMADDR with dest addr - real addr */
+	sw		$a0, 112($t2)	/* set NVMSRCADDR with src addr - real addr */
+
+	bal		progflash
+	addiu	$a0, $a0, 2048
+	addiu	$a1, $a1, 2048
+	beq		$zero, $zero, write_row
+	addiu	$a2, $a2, -512
+
+write_word:
+	/* write 32bit words */
+	lui		$s5, 0xa000
+	ori		$s5, 0x0000
+	or		$a0, $a0, $s5			/* convert to virtual addr */
+
+	beq		$zero, $zero, next_word
+	ori		$t3, $zero, 0x4001		/* NVMCON word write cmd */
+
+prog_word:
+	lw		$s4, 0($a0)		/* load data - from virtual addr */
+	sw		$s4, 48($t2)	/* set NVMDATA with data */
+	sw		$a1, 32($t2)	/* set NVMADDR with dest addr - real addr */
+
+	bal		progflash
+	addiu	$a0, $a0, 4
+	addiu	$a1, $a1, 4
+	addiu	$a2, $a2, -1
+next_word:
+	bne		$a2, $zero, prog_word
+	nop
+
+done:
+	beq		$zero, $zero, exit
+	addiu	$a0, $zero, 0
+
+error:
+	/* save result to $a0 */
+	addiu	$a0, $s1, 0
+
+exit:
+	sdbbp
+.end main
+
+	.type progflash, @function
+	.global progflash
+
+.ent progflash
+progflash:
+	sw		$t3, 0($t2)		/* set NVMWREN */
+	sw		$t0, 16($t2)	/* write NVMKEY1 */
+	sw		$t1, 16($t2)	/* write NVMKEY2 */
+	sw		$t4, 8($t2)		/* start operation */
+
+waitflash:
+	lw		$s0, 0($t2)
+	and		$s0, $s0, $t4
+	bne		$s0, $zero, waitflash
+	nop
+
+	/* following is to comply with errata #34
+	 * 500ns delay required */
+	nop
+	nop
+	nop
+	nop
+	/* check for errors */
+	lw		$s1, 0($t2)
+	andi	$s1, $s1, 0x3000
+	bne		$s1, $zero, error
+	sw		$t5, 4($t2)		/* clear NVMWREN */
+	jr		$ra
+	nop
+
+.end progflash
diff --git b/doc/openocd.texi a/doc/openocd.texi
index ce681a38d..fca0d047f 100644
--- b/doc/openocd.texi
+++ a/doc/openocd.texi
@@ -1,3 +1,4 @@
+
 \input texinfo @c -*-texinfo-*-
 @c %**start of header
 @setfilename openocd.info
@@ -4231,6 +4232,8 @@ compact Thumb2 instruction set.
 @item @code{fa526} -- resembles arm920 (w/o Thumb)
 @item @code{feroceon} -- resembles arm926
 @item @code{mips_m4k} -- a MIPS core
+@item @code{mips_mApticv} -- a MIPS microAptiv core
+@item @code{mips_iApticv} -- a MIPS interAptiv core (with limitation)
 @item @code{xscale} -- this is actually an architecture,
 not a CPU type. It is based on the ARMv5 architecture.
 @item @code{openrisc} -- this is an OpenRISC 1000 core.
diff --git b/jimtcl a/jimtcl
deleted file mode 160000
index a9bf5975f..000000000
--- b/jimtcl
+++ /dev/null
@@ -1 +0,0 @@
-Subproject commit a9bf5975fd0f89974d689a2d9ebd0873c8d64787
diff --git b/src/flash/nor/Makefile.am a/src/flash/nor/Makefile.am
index 878fc26ba..c19073889 100644
--- b/src/flash/nor/Makefile.am
+++ a/src/flash/nor/Makefile.am
@@ -27,6 +27,7 @@ NOR_DRIVERS = \
 	non_cfi.c \
 	ocl.c \
 	pic32mx.c \
+	pic32mz.c \
 	spi.c \
 	stmsmi.c \
 	stellaris.c \
diff --git b/src/flash/nor/drivers.c a/src/flash/nor/drivers.c
index fead7974f..d75597ab2 100644
--- b/src/flash/nor/drivers.c
+++ a/src/flash/nor/drivers.c
@@ -43,6 +43,7 @@ extern struct flash_driver stm32lx_flash;
 extern struct flash_driver tms470_flash;
 extern struct flash_driver ocl_flash;
 extern struct flash_driver pic32mx_flash;
+extern struct flash_driver pic32mz_flash;
 extern struct flash_driver avr_flash;
 extern struct flash_driver faux_flash;
 extern struct flash_driver virtual_flash;
@@ -86,6 +87,7 @@ static struct flash_driver *flash_drivers[] = {
 	&tms470_flash,
 	&ocl_flash,
 	&pic32mx_flash,
+	&pic32mz_flash,
 	&avr_flash,
 	&faux_flash,
 	&virtual_flash,
diff --git b/src/flash/nor/pic32mx.c a/src/flash/nor/pic32mx.c
index 5e82ba63d..1f7f5161b 100644
--- b/src/flash/nor/pic32mx.c
+++ a/src/flash/nor/pic32mx.c
@@ -403,7 +403,7 @@ static uint32_t pic32mx_flash_write_code[] = {
 	0x00000000,		/* nop */
 	0x00000000,		/* nop */
 	0x8D510000,		/* lw $s1, 0($t2) */
-	0x30113000,		/* andi $s1, $zero, 0x3000 */
+	0x32313000,		/* andi $s1, $s1, 0x3000 */
 	0x1620FFEF,		/* bne $s1, $zero, error */
 	0xAD4D0004,		/* sw $t5, 4($t2) */
 	0x03E00008,		/* jr $ra */
diff --git b/src/flash/nor/pic32mz.c a/src/flash/nor/pic32mz.c
new file mode 100644
index 000000000..73785ef1e
--- /dev/null
+++ a/src/flash/nor/pic32mz.c
@@ -0,0 +1,1183 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Dominic Rath                                    *
+ *   Dominic.Rath@gmx.de                                                   *
+ *                                                                         *
+ *   Copyright (C) 2008 by Spencer Oliver                                  *
+ *   spen@spen-soft.co.uk                                                  *
+ *                                                                         *
+ *   Copyright (C) 2008 by John McCarthy                                   *
+ *   jgmcc@magma.ca                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *																           *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <jtag/jtag.h>
+#include "imp.h"
+#include <target/algorithm.h>
+#include <target/mips32.h>
+#include <target/mips_m4k.h>
+
+
+/* In PIC32MZ EC devices, the Flash page size is 16 KB (4096 IW) and the row size is 2 KB (512 IW). */
+
+#define PIC32MZ_MANUF_ID	0x029
+
+/* pic32mz memory locations */
+
+#define PIC32MZ_PHYS_RAM			0x00000000
+#define PIC32MZ_PHYS_PGM_FLASH		0x1D000000
+#define PIC32MZ_PHYS_PERIPHERALS	0x1F800000
+#define PIC32MZ_PHYS_BOOT_FLASH		0x1FC00000
+#define PIC32MZ_PHYS_LOWER_BOOT_ALIAS	0x1FC00000
+#define PIC32MZ_PHYS_UPPER_BOOT_ALIAS	0x1FC20000
+#define PIC32MZ_PHYS_BOOT_FLASH_END	0x1FC74000
+#define PIC32MZ_PAGE_NUMBYTES (16*1024)
+#define PIC32MZ_BOOT_BLOCK_NUMBYTES     (80*1024)
+#define PIC32MZ_BOOT_BLOCK_NUMPAGES     (PIC32MZ_BOOT_BLOCK_NUMBYTES/PIC32MZ_PAGE_NUMBYTES)
+
+
+/*
+ * Translate Virtual and Physical addresses.
+ * Note: These macros only work for KSEG0/KSEG1 addresses.
+ */
+
+#define Virt2Phys(v)	((v) & 0x1FFFFFFF)
+
+/* pic32mz configuration register locations */
+
+#define PIC32MZ_DEVCP0		0xBFC4FFDC
+
+#define PIC32MZ_NVMBWP_LBWP0_OFFSET 8
+#define PIC32MZ_NVMBWP_UBWP0_OFFSET 0      
+
+#define PIC32MZ_NVMBWP_LBWPULOCK 0x00008000
+#define PIC32MZ_NVMBWP_UBWPULOCK 0x00000080
+
+#define PIC32MZ_NVMPWP_PWPULOCK 0x80000000
+#define PIC32MZ_NVMPWP_PWP      0x00FFFFFF
+
+/* pic32mz flash controller register locations */
+
+#define PIC32MZ_NVMCON		0xBF800600  
+#define PIC32MZ_NVMCONCLR	0xBF800604  
+#define PIC32MZ_NVMCONSET	0xBF800608  
+#define PIC32MZ_NVMCONINV	0xBF80060C  
+#define NVMCON_NVMWR		(1 << 15)  
+#define NVMCON_NVMWREN		(1 << 14)  
+#define NVMCON_NVMERR		(1 << 13)  
+#define NVMCON_LVDERR		(1 << 12)  
+// #define NVMCON_LVDSTAT	// NOT available in PIC32MZ devices... was in PIC32MX
+#define NVMCON_OP_PFM_ERASE	0x7  
+#define NVMCON_OP_PAGE_ERASE	0x4  
+#define NVMCON_OP_ROW_PROG	0x3  
+#define NVMCON_OP_WORD_PROG	0x1  
+#define NVMCON_OP_QUAD_WORD_PROG	0x2
+#define NVMCON_OP_NOP		0x0  
+
+#define PIC32MZ_NVMKEY		0xBF800610  
+#define PIC32MZ_NVMADDR		0xBF800620  
+#define PIC32MZ_NVMADDRCLR	0xBF800624   
+#define PIC32MZ_NVMADDRSET	0xBF800628  
+#define PIC32MZ_NVMADDRINV	0xBF80062C  
+#define PIC32MZ_NVMDATA0	0xBF800630  
+#define PIC32MZ_NVMDATA1	0xBF800640  
+#define PIC32MZ_NVMDATA2	0xBF800650  
+#define PIC32MZ_NVMDATA3	0xBF800660  
+#define PIC32MZ_NVMSRCADDR	0xBF800670  
+#define PIC32MZ_DEVCFG3		0xBFC0FFC0
+#define PIC32MZ_NVMPWP          0xBF800680
+#define PIC32MZ_NVMBWP          0xBF800690
+#define PIC32MZ_NVMBWPCLR	0xBF800694
+
+#define PIC32MZ_CFGCON		0xBF800000
+#define CFGCON_ECC		0x30
+
+/* flash unlock keys */
+
+#define NVMKEY1			0xAA996655  
+#define NVMKEY2			0x556699AA  
+
+
+
+struct pic32mz_flash_bank {
+	int probed;
+	int dev_type;		/* Default 0. 1 for Pic32mz1XX/2XX variant */
+};
+
+/*
+ * DEVID values as per PIC32MZ Flash Programming Specification Rev J
+ */
+
+static const struct pic32mz_devs_s {
+	uint32_t devid;
+	const char *name;
+	uint32_t kb_program_flash;
+} pic32mz_devs[] = {
+	/* PIC32MZ EMBEDDED CONNECTIVITY (EC) FAMILY DEVICE IDS */
+	{0x05103053, "1024ECG064", 1024},
+	{0x05108053, "1024ECH064", 1024},
+	{0x05130053, "1024ECM064", 1024},
+	{0x05104053, "2048ECG064", 2048},
+	{0x05109053, "2048ECH064", 2048},
+	{0x05131053, "2048ECM064", 2048},
+	{0x0510D053, "1024ECG100", 1024},
+	{0x05112053, "1024ECH100", 1024},
+	{0x0513A053, "1024ECM100", 1024},
+	{0x0510E053, "2048ECG100", 2048},
+	{0x05113053, "2048ECH100", 2048},
+	{0x0513B053, "2048ECM100", 2048},
+	{0x05117053, "1024ECG124", 1024},
+	{0x0511C053, "1024ECH124", 1024},
+	{0x05144053, "1024ECM124", 1024},
+	{0x05118053, "2048ECG124", 2048},
+	{0x0511D053, "2048ECH124", 2048},
+	{0x05145053, "2048ECM124", 2048},
+	{0x05121053, "1024ECG144", 1024},
+	{0x05126053, "1024ECH144", 1024},
+	{0x0514E053, "1024ECM144", 1024},
+	{0x05122053, "2048ECG144", 2048},
+	{0x05127053, "2048ECH144", 2048},
+	{0x0514F053, "2048ECM144", 2048},
+	/* PIC32MZ EMBEDDED CONNECTIVITY WITH FPU (EF) FAMILY DEVICE IDS */
+	{0x07201053, "0512EFE064", 512},
+	{0x07206053, "0512EFF064", 512},
+	{0x0722E053, "0512EFK064", 512},
+	{0x07202053, "1024EFE064", 1024},
+	{0x07207053, "1024EFF064", 1024},
+	{0x0722F053, "1024EFK064", 1024},
+	{0x07203053, "1024EFG064", 1024},
+	{0x07208053, "1024EFH064", 1024},
+	{0x07230053, "1024EFM064", 1024},
+	{0x07204053, "2048EFG064", 2048},
+	{0x07209053, "2048EFH064", 2048},
+	{0x07231053, "2048EFM064", 2048},
+	{0x0720B053, "0512EFE100", 512},
+	{0x07210053, "0512EFF100", 512},
+	{0x07238053, "0512EFK100", 512},
+	{0x0720C053, "1024EFE100", 1024},
+	{0x07211053, "1024EFF100", 1024},
+	{0x07239053, "1024EFK100", 1024},
+	{0x0720D053, "1024EFG100", 1024},
+	{0x07212053, "1024EFH100", 1024},
+	{0x0723A053, "1024EFM100", 1024},
+	{0x0720E053, "2048EFG100", 2048},
+	{0x07213053, "2048EFH100", 2048},
+	{0x0723B053, "2048EFM100", 2048},
+	{0x07215053, "0512EFE124", 512},
+	{0x0721A053, "0512EFF124", 512},
+	{0x07242053, "0512EFK124", 512},
+	{0x07216053, "1024EFE124", 1024},
+	{0x0721B053, "1024EFF124", 1024},
+	{0x07243053, "1024EFK124", 1024},
+	{0x07217053, "1024EFG124", 1024},
+	{0x0721C053, "1024EFH124", 1024},
+	{0x07244053, "1024EFM124", 1024},
+	{0x07218053, "2048EFG124", 2048},
+	{0x0721D053, "2048EFH124", 2048},
+	{0x07245053, "2048EFM124", 2048},
+	{0x0721F053, "0512EFE144", 512},
+	{0x07224053, "0512EFF144", 512},
+	{0x0724C053, "0512EFK144", 512},
+	{0x07220053, "1024EFE144", 1024},
+	{0x07225053, "1024EFF144", 1024},
+	{0x0724D053, "1024EFK144", 1024},
+	{0x07221053, "1024EFG144", 1024},
+	{0x07226053, "1024EFH144", 1024},
+	{0x0724E053, "1024EFM144", 1024},
+	{0x07222053, "2048EFG144", 2048},
+	{0x07227053, "2048EFH144", 2048},
+	{0x0724F053, "2048EFM144", 2048},
+	/* PIC32MZ GRAPHICS (DA) FAMILY DEVICE IDS */
+	{0x05F0C053, "1025DAA169", 1024},
+	{0x05F0D053, "1025DAB169", 1024},
+	{0x05F0F053, "1064DAA169", 1024},
+	{0x05F10053, "1064DAB169", 1024},
+	{0x05F15053, "2025DAA169", 2048},
+	{0x05F16053, "2025DAB169", 2048},
+	{0x05F18053, "2064DAA169", 2048},
+	{0x05F19053, "2064DAB169", 2048},
+	{0x05F42053, "1025DAG169", 1024},
+	{0x05F43053, "1025DAH169", 1024},
+	{0x05F45053, "1064DAG169", 1024},
+	{0x05F46053, "1064DAH169", 1024},
+	{0x05F4B053, "2025DAG169", 2048},
+	{0x05F4C053, "2025DAH169", 2048},
+	{0x05F4E053, "2064DAG169", 2048},
+	{0x05F4F053, "2064DAH169", 2048},
+	{0x05F78053, "1025DAA176", 1024},
+	{0x05F79053, "1025DAB176", 1024},
+	{0x05F7B053, "1064DAA176", 1024},
+	{0x05F7C053, "1064DAB176", 1024},
+	{0x05F81053, "2025DAA176", 2048},
+	{0x05F82053, "2025DAB176", 2048},
+	{0x05F84053, "2064DAA176", 2048},
+	{0x05F85053, "2064DAB176", 2048},
+	{0x05FAE053, "1025DAG176", 1024},
+	{0x05FAF053, "1025DAH176", 1024},
+	{0x05FB1053, "1064DAG176", 1024},
+	{0x05FB2053, "1064DAH176", 1024},
+	{0x05FB7053, "2025DAG176", 2048},
+	{0x05FB8053, "2025DAH176", 2048},
+	{0x05FBA053, "2064DAG176", 2048},
+	{0x05FBB053, "2064DAH176", 2048},
+	{0x05F5D053, "1025DAA288", 1024},
+	{0x05F5E053, "1025DAB288", 1024},
+	{0x05F60053, "1064DAA288", 1024},
+	{0x05F61053, "1064DAB288", 1024},
+	{0x05F66053, "2025DAA288", 2048},
+	{0x05F67053, "2025DAB288", 2048},
+	{0x05F69053, "2064DAA288", 2048},
+	{0x05F6A053, "2064DAB288", 2048},
+	{0x00000000, NULL, 0}
+};
+
+static const struct pic32mz_devs_s *pic32mz_lookup_device(uint32_t device_id)
+{
+	int i;
+
+	for (i = 0; pic32mz_devs[i].name != NULL; i++) {
+		if (pic32mz_devs[i].devid == (device_id & 0x0fffffff)) {
+			return &pic32mz_devs[i];
+		}
+	}
+	return NULL;
+}
+
+
+
+/* flash bank pic32mz <base> <size> 0 0 <target#>
+ */
+FLASH_BANK_COMMAND_HANDLER(pic32mz_flash_bank_command)
+{
+	struct pic32mz_flash_bank *pic32mz_info;
+
+	if (CMD_ARGC < 6)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	pic32mz_info = malloc(sizeof(struct pic32mz_flash_bank));
+	bank->driver_priv = pic32mz_info;
+
+	pic32mz_info->probed = 0;
+	pic32mz_info->dev_type = 0;
+
+	return ERROR_OK;
+}
+
+static uint32_t pic32mz_get_flash_status(struct flash_bank *bank)
+{
+	struct target *target = bank->target;
+	uint32_t status;
+
+	target_read_u32(target, PIC32MZ_NVMCON, &status);
+
+	return status;
+}
+
+static uint32_t pic32mz_wait_status_busy(struct flash_bank *bank, int timeout)
+{
+	uint32_t status;
+
+	/* wait for busy to clear */
+	while (((status = pic32mz_get_flash_status(bank)) & NVMCON_NVMWR) && (timeout-- > 0)) {
+		LOG_DEBUG("status: 0x%" PRIx32, status);
+		alive_sleep(1);
+	}
+	if (timeout <= 0)
+		LOG_DEBUG("timeout: status: 0x%" PRIx32, status);
+
+	return status;
+}
+
+static int pic32mz_nvm_exec(struct flash_bank *bank, uint32_t op, uint32_t timeout)
+{
+	struct target *target = bank->target;
+	uint32_t status;
+
+	target_write_u32(target, PIC32MZ_NVMCON, NVMCON_NVMWREN | op);
+
+	/* unlock flash registers */
+	target_write_u32(target, PIC32MZ_NVMKEY, 0);  /* write of 0 might not have been required for PIC32MX, but it is suggested for PIC32MZ */
+	target_write_u32(target, PIC32MZ_NVMKEY, NVMKEY1);
+	target_write_u32(target, PIC32MZ_NVMKEY, NVMKEY2);
+
+	/* start operation */
+	target_write_u32(target, PIC32MZ_NVMCONSET, NVMCON_NVMWR);
+
+	status = pic32mz_wait_status_busy(bank, timeout);
+
+	/* lock flash registers */
+	target_write_u32(target, PIC32MZ_NVMCONCLR, NVMCON_NVMWREN);
+
+	return status;
+}
+
+static int pic32mz_protect_check(struct flash_bank *bank)
+{
+	struct target *target = bank->target;
+	// struct pic32mz_flash_bank *pic32mz_info = bank->driver_priv;
+
+	uint32_t cp0_address;
+	uint32_t nvmpwp_address;
+	uint32_t nvmbwp_address;
+	uint32_t devcp0;
+	uint32_t nvmpwp;
+	uint32_t nvmbwp;
+	int s;
+	int num_pages;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	cp0_address = PIC32MZ_DEVCP0;
+	nvmpwp_address = PIC32MZ_NVMPWP;
+	nvmbwp_address = PIC32MZ_NVMBWP;
+
+	target_read_u32(target, cp0_address, &devcp0);
+
+
+
+	if ((devcp0 & (1 << 28)) == 0) { /* code protect bit */
+		/* all pages protected */
+		for (s = 0; s < bank->num_sectors; s++)
+			bank->sectors[s].is_protected = 1;
+	} else if (Virt2Phys(bank->base) == PIC32MZ_PHYS_LOWER_BOOT_ALIAS) {
+		/* Boot flash write protection is divided into pages and is enabled by the LBWPx bits in the NVMBWP register.*/
+		target_read_u32(target, nvmbwp_address, &nvmbwp);
+		for (s = 0; s < bank->num_sectors && s < PIC32MZ_BOOT_BLOCK_NUMPAGES; s++) {
+			int bit = (nvmbwp >> (PIC32MZ_NVMBWP_LBWP0_OFFSET+s)) & 0x1;
+			bank->sectors[s].is_protected = (bit != 0);
+		}
+	} else if (Virt2Phys(bank->base) == PIC32MZ_PHYS_UPPER_BOOT_ALIAS) {
+		/* Boot Flash write protection is divided into pages and is enabled by the UBWPx bits in the NVMBWP register.*/
+		target_read_u32(target, nvmbwp_address, &nvmbwp);
+		for (s = 0; s < bank->num_sectors && s < PIC32MZ_BOOT_BLOCK_NUMPAGES; s++) {
+			int bit = (nvmbwp >> (PIC32MZ_NVMBWP_UBWP0_OFFSET+s)) & 0x1;
+			bank->sectors[s].is_protected = (bit != 0);
+		}
+	} else {
+		/* pgm flash */
+		target_read_u32(target, nvmpwp_address, &nvmpwp);
+		nvmpwp &= 0x00FFFFFF;
+		num_pages = (nvmpwp/PIC32MZ_PAGE_NUMBYTES)+1;
+		for (s = 0; s < bank->num_sectors; s++) {
+			// protected if nvmpwp is not zero, and if the page index is less than or equal to the page index of nvmpwp
+			bank->sectors[s].is_protected = (nvmpwp != 0x0) && (s < num_pages);
+		}
+	}
+
+	return ERROR_OK;
+}
+
+static int pic32mz_erase(struct flash_bank *bank, int first, int last)
+{
+	struct target *target = bank->target;
+	int i;
+	uint32_t status;
+
+	if (bank->target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	if ((first == 0) && (last == (bank->num_sectors - 1))
+		&& (Virt2Phys(bank->base) == PIC32MZ_PHYS_PGM_FLASH)) {
+		/* this will only erase the Program Flash (PFM), not the Boot Flash (BFM)
+		 * we need to use the MTAP to perform a full erase */
+		LOG_DEBUG("Erasing entire program flash");
+		status = pic32mz_nvm_exec(bank, NVMCON_OP_PFM_ERASE, 50);
+		if (status & NVMCON_NVMERR)
+			return ERROR_FLASH_OPERATION_FAILED;
+		if (status & NVMCON_LVDERR)
+			return ERROR_FLASH_OPERATION_FAILED;
+		return ERROR_OK;
+	}
+
+	for (i = first; i <= last; i++) {
+		target_write_u32(target, PIC32MZ_NVMADDR, Virt2Phys(bank->base + bank->sectors[i].offset));
+
+		status = pic32mz_nvm_exec(bank, NVMCON_OP_PAGE_ERASE, 10);
+
+		if (status & NVMCON_NVMERR)
+			return ERROR_FLASH_OPERATION_FAILED;
+		if (status & NVMCON_LVDERR)
+			return ERROR_FLASH_OPERATION_FAILED;
+		bank->sectors[i].is_erased = 1;
+	}
+
+	return ERROR_OK;
+}
+
+static int pic32mz_protect(struct flash_bank *bank, int set, int first, int last)
+{
+	struct target *target = bank->target;
+	int sector;
+	uint32_t nvmbwp;
+	uint32_t nvmpwp;
+	uint32_t nvmpwp_23_0;
+	int num_pages;
+
+	/* the calling function(s) validate that first and last are valid sector indices, no need to validate here */
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	if (Virt2Phys(bank->base) == PIC32MZ_PHYS_LOWER_BOOT_ALIAS) {
+		/* Boot flash write protection is divided into pages and is enabled by the LBWPx bits in the NVMBWP register.*/
+		target_read_u32(target, PIC32MZ_NVMBWP, &nvmbwp);
+		if ((nvmbwp & PIC32MZ_NVMBWP_LBWPULOCK) == 0) {
+			// can't unprotect the page
+			LOG_ERROR("Boot flash write protect registers are locked; unlocking requires device reset");
+			return ERROR_FLASH_OPERATION_FAILED;
+		}
+		for (sector = first; sector <= last; sector++) {
+			if (set) {
+				nvmbwp |= (1 << (PIC32MZ_NVMBWP_LBWP0_OFFSET+sector));
+			} else {
+				nvmbwp &= ~(1 << (PIC32MZ_NVMBWP_LBWP0_OFFSET+sector));
+			}
+		}
+		/* changing the write protect bits requires unlocking flash registers */
+		target_write_u32(target, PIC32MZ_NVMKEY, 0);  /* write of 0 might not have been required for PIC32MX, but it is suggested for PIC32MZ */
+		target_write_u32(target, PIC32MZ_NVMKEY, NVMKEY1);
+		target_write_u32(target, PIC32MZ_NVMKEY, NVMKEY2);
+		/* write back nvmbwp */
+		target_write_u32(target, PIC32MZ_NVMBWP, nvmbwp);
+	} else if (Virt2Phys(bank->base) == PIC32MZ_PHYS_UPPER_BOOT_ALIAS) {
+		/* Boot Flash write protection is divided into pages and is enabled by the UBWPx bits in the NVMBWP register.*/
+		target_read_u32(target, PIC32MZ_NVMBWP, &nvmbwp);
+		if ((nvmbwp & PIC32MZ_NVMBWP_UBWPULOCK) == 0) {
+			// can't unprotect the page
+			LOG_ERROR("Boot flash write protect registers are locked; unlocking requires device reset");
+			return ERROR_FLASH_OPERATION_FAILED;
+		}
+
+		for (sector = first; sector <= last; sector++) {
+			if (set) {
+				nvmbwp |= (1 << (PIC32MZ_NVMBWP_UBWP0_OFFSET+sector));
+			} else {
+				nvmbwp &= ~(1 << (PIC32MZ_NVMBWP_UBWP0_OFFSET+sector));
+			}
+		}
+		/* changing the write protect bits requires unlocking flash registers */
+		target_write_u32(target, PIC32MZ_NVMKEY, 0);  /* write of 0 might not have been required for PIC32MX, but it is suggested for PIC32MZ */
+		target_write_u32(target, PIC32MZ_NVMKEY, NVMKEY1);
+		target_write_u32(target, PIC32MZ_NVMKEY, NVMKEY2);
+		/* write back nvmbwp */
+		target_write_u32(target, PIC32MZ_NVMBWP, nvmbwp);
+	} else {
+		/* pgm flash */
+		target_read_u32(target, PIC32MZ_NVMPWP, &nvmpwp);
+		if ((nvmpwp & PIC32MZ_NVMPWP_PWPULOCK) == 0) {
+			// can't unprotect the page
+			LOG_ERROR("Program flash write protect register is locked; unlocking requires device reset");
+			return ERROR_FLASH_OPERATION_FAILED;
+		}
+		nvmpwp_23_0 = nvmpwp & PIC32MZ_NVMPWP_PWP;
+		num_pages = (nvmpwp_23_0 == 0 ? 0 : (nvmpwp_23_0/PIC32MZ_PAGE_NUMBYTES)+1);
+		if (set) {
+			if (first > num_pages) {
+				LOG_ERROR("protected space must be contiguous below unprotected space");
+				return ERROR_FLASH_SECTOR_INVALID;
+			}
+			nvmpwp = (nvmpwp & PIC32MZ_NVMPWP_PWPULOCK) | ((last * PIC32MZ_PAGE_NUMBYTES) + 4);  /* need 4 offset just because 0 is special sentinel value and must be avoided */
+		} else {
+			if (last < num_pages-1) {
+				LOG_ERROR("protected space must be contiguous below unprotected space");
+				return ERROR_FLASH_SECTOR_INVALID;
+			}
+			if (first == 0) {
+				nvmpwp = (nvmpwp & PIC32MZ_NVMPWP_PWPULOCK);
+			} else {
+				nvmpwp = (nvmpwp & PIC32MZ_NVMPWP_PWPULOCK) | (((first-1) * PIC32MZ_PAGE_NUMBYTES) + 4);  /* need 4 offset just because 0 is special sentinel value and must be avoided */			
+			}
+		}
+		/* changing the write protect bits requires unlocking flash registers */
+		target_write_u32(target, PIC32MZ_NVMKEY, 0);  /* write of 0 might not have been required for PIC32MX, but it is suggested for PIC32MZ */
+		target_write_u32(target, PIC32MZ_NVMKEY, NVMKEY1);
+		target_write_u32(target, PIC32MZ_NVMKEY, NVMKEY2);
+		/* write back nvmpwp */
+		target_write_u32(target, PIC32MZ_NVMPWP, nvmpwp);
+	}
+
+	return ERROR_OK;
+}
+
+/* see contib/loaders/flash/pic32mz.s for src */
+
+static uint32_t pic32mz_flash_write_code[] = {
+					/* write: */
+	/* nvmkey1 = t0 = 0xAA996655 */
+	0x3C08AA99,		/* lui $t0, 0xaa99 */
+	0x35086655,		/* ori $t0, 0x6655 */
+	/* nvmkey2 = t1 = 0x556699aa */
+	0x3C095566,		/* lui $t1, 0x5566 */
+	0x352999AA,		/* ori $t1, 0x99aa */
+	/* nvmcon_addr = t2 = 0xBF800600 */
+	0x3C0ABF80,		/* lui $t2, 0xbf80 */
+	0x354A0600,		/* ori $t2, 0x0600 */
+	/* nvmcon_value = t3 = 0x4003 */
+	0x340B4003,		/* ori $t3, $zero, 0x4003 */
+	/* nvmconset_value = t4 = 0x8000 */
+	0x340C8000,		/* ori $t4, $zero, 0x8000 */
+					/* write_row: */
+	/* while (1) { */
+	/* nvmconclr_value = t5 = 0x4000 */
+	/*   if (param_words_left < 512) {
+	     goto write_word;
+	     }
+	*/
+	0x2CD30200,		/* sltiu $s3, $a2, 512 */   /* modified for MZ -- 512 words */
+	0x16600008,		/* bne $s3, $zero, write_word */
+	0x340D4000,		/* ori $t5, $zero, 0x4000 */
+	/* *nvmaddr_addr = param_dest_address; */
+	0xAD450020,		/* sw $a1, 32($t2) */
+	/* *srcaddr_addr = param_source_address; */
+	0xAD440070,		/* sw $a0, 112($t2) */
+	/* param_source_address += 2048 */
+	/* progflash() */
+	0x04110016,		/* bal progflash */
+	0x24840800,		/* addiu $a0, $a0, 2048 */
+	/* param_dest_address += 2048; */
+	0x24A50800,		/* addiu $a1, $a1, 2048 */
+	/* param_words_left -= 512;
+	 } end while */
+	0x1000FFF7,		/* beq $zero, $zero, write_row */
+	0x24C6FE00,		/* addiu $a2, $a2, -512 */
+					/* write_word: */
+	/* param_source_address |= 0xA0000000; */
+	0x3C15A000,		/* lui $s5, 0xa000 */
+	0x36B50000,		/* ori $s5, $s5, 0x0 */
+	0x00952025,		/* or $a0, $a0, $s5 */
+	/* nvmcon_value = 0x4001; */
+	/* goto next_word; */
+	0x10000008,		/* beq $zero, $zero, next_word */
+	0x340B4001,		/* ori $t3, $zero, 0x4001 */
+					/* prog_word: */
+	/* do { */
+	/*    *nvmdata_addr = *param_source_address; */
+	0x8C940000,		/* lw $s4, 0($a0) */
+	0xAD540030,		/* sw $s4, 48($t2) */
+	/*    *nvmaddr_addr = param_dest_address; */
+	0xAD450020,		/* sw $a1, 32($t2) */
+	/*    param_source_address += 4; */
+	/*    progflash() */
+	0x04110009,		/* bal progflash */
+	0x24840004,		/* addiu $a0, $a0, 4 */
+	/*    param_dest_address += 4; */
+	0x24A50004,		/* addiu $a1, $a1, 4 */
+	/*    param_words_left -= 1; */
+	0x24C6FFFF,		/* addiu $a2, $a2, -1 */
+					/* next_word: */
+	/* } while (param_words_left != 0); */
+	0x14C0FFF8,		/* bne $a2, $zero, prog_word */
+	0x00000000,		/* nop */
+					/* done: */
+	/* param_result = 0; */
+	/* goto exit; */
+	0x10000002,		/* beq $zero, $zero, exit */
+	0x24040000,		/* addiu $a0, $zero, 0 */
+					/* error: */
+	/* param_result = nvmcon_result; */
+	0x26240000,		/* addiu $a0, $s1, 0 */
+					/* exit: */
+	0x7000003F,		/* sdbbp */
+					/* progflash: */
+	/* *nvmcon_addr = nvmcon_value; */
+	0xAD4B0000,		/* sw $t3, 0($t2) */
+	/* *nvmkey_addr = nvmkey1; */
+	0xAD480010,		/* sw $t0, 16($t2) */
+	/* *nvmkey_addr = nvmkey2; */
+	0xAD490010,		/* sw $t1, 16($t2) */
+	/* *nvmconset_addr = nvmconset_value; */
+	0xAD4C0008,		/* sw $t4, 8($t2) */
+					/* waitflash: */
+	/*    do { } while ((*NVMCON & nvmconset_value) != 0); */
+	0x8D500000,		/* lw $s0, 0($t2) */
+	0x020C8024,		/* and $s0, $s0, $t4 */
+	0x1600FFFD,		/* bne $s0, $zero, waitflash */
+	0x00000000,		/* nop */
+	0x00000000,		/* nop */
+	0x00000000,		/* nop */
+	0x00000000,		/* nop */
+	0x00000000,		/* nop */
+	/*    if ((*NVMCON & 0x3000) != 0) {
+		      goto error;
+	      } 
+	*/
+	0x8D510000,		/* lw $s1, 0($t2) */
+	0x32313000,		/* andi $s1, $s1, 0x3000 */
+	0x1620FFEF,		/* bne $s1, $zero, error */
+	/* *nvmconclr_addr = nvmconclr_value; */
+	0xAD4D0004,		/* sw $t5, 4($t2) */
+	/* return */
+	0x03E00008,		/* jr $ra */
+	0x00000000		/* nop */
+};
+
+static int pic32mz_write_block(struct flash_bank *bank, const uint8_t *buffer,
+		uint32_t offset, uint32_t count)
+{
+	struct target *target = bank->target;
+	uint32_t buffer_size = 16384;
+	struct working_area *write_algorithm;
+	struct working_area *source;
+	uint32_t address = bank->base + offset;
+	struct reg_param reg_params[3];
+	uint32_t row_size;
+	int retval = ERROR_OK;
+
+	// struct pic32mz_flash_bank *pic32mz_info = bank->driver_priv;
+	struct mips32_algorithm mips32_info;
+
+	/* flash write code */
+	if (target_alloc_working_area(target, sizeof(pic32mz_flash_write_code),
+			&write_algorithm) != ERROR_OK) {
+		LOG_WARNING("no working area available, can't do block memory writes");
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	};
+
+	/* 2K byte row */
+	row_size = 2*1024;
+
+	uint8_t code[sizeof(pic32mz_flash_write_code)];
+	target_buffer_set_u32_array(target, code, ARRAY_SIZE(pic32mz_flash_write_code),
+			pic32mz_flash_write_code);
+	retval = target_write_buffer(target, write_algorithm->address, sizeof(code), code);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* memory buffer */
+	while (target_alloc_working_area_try(target, buffer_size, &source) != ERROR_OK) {
+		buffer_size /= 2;
+		if (buffer_size <= 256) {
+			/* we already allocated the writing code, but failed to get a
+			 * buffer, free the algorithm */
+			target_free_working_area(target, write_algorithm);
+
+			LOG_WARNING("no large enough working area available, can't do block memory writes");
+			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+		}
+	}
+
+	mips32_info.common_magic = MIPS32_COMMON_MAGIC;
+	mips32_info.isa_mode = MIPS32_ISA_MIPS32;
+
+	init_reg_param(&reg_params[0], "r4", 32, PARAM_IN_OUT);
+	init_reg_param(&reg_params[1], "r5", 32, PARAM_OUT);
+	init_reg_param(&reg_params[2], "r6", 32, PARAM_OUT);
+
+	int row_offset = offset % row_size;
+	uint8_t *new_buffer = NULL;
+	if (row_offset && (count >= (row_size / 4))) {
+		new_buffer = malloc(buffer_size);
+		if (new_buffer == NULL) {
+			LOG_ERROR("Out of memory");
+			return ERROR_FAIL;
+		}
+		memset(new_buffer,  0xff, row_offset);
+		address -= row_offset;
+	} else
+		row_offset = 0;
+
+	while (count > 0) {
+		uint32_t status;
+		uint32_t thisrun_count;
+
+		if (row_offset) {
+			thisrun_count = (count > ((buffer_size - row_offset) / 4)) ?
+				((buffer_size - row_offset) / 4) : count;
+
+			memcpy(new_buffer + row_offset, buffer, thisrun_count * 4);
+
+			retval = target_write_buffer(target, source->address,
+				row_offset + thisrun_count * 4, new_buffer);
+			if (retval != ERROR_OK)
+				break;
+		} else {
+			thisrun_count = (count > (buffer_size / 4)) ?
+					(buffer_size / 4) : count;
+
+			retval = target_write_buffer(target, source->address,
+					thisrun_count * 4, buffer);
+			if (retval != ERROR_OK)
+				break;
+		}
+
+		buf_set_u32(reg_params[0].value, 0, 32, Virt2Phys(source->address));
+		buf_set_u32(reg_params[1].value, 0, 32, Virt2Phys(address));
+		buf_set_u32(reg_params[2].value, 0, 32, thisrun_count + row_offset / 4);
+
+		retval = target_run_algorithm(target, 0, NULL, 3, reg_params,
+				write_algorithm->address,
+				0, 10000, &mips32_info);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("error executing pic32mz flash write algorithm");
+			retval = ERROR_FLASH_OPERATION_FAILED;
+			break;
+		}
+
+		status = buf_get_u32(reg_params[0].value, 0, 32);
+
+		if (status & NVMCON_NVMERR) {
+			LOG_ERROR("Flash write error NVMERR (status = 0x%08" PRIx32 ")", status);
+			retval = ERROR_FLASH_OPERATION_FAILED;
+			break;
+		}
+
+		if (status & NVMCON_LVDERR) {
+			LOG_ERROR("Flash write error LVDERR (status = 0x%08" PRIx32 ")", status);
+			retval = ERROR_FLASH_OPERATION_FAILED;
+			break;
+		}
+
+		buffer += thisrun_count * 4;
+		address += thisrun_count * 4;
+		count -= thisrun_count;
+		if (row_offset) {
+			address += row_offset;
+			row_offset = 0;
+		}
+	}
+
+	target_free_working_area(target, source);
+	target_free_working_area(target, write_algorithm);
+
+	destroy_reg_param(&reg_params[0]);
+	destroy_reg_param(&reg_params[1]);
+	destroy_reg_param(&reg_params[2]);
+
+	if (new_buffer != NULL)
+		free(new_buffer);
+	return retval;
+}
+
+static int pic32mz_write_word(struct flash_bank *bank, uint32_t address, uint32_t word)
+{
+	struct target *target = bank->target;
+
+	target_write_u32(target, PIC32MZ_NVMADDR, Virt2Phys(address));
+	target_write_u32(target, PIC32MZ_NVMDATA0, word);
+
+	return pic32mz_nvm_exec(bank, NVMCON_OP_WORD_PROG, 5);
+}
+
+static int pic32mz_write_quad_word(struct flash_bank *bank, uint32_t address, uint32_t word0, uint32_t word1, uint32_t word2, uint32_t word3)
+{
+	struct target *target = bank->target;
+
+	target_write_u32(target, PIC32MZ_NVMADDR, Virt2Phys(address));
+	target_write_u32(target, PIC32MZ_NVMDATA0, word0);
+	target_write_u32(target, PIC32MZ_NVMDATA1, word1);
+	target_write_u32(target, PIC32MZ_NVMDATA2, word2);
+	target_write_u32(target, PIC32MZ_NVMDATA3, word3);
+
+	return pic32mz_nvm_exec(bank, NVMCON_OP_QUAD_WORD_PROG, 5);
+}
+
+static int pic32mz_write_quad_words(struct flash_bank *bank, uint32_t address, const uint8_t *buffer, uint32_t numwords)
+{
+	uint32_t words_remaining = numwords;
+	uint32_t curaddr = address;
+	int status;
+
+	if (address & 0xF) {
+		LOG_WARNING("address 0x%" PRIx32 "breaks required 16-byte alignment for PIC32MZ quad-word programming", address);
+		return ERROR_FLASH_DST_BREAKS_ALIGNMENT;
+	}
+	
+	while (words_remaining != 0) {
+		uint32_t chunk_words = (words_remaining > 4 ? 4 : words_remaining);
+		uint32_t words[4];
+
+		for (uint32_t i = 0; i < 4; i++) {
+			if (chunk_words > i) {
+				memcpy(&words[i], buffer + (curaddr-address) + (i*4), sizeof(uint32_t));
+			} else {
+				words[i] = 0xFFFFFFFF;
+			}
+		}
+
+		status = pic32mz_write_quad_word(bank, curaddr, words[0], words[1], words[2], words[3]);
+
+		if (status & NVMCON_NVMERR) {
+			LOG_ERROR("Flash write error NVMERR (status = 0x%08" PRIx32 ")", status);
+			return ERROR_FLASH_OPERATION_FAILED;
+		}
+
+		if (status & NVMCON_LVDERR) {
+			LOG_ERROR("Flash write error LVDERR (status = 0x%08" PRIx32 ")", status);
+			return ERROR_FLASH_OPERATION_FAILED;
+		}
+
+		curaddr += chunk_words * 4;
+		words_remaining -= chunk_words;
+	}
+
+	return ERROR_OK;
+}
+
+static int pic32mz_write(struct flash_bank *bank, const uint8_t *buffer, uint32_t offset, uint32_t count)
+{
+	uint32_t words_remaining = (count / 4);
+	uint32_t bytes_remaining = (count & 0x00000003);
+	uint32_t address = bank->base + offset;
+	uint32_t bytes_written = 0;
+	uint32_t status;
+	int retval;
+	uint32_t cfgcon_address;
+	uint32_t cfgcon;
+	bool ecc_is_on;
+
+	if (bank->target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	LOG_DEBUG("writing to flash at address 0x%08" PRIx32 " at offset 0x%8.8" PRIx32
+			" count: 0x%8.8" PRIx32 "", bank->base, offset, count);
+
+	cfgcon_address = PIC32MZ_CFGCON;
+	target_read_u32(bank->target, cfgcon_address, &cfgcon);
+	ecc_is_on = ((cfgcon & CFGCON_ECC) == 0);
+
+	if (ecc_is_on || Virt2Phys(bank->base) == PIC32MZ_PHYS_LOWER_BOOT_ALIAS || Virt2Phys(bank->base) == PIC32MZ_PHYS_UPPER_BOOT_ALIAS) {
+		return pic32mz_write_quad_words(bank, address, buffer, count/4);
+	}
+
+	if (offset & 0x3) {
+		LOG_WARNING("offset 0x%" PRIx32 "breaks required 4-byte alignment", offset);
+		return ERROR_FLASH_DST_BREAKS_ALIGNMENT;
+	}
+
+	/* multiple words (4-byte) to be programmed? */
+	if (words_remaining > 0) {
+		/* try using a block write */
+		retval = pic32mz_write_block(bank, buffer, offset, words_remaining);
+		if (retval != ERROR_OK) {
+			if (retval == ERROR_TARGET_RESOURCE_NOT_AVAILABLE) {
+				/* if block write failed (no sufficient working area),
+				 * we use normal (slow) single dword accesses */
+				LOG_WARNING("couldn't use block writes, falling back to single memory accesses");
+			} else if (retval == ERROR_FLASH_OPERATION_FAILED) {
+				LOG_ERROR("flash writing failed");
+				return retval;
+			}
+		} else {
+			buffer += words_remaining * 4;
+			address += words_remaining * 4;
+			words_remaining = 0;
+		}
+	}
+
+	while (words_remaining > 0) {
+		uint32_t value;
+		memcpy(&value, buffer + bytes_written, sizeof(uint32_t));
+
+		status = pic32mz_write_word(bank, address, value);
+
+		if (status & NVMCON_NVMERR) {
+			LOG_ERROR("Flash write error NVMERR (status = 0x%08" PRIx32 ")", status);
+			return ERROR_FLASH_OPERATION_FAILED;
+		}
+
+		if (status & NVMCON_LVDERR) {
+			LOG_ERROR("Flash write error LVDERR (status = 0x%08" PRIx32 ")", status);
+			return ERROR_FLASH_OPERATION_FAILED;
+		}
+
+		bytes_written += 4;
+		words_remaining--;
+		address += 4;
+	}
+
+	if (bytes_remaining) {
+		uint32_t value = 0xffffffff;
+		memcpy(&value, buffer + bytes_written, bytes_remaining);
+
+		status = pic32mz_write_word(bank, address, value);
+
+		if (status & NVMCON_NVMERR) {
+			LOG_ERROR("Flash write error NVMERR (status = 0x%08" PRIx32 ")", status);
+			return ERROR_FLASH_OPERATION_FAILED;
+		}
+
+		if (status & NVMCON_LVDERR) {
+			LOG_ERROR("Flash write error LVDERR (status = 0x%08" PRIx32 ")", status);
+			return ERROR_FLASH_OPERATION_FAILED;
+		}
+	}
+
+	return ERROR_OK;
+}
+
+static int pic32mz_probe(struct flash_bank *bank)
+{
+	struct target *target = bank->target;
+	struct pic32mz_flash_bank *pic32mz_info = bank->driver_priv;
+	struct mips32_common *mips32 = target->arch_info;
+	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
+	int i;
+	uint32_t num_pages = 0;
+	uint32_t num_bytes = 0;
+	uint32_t device_id;
+	int page_size;
+	const struct pic32mz_devs_s *pdev = NULL;
+
+	pic32mz_info->probed = 0;
+
+	device_id = ejtag_info->idcode;
+	LOG_INFO("device id = 0x%08" PRIx32 " (manuf 0x%03x dev 0x%04x, ver 0x%02x)",
+			  device_id,
+			  (unsigned)((device_id >> 1) & 0x7ff),
+			  (unsigned)((device_id >> 12) & 0xffff),
+			  (unsigned)((device_id >> 28) & 0xf));
+
+	if (((device_id >> 1) & 0x7ff) != PIC32MZ_MANUF_ID) {
+		LOG_WARNING("Cannot identify target as a PIC32MZ family.");
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	page_size = 16*1024;  // fixed size pages for PIC32MZ
+
+	if (Virt2Phys(bank->base) == PIC32MZ_PHYS_LOWER_BOOT_ALIAS || Virt2Phys(bank->base) == PIC32MZ_PHYS_UPPER_BOOT_ALIAS) {
+		/* 0x1FC00000 or 0x1FC20000: Boot flash size */
+		num_bytes = PIC32MZ_BOOT_BLOCK_NUMBYTES;
+	} else if ((pdev = pic32mz_lookup_device(device_id)) != NULL) {
+		num_bytes = (pdev->kb_program_flash * 1024);
+	} else {
+		num_bytes = (512 * 1024);  /* unknown device, assume 512 KB program flash */
+	}
+
+	LOG_INFO("flash size = %" PRId32 "kbytes", num_bytes / 1024);
+
+	if (bank->sectors) {
+		free(bank->sectors);
+		bank->sectors = NULL;
+	}
+
+	/* calculate numbers of pages */
+	num_pages = num_bytes / page_size;
+	bank->size = (num_pages * page_size);
+	bank->num_sectors = num_pages;
+	bank->sectors = malloc(sizeof(struct flash_sector) * num_pages);
+
+	for (i = 0; i < (int)num_pages; i++) {
+		bank->sectors[i].offset = i * page_size;
+		bank->sectors[i].size = page_size;
+		bank->sectors[i].is_erased = -1;
+		bank->sectors[i].is_protected = 1;
+	}
+
+	pic32mz_protect_check(bank);
+
+	pic32mz_info->probed = 1;
+
+	return ERROR_OK;
+}
+
+static int pic32mz_auto_probe(struct flash_bank *bank)
+{
+	struct pic32mz_flash_bank *pic32mz_info = bank->driver_priv;
+	if (pic32mz_info->probed)
+		return ERROR_OK;
+	return pic32mz_probe(bank);
+}
+
+static int pic32mz_info(struct flash_bank *bank, char *buf, int buf_size)
+{
+	struct target *target = bank->target;
+	struct mips32_common *mips32 = target->arch_info;
+	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
+	uint32_t device_id;
+	int printed = 0, i;
+
+	device_id = ejtag_info->idcode;
+
+	if (((device_id >> 1) & 0x7ff) != PIC32MZ_MANUF_ID) {
+		snprintf(buf, buf_size,
+				 "Cannot identify target as a PIC32MZ family (manufacturer 0x%03d != 0x%03d)\n",
+				 (unsigned)((device_id >> 1) & 0x7ff),
+				 PIC32MZ_MANUF_ID);
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	for (i = 0; pic32mz_devs[i].name != NULL; i++) {
+		if (pic32mz_devs[i].devid == (device_id & 0x0fffffff)) {
+			printed = snprintf(buf, buf_size, "PIC32MZ%s", pic32mz_devs[i].name);
+			break;
+		}
+	}
+
+	if (pic32mz_devs[i].name == NULL)
+		printed = snprintf(buf, buf_size, "Unknown");
+
+	buf += printed;
+	buf_size -= printed;
+	snprintf(buf, buf_size, " Ver: 0x%02x",
+			(unsigned)((device_id >> 28) & 0xf));
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(pic32mz_handle_pgm_word_command)
+{
+	uint32_t address, value;
+	int status, res;
+
+	if (CMD_ARGC != 3)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], address);
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], value);
+
+	struct flash_bank *bank;
+	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 2, &bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	if (address < bank->base || address >= (bank->base + bank->size)) {
+		command_print(CMD_CTX, "flash address '%s' is out of bounds", CMD_ARGV[0]);
+		return ERROR_OK;
+	}
+
+	res = ERROR_OK;
+	status = pic32mz_write_word(bank, address, value);
+	if (status & NVMCON_NVMERR)
+		res = ERROR_FLASH_OPERATION_FAILED;
+	if (status & NVMCON_LVDERR)
+		res = ERROR_FLASH_OPERATION_FAILED;
+
+	if (res == ERROR_OK)
+		command_print(CMD_CTX, "pic32mz pgm word complete");
+	else
+		command_print(CMD_CTX, "pic32mz pgm word failed (status = 0x%x)", status);
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(pic32mz_handle_unlock_command)
+{
+	uint32_t mchip_cmd;
+	struct target *target = NULL;
+	struct mips_m4k_common *mips_m4k;
+	struct mips_ejtag *ejtag_info;
+	int timeout = 10;
+
+	if (CMD_ARGC < 1) {
+		command_print(CMD_CTX, "pic32mz unlock <bank>");
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	struct flash_bank *bank;
+	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	target = bank->target;
+	mips_m4k = target_to_m4k(target);
+	ejtag_info = &mips_m4k->mips32.ejtag_info;
+
+	/* we have to use the MTAP to perform a full erase */
+	mips_ejtag_set_instr(ejtag_info, MTAP_SW_MTAP);
+	mips_ejtag_set_instr(ejtag_info, MTAP_COMMAND);
+
+	/* first check status of device */
+	mchip_cmd = MCHP_STATUS;
+	mips_ejtag_drscan_8(ejtag_info, &mchip_cmd);
+	if (mchip_cmd & (1 << 7)) {
+		/* device is not locked */
+		command_print(CMD_CTX, "pic32mz is already unlocked, erasing anyway");
+	}
+
+	/* unlock/erase device */
+	mips_ejtag_drscan_8_out(ejtag_info, MCHP_ASERT_RST);
+	jtag_add_sleep(200);
+
+	mips_ejtag_drscan_8_out(ejtag_info, MCHP_ERASE);
+
+	do {
+		mchip_cmd = MCHP_STATUS;
+		mips_ejtag_drscan_8(ejtag_info, &mchip_cmd);
+		if (timeout-- == 0) {
+			LOG_DEBUG("timeout waiting for unlock: 0x%" PRIx32 "", mchip_cmd);
+			break;
+		}
+		alive_sleep(1);
+	} while ((mchip_cmd & (1 << 2)) || (!(mchip_cmd & (1 << 3))));
+
+	mips_ejtag_drscan_8_out(ejtag_info, MCHP_DE_ASSERT_RST);
+
+	/* select ejtag tap */
+	mips_ejtag_set_instr(ejtag_info, MTAP_SW_ETAP);
+
+	command_print(CMD_CTX, "pic32mz unlocked.\n"
+			"INFO: a reset or power cycle is required "
+			"for the new settings to take effect.");
+
+	return ERROR_OK;
+}
+
+static const struct command_registration pic32mz_exec_command_handlers[] = {
+	{
+		.name = "pgm_word",
+		.usage = "<addr> <value> <bank>",
+		.handler = pic32mz_handle_pgm_word_command,
+		.mode = COMMAND_EXEC,
+		.help = "program a word",
+	},
+	{
+		.name = "unlock",
+		.handler = pic32mz_handle_unlock_command,
+		.mode = COMMAND_EXEC,
+		.usage = "[bank_id]",
+		.help = "Unlock/Erase entire device.",
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+static const struct command_registration pic32mz_command_handlers[] = {
+	{
+		.name = "pic32mz",
+		.mode = COMMAND_ANY,
+		.help = "pic32mz flash command group",
+		.usage = "",
+		.chain = pic32mz_exec_command_handlers,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+struct flash_driver pic32mz_flash = {
+	.name = "pic32mz",
+	.commands = pic32mz_command_handlers,
+	.flash_bank_command = pic32mz_flash_bank_command,
+	.erase = pic32mz_erase,
+	.protect = pic32mz_protect,
+	.write = pic32mz_write,
+	.read = default_flash_read,
+	.probe = pic32mz_probe,
+	.auto_probe = pic32mz_auto_probe,
+	.erase_check = default_flash_blank_check,
+	.protect_check = pic32mz_protect_check,
+	.info = pic32mz_info,
+};
diff --git b/src/helper/binarybuffer.h a/src/helper/binarybuffer.h
index eaa8c5263..bd83f54d9 100644
--- b/src/helper/binarybuffer.h
+++ a/src/helper/binarybuffer.h
@@ -126,6 +126,34 @@ static inline uint32_t buf_get_u32(const uint8_t *_buffer,
 	}
 }
 
+static inline uint64_t buf_get_u38(const void *_buffer,
+	unsigned first, unsigned num)
+{
+	const uint8_t *buffer = _buffer;
+
+	if ((num == 32) && (first == 0)) {
+		return 0 + ((((uint32_t)buffer[3]) << 24) |   /* Note - zero plus is to avoid a checkpatch bug */
+				(((uint32_t)buffer[2]) << 16) |
+				(((uint32_t)buffer[1]) << 8)  |
+				(((uint32_t)buffer[0]) << 0));
+	} else if ((num == 38) && (first == 0)) {
+		return 0 + ((((uint64_t)buffer[6]) << 48) |   /* Note - zero plus is to avoid a checkpatch bug */
+				(((uint64_t)buffer[5]) << 40) |
+				(((uint64_t)buffer[4]) << 32) |
+				(((uint64_t)buffer[3]) << 24) |
+				(((uint64_t)buffer[2]) << 16) |
+				(((uint64_t)buffer[1]) << 8)  |
+				(((uint64_t)buffer[0]) << 0));
+	} else {
+		uint64_t result = 0;
+		for (unsigned i = first; i < first + num; i++) {
+			if (((buffer[i / 5] >> (i % 5)) & 1) == 1)
+				result = result | ((uint64_t)1 << (uint64_t)(i - first));
+		}
+		return result;
+	}
+}
+
 /**
  * Retrieves @c num bits from @c _buffer, starting at the @c first bit,
  * returning the bits in a 64-bit word.  This routine fast-paths reads
diff --git b/src/jtag/drivers/OpenULINK/Makefile a/src/jtag/drivers/OpenULINK/Makefile
deleted file mode 100644
index 8ef2d03f9..000000000
--- b/src/jtag/drivers/OpenULINK/Makefile
+++ /dev/null
@@ -1,89 +0,0 @@
-############################################################################
-#    Copyright (C) 2011 by Martin Schmoelzer                               #
-#    <martin.schmoelzer@student.tuwien.ac.at>                              #
-#                                                                          #
-#    This program is free software; you can redistribute it and/or modify  #
-#    it under the terms of the GNU General Public License as published by  #
-#    the Free Software Foundation; either version 2 of the License, or     #
-#    (at your option) any later version.                                   #
-#                                                                          #
-#    This program is distributed in the hope that it will be useful,       #
-#    but WITHOUT ANY WARRANTY; without even the implied warranty of        #
-#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         #
-#    GNU General Public License for more details.                          #
-#                                                                          #
-#    You should have received a copy of the GNU General Public License     #
-#    along with this program; if not, write to the                         #
-#    Free Software Foundation, Inc.,                                       #
-#    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           #
-############################################################################
-
-# Define the name of our tools. Some distributions (e. g. Fedora) prefix
-# the SDCC executables, change this accordingly!
-PREFIX =
-
-# Small Device C Compiler: http://sdcc.sourceforge.net/
-CC = $(PREFIX)-sdcc
-
-# 8051 assembler, part of the SDCC software package.
-AS = $(PREFIX)-sdas8051
-
-# SDCC produces quite messy Intel HEX files. This tool is be used to re-format
-# those files. It is not required for the firmware download functionality in
-# the OpenOCD driver, but the resulting file is smaller.
-PACKIHX = $(PREFIX)-packihx
-
-# GNU binutils size. Used to print the size of the IHX file generated by SDCC.
-SIZE = size
-
-# Source and header directories.
-SRC_DIR     = src
-INCLUDE_DIR = include
-
-CODE_SIZE = 0x1B00
-
-# Starting address of __xdata variables. Since the OpenULINK firmware does not
-# use any of the isochronous interrupts, we can use the isochronous buffer space
-# as XDATA memory.
-XRAM_LOC  = 0x2000
-XRAM_SIZE = 0x0800
-
-CFLAGS  = --std-sdcc99 --opt-code-size --model-small
-LDFLAGS = --code-loc 0x0000 --code-size $(CODE_SIZE) --xram-loc $(XRAM_LOC) \
-          --xram-size $(XRAM_SIZE) --iram-size 256 --model-small
-
-# list of base object files
-OBJECTS = main.rel usb.rel protocol.rel jtag.rel delay.rel USBJmpTb.rel
-HEADERS = $(INCLUDE_DIR)/main.h         \
-          $(INCLUDE_DIR)/usb.h          \
-          $(INCLUDE_DIR)/protocol.h     \
-          $(INCLUDE_DIR)/jtag.h         \
-          $(INCLUDE_DIR)/delay.h        \
-          $(INCLUDE_DIR)/reg_ezusb.h    \
-          $(INCLUDE_DIR)/io.h           \
-          $(INCLUDE_DIR)/msgtypes.h
-
-# Disable all built-in rules.
-.SUFFIXES:
-
-# Targets which are executed even when identically named file is present.
-.PHONY: all, clean
-
-all: ulink_firmware.ihx
-	$(SIZE) ulink_firmware.ihx
-
-ulink_firmware.ihx: $(OBJECTS)
-	$(CC) -mmcs51 $(LDFLAGS) -o $@ $^
-
-# Rebuild every C module (there are only 5 of them) if any header changes.
-%.rel: $(SRC_DIR)/%.c $(HEADERS)
-	$(CC) -c $(CFLAGS) -mmcs51 -I$(INCLUDE_DIR) -o $@ $<
-
-%.rel: $(SRC_DIR)/%.a51
-	$(AS) -lsgo $@ $<
-
-clean:
-	rm -f *.asm *.lst *.rel *.rst *.sym *.ihx *.lk *.map *.mem
-
-hex: ulink_firmware.ihx
-	$(PACKIHX) ulink_firmware.ihx > ulink_firmware.hex
diff --git b/src/target/Makefile.am a/src/target/Makefile.am
index bf80c64c0..ac1afd99b 100644
--- b/src/target/Makefile.am
+++ a/src/target/Makefile.am
@@ -108,7 +108,10 @@ AVR32_SRC = \
 
 MIPS32_SRC = \
 	mips32.c \
+	mips_common.c \
 	mips_m4k.c \
+	mips_mAptiv.c \
+	mips_iAptiv.c \
 	mips32_pracc.c \
 	mips32_dmaacc.c \
 	mips_ejtag.c
@@ -168,7 +171,9 @@ noinst_HEADERS = \
 	etm_dummy.h \
 	image.h \
 	mips32.h \
+	mips_common.h \
 	mips_m4k.h \
+	mips_mAptiv.h \
 	mips_ejtag.h \
 	mips32_pracc.h \
 	mips32_dmaacc.h \
diff --git b/src/target/image.c a/src/target/image.c
index b1b7e3a6a..0367c8018 100644
--- b/src/target/image.c
+++ a/src/target/image.c
@@ -345,6 +345,8 @@ static int image_elf_read_headers(struct image *image)
 	int retval;
 	uint32_t nload, load_to_vaddr = 0;
 
+#define PT_NOTE    4
+
 	elf->header = malloc(sizeof(Elf32_Ehdr));
 
 	if (elf->header == NULL) {
@@ -409,12 +411,18 @@ static int image_elf_read_headers(struct image *image)
 
 	/* count useful segments (loadable), ignore BSS section */
 	image->num_sections = 0;
-	for (i = 0; i < elf->segment_count; i++)
-		if ((field32(elf,
-			elf->segments[i].p_type) == PT_LOAD) &&
+	for (i = 0; i < elf->segment_count; i++){
+		int type = (field32(elf, elf->segments[i].p_type) == PT_LOAD);
+//		if ((field32(elf,
+//			elf->segments[i].p_type) == PT_LOAD) &&
+//			(field32(elf, elf->segments[i].p_filesz) != 0))
+//			image->num_sections++;
+
+
+		if (((type == PT_LOAD) || (type == PT_NOTE)) &&
 			(field32(elf, elf->segments[i].p_filesz) != 0))
 			image->num_sections++;
-
+	}
 	assert(image->num_sections > 0);
 
 	/**
@@ -430,10 +438,18 @@ static int image_elf_read_headers(struct image *image)
 	for (nload = 0, i = 0; i < elf->segment_count; i++)
 		if (elf->segments[i].p_paddr != 0)
 			break;
-		else if ((field32(elf,
-			elf->segments[i].p_type) == PT_LOAD) &&
-			(field32(elf, elf->segments[i].p_memsz) != 0))
+//		else if ((field32(elf,
+//				 elf->segments[i].p_type) == PT_LOAD) &&
+//				 (field32(elf, elf->segments[i].p_memsz) != 0))
+//			++nload;
+
+
+		else {
+			int type = (field32(elf, elf->segments[i].p_type) == PT_LOAD);
+			if (((type == PT_LOAD) || (type == PT_NOTE)) &&
+				(field32(elf, elf->segments[i].p_filesz) != 0))
 			++nload;
+		}
 
 	if (i >= elf->segment_count && nload > 1)
 		load_to_vaddr = 1;
@@ -441,8 +457,14 @@ static int image_elf_read_headers(struct image *image)
 	/* alloc and fill sections array with loadable segments */
 	image->sections = malloc(image->num_sections * sizeof(struct imagesection));
 	for (i = 0, j = 0; i < elf->segment_count; i++) {
-		if ((field32(elf,
-			elf->segments[i].p_type) == PT_LOAD) &&
+//		if ((field32(elf,
+//			elf->segments[i].p_type) == PT_LOAD) &&
+//		   (field32(elf, elf->segments[i].p_filesz) != 0)) {
+//			image->sections[j].size = field32(elf, elf->segments[i].p_filesz);
+
+
+		int type = (field32(elf, elf->segments[i].p_type) == PT_LOAD);
+		if (((type == PT_LOAD) || (type == PT_NOTE)) &&
 			(field32(elf, elf->segments[i].p_filesz) != 0)) {
 			image->sections[j].size = field32(elf, elf->segments[i].p_filesz);
 			if (load_to_vaddr)
@@ -459,6 +481,7 @@ static int image_elf_read_headers(struct image *image)
 
 	image->start_address_set = 1;
 	image->start_address = field32(elf, elf->header->e_entry);
+	LOG_USER ("Execution start_address = 0x%x",image->start_address);
 
 	return ERROR_OK;
 }
diff --git b/src/target/mips32.c a/src/target/mips32.c
index 5a0e2a3a1..d159bfc52 100644
--- b/src/target/mips32.c
+++ a/src/target/mips32.c
@@ -4,12 +4,15 @@
  *                                                                         *
  *   Copyright (C) 2008 by David T.L. Wong                                 *
  *                                                                         *
- *   Copyright (C) 2007,2008 yvind Harboe                                 *
+ *   Copyright (C) 2007,2008 yvind Harboe                             *
  *   oyvind.harboe@zylin.com                                               *
  *                                                                         *
  *   Copyright (C) 2011 by Drasko DRASKOVIC                                *
  *   drasko.draskovic@gmail.com                                            *
  *                                                                         *
+ *   Copyright (C) 2014 by Kent Brinkley								   *
+ *   jkbrinkley.imgtec@gmail.com										   *
+ *																		   *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -35,137 +38,174 @@
 #include "algorithm.h"
 #include "register.h"
 
+int mips_common_handle_target_request(void *priv);
+
 static const char *mips_isa_strings[] = {
-	"MIPS32", "MIPS16e"
+	"MIPS32", "MIPS16"
 };
 
 #define MIPS32_GDB_DUMMY_FP_REG 1
 
-/*
- * GDB registers
- * based on gdb-7.6.2/gdb/features/mips-{fpu,cp0,cpu}.xml
- */
 static const struct {
-	unsigned id;
+	unsigned option;
+	const char *arg;
+} invalidate_cmd[5] = {
+	{ ALL, "all", },
+	{ INST, "inst", },
+	{ DATA, "data", },
+	{ ALLNOWB, "allnowb", },
+	{ DATANOWB, "datanowb", },
+};
+
+static const struct {
 	const char *name;
 	enum reg_type type;
 	const char *group;
 	const char *feature;
 	int flag;
 } mips32_regs[] = {
-	{  0,  "r0", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
-	{  1,  "r1", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
-	{  2,  "r2", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
-	{  3,  "r3", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
-	{  4,  "r4", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
-	{  5,  "r5", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
-	{  6,  "r6", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
-	{  7,  "r7", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
-	{  8,  "r8", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
-	{  9,  "r9", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
-	{ 10, "r10", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
-	{ 11, "r11", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
-	{ 12, "r12", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
-	{ 13, "r13", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
-	{ 14, "r14", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
-	{ 15, "r15", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
-	{ 16, "r16", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
-	{ 17, "r17", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
-	{ 18, "r18", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
-	{ 19, "r19", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
-	{ 20, "r20", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
-	{ 21, "r21", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
-	{ 22, "r22", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
-	{ 23, "r23", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
-	{ 24, "r24", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
-	{ 25, "r25", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
-	{ 26, "r26", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
-	{ 27, "r27", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
-	{ 28, "r28", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
-	{ 29, "r29", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
-	{ 30, "r30", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
-	{ 31, "r31", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
-	{ 32, "status", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cp0", 0 },
-	{ 33, "lo", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
-	{ 34, "hi", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
-	{ 35, "badvaddr", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cp0", 0 },
-	{ 36, "cause", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cp0", 0 },
-	{ 37, "pc", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
-
-	{ 38,  "f0", REG_TYPE_IEEE_SINGLE, NULL,
+	{ "r0", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
+	{ "r1", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
+	{ "r2", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
+	{ "r3", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
+	{ "r4", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
+	{ "r5", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
+	{ "r6", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
+	{ "r7", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
+	{ "r8", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
+	{ "r9", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
+	{ "r10", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
+	{ "r11", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
+	{ "r12", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
+	{ "r13", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
+	{ "r14", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
+	{ "r15", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
+	{ "r16", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
+	{ "r17", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
+	{ "r18", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
+	{ "r19", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
+	{ "r20", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
+	{ "r21", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
+	{ "r22", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
+	{ "r23", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
+	{ "r24", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
+	{ "r25", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
+	{ "r26", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
+	{ "r27", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
+	{ "r28", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
+	{ "r29", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
+	{ "r30", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
+	{ "r31", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
+	{ "status", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cp0", 0 },
+	{ "lo", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
+	{ "hi", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
+	{ "badvaddr", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cp0", 0 },
+	{ "cause", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cp0", 0 },
+	{ "pc", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cpu", 0 },
+	{ "guestCtl1", REG_TYPE_INT, NULL, "org.gnu.gdb.mips.cp0", 0 },
+	{  "f0", REG_TYPE_IEEE_SINGLE, NULL,
 		"org.gnu.gdb.mips.fpu", MIPS32_GDB_DUMMY_FP_REG },
-	{ 39,  "f1", REG_TYPE_IEEE_SINGLE, NULL,
+	{  "f1", REG_TYPE_IEEE_SINGLE, NULL,
 		"org.gnu.gdb.mips.fpu", MIPS32_GDB_DUMMY_FP_REG },
-	{ 40,  "f2", REG_TYPE_IEEE_SINGLE, NULL,
+	{  "f2", REG_TYPE_IEEE_SINGLE, NULL,
 		"org.gnu.gdb.mips.fpu", MIPS32_GDB_DUMMY_FP_REG },
-	{ 41,  "f3", REG_TYPE_IEEE_SINGLE, NULL,
+	{  "f3", REG_TYPE_IEEE_SINGLE, NULL,
 		"org.gnu.gdb.mips.fpu", MIPS32_GDB_DUMMY_FP_REG },
-	{ 42,  "f4", REG_TYPE_IEEE_SINGLE, NULL,
+	{  "f4", REG_TYPE_IEEE_SINGLE, NULL,
 		"org.gnu.gdb.mips.fpu", MIPS32_GDB_DUMMY_FP_REG },
-	{ 43,  "f5", REG_TYPE_IEEE_SINGLE, NULL,
+	{  "f5", REG_TYPE_IEEE_SINGLE, NULL,
 		"org.gnu.gdb.mips.fpu", MIPS32_GDB_DUMMY_FP_REG },
-	{ 44,  "f6", REG_TYPE_IEEE_SINGLE, NULL,
+	{  "f6", REG_TYPE_IEEE_SINGLE, NULL,
 		"org.gnu.gdb.mips.fpu", MIPS32_GDB_DUMMY_FP_REG },
-	{ 45,  "f7", REG_TYPE_IEEE_SINGLE, NULL,
+	{  "f7", REG_TYPE_IEEE_SINGLE, NULL,
 		"org.gnu.gdb.mips.fpu", MIPS32_GDB_DUMMY_FP_REG },
-	{ 46,  "f8", REG_TYPE_IEEE_SINGLE, NULL,
+	{  "f8", REG_TYPE_IEEE_SINGLE, NULL,
 		"org.gnu.gdb.mips.fpu", MIPS32_GDB_DUMMY_FP_REG },
-	{ 47,  "f9", REG_TYPE_IEEE_SINGLE, NULL,
+	{  "f9", REG_TYPE_IEEE_SINGLE, NULL,
 		"org.gnu.gdb.mips.fpu", MIPS32_GDB_DUMMY_FP_REG },
-	{ 48, "f10", REG_TYPE_IEEE_SINGLE, NULL,
+	{ "f10", REG_TYPE_IEEE_SINGLE, NULL,
 		"org.gnu.gdb.mips.fpu", MIPS32_GDB_DUMMY_FP_REG },
-	{ 49, "f11", REG_TYPE_IEEE_SINGLE, NULL,
+	{ "f11", REG_TYPE_IEEE_SINGLE, NULL,
 		"org.gnu.gdb.mips.fpu", MIPS32_GDB_DUMMY_FP_REG },
-	{ 50, "f12", REG_TYPE_IEEE_SINGLE, NULL,
+	{ "f12", REG_TYPE_IEEE_SINGLE, NULL,
 		"org.gnu.gdb.mips.fpu", MIPS32_GDB_DUMMY_FP_REG },
-	{ 51, "f13", REG_TYPE_IEEE_SINGLE, NULL,
+	{ "f13", REG_TYPE_IEEE_SINGLE, NULL,
 		"org.gnu.gdb.mips.fpu", MIPS32_GDB_DUMMY_FP_REG },
-	{ 52, "f14", REG_TYPE_IEEE_SINGLE, NULL,
+	{ "f14", REG_TYPE_IEEE_SINGLE, NULL,
 		"org.gnu.gdb.mips.fpu", MIPS32_GDB_DUMMY_FP_REG },
-	{ 53, "f15", REG_TYPE_IEEE_SINGLE, NULL,
+	{ "f15", REG_TYPE_IEEE_SINGLE, NULL,
 		"org.gnu.gdb.mips.fpu", MIPS32_GDB_DUMMY_FP_REG },
-	{ 54, "f16", REG_TYPE_IEEE_SINGLE, NULL,
+	{ "f16", REG_TYPE_IEEE_SINGLE, NULL,
 		"org.gnu.gdb.mips.fpu", MIPS32_GDB_DUMMY_FP_REG },
-	{ 55, "f17", REG_TYPE_IEEE_SINGLE, NULL,
+	{ "f17", REG_TYPE_IEEE_SINGLE, NULL,
 		"org.gnu.gdb.mips.fpu", MIPS32_GDB_DUMMY_FP_REG },
-	{ 56, "f18", REG_TYPE_IEEE_SINGLE, NULL,
+	{ "f18", REG_TYPE_IEEE_SINGLE, NULL,
 		"org.gnu.gdb.mips.fpu", MIPS32_GDB_DUMMY_FP_REG },
-	{ 57, "f19", REG_TYPE_IEEE_SINGLE, NULL,
+	{ "f19", REG_TYPE_IEEE_SINGLE, NULL,
 		"org.gnu.gdb.mips.fpu", MIPS32_GDB_DUMMY_FP_REG },
-	{ 58, "f20", REG_TYPE_IEEE_SINGLE, NULL,
+	{ "f20", REG_TYPE_IEEE_SINGLE, NULL,
 		"org.gnu.gdb.mips.fpu", MIPS32_GDB_DUMMY_FP_REG },
-	{ 59, "f21", REG_TYPE_IEEE_SINGLE, NULL,
+	{ "f21", REG_TYPE_IEEE_SINGLE, NULL,
 		"org.gnu.gdb.mips.fpu", MIPS32_GDB_DUMMY_FP_REG },
-	{ 60, "f22", REG_TYPE_IEEE_SINGLE, NULL,
+	{ "f22", REG_TYPE_IEEE_SINGLE, NULL,
 		"org.gnu.gdb.mips.fpu", MIPS32_GDB_DUMMY_FP_REG },
-	{ 61, "f23", REG_TYPE_IEEE_SINGLE, NULL,
+	{ "f23", REG_TYPE_IEEE_SINGLE, NULL,
 		"org.gnu.gdb.mips.fpu", MIPS32_GDB_DUMMY_FP_REG },
-	{ 62, "f24", REG_TYPE_IEEE_SINGLE, NULL,
+	{ "f24", REG_TYPE_IEEE_SINGLE, NULL,
 		"org.gnu.gdb.mips.fpu", MIPS32_GDB_DUMMY_FP_REG },
-	{ 63, "f25", REG_TYPE_IEEE_SINGLE, NULL,
+	{ "f25", REG_TYPE_IEEE_SINGLE, NULL,
 		"org.gnu.gdb.mips.fpu", MIPS32_GDB_DUMMY_FP_REG },
-	{ 64, "f26", REG_TYPE_IEEE_SINGLE, NULL,
+	{ "f26", REG_TYPE_IEEE_SINGLE, NULL,
 		"org.gnu.gdb.mips.fpu", MIPS32_GDB_DUMMY_FP_REG },
-	{ 65, "f27", REG_TYPE_IEEE_SINGLE, NULL,
+	{ "f27", REG_TYPE_IEEE_SINGLE, NULL,
 		"org.gnu.gdb.mips.fpu", MIPS32_GDB_DUMMY_FP_REG },
-	{ 66, "f28", REG_TYPE_IEEE_SINGLE, NULL,
+	{ "f28", REG_TYPE_IEEE_SINGLE, NULL,
 		"org.gnu.gdb.mips.fpu", MIPS32_GDB_DUMMY_FP_REG },
-	{ 67, "f29", REG_TYPE_IEEE_SINGLE, NULL,
+	{ "f29", REG_TYPE_IEEE_SINGLE, NULL,
 		"org.gnu.gdb.mips.fpu", MIPS32_GDB_DUMMY_FP_REG },
-	{ 68, "f30", REG_TYPE_IEEE_SINGLE, NULL,
+	{ "f30", REG_TYPE_IEEE_SINGLE, NULL,
 		"org.gnu.gdb.mips.fpu", MIPS32_GDB_DUMMY_FP_REG },
-	{ 69, "f31", REG_TYPE_IEEE_SINGLE, NULL,
+	{ "f31", REG_TYPE_IEEE_SINGLE, NULL,
 		"org.gnu.gdb.mips.fpu", MIPS32_GDB_DUMMY_FP_REG },
-	{ 70, "fcsr", REG_TYPE_INT, "float",
+	{ "fcsr", REG_TYPE_INT, "float",
 		"org.gnu.gdb.mips.fpu", MIPS32_GDB_DUMMY_FP_REG },
-	{ 71, "fir", REG_TYPE_INT, "float",
+	{ "fir", REG_TYPE_INT, "float",
 		"org.gnu.gdb.mips.fpu", MIPS32_GDB_DUMMY_FP_REG },
 };
 
+/* Order fixed */
+static const struct {
+	const char *name;
+} mips32_dsp_regs[MIPS32NUMDSPREGS] = {
+	{ "hi0"},
+	{ "hi1"},
+	{ "hi2"},
+	{ "hi3"},
+	{ "lo0"},
+	{ "lo1"},
+	{ "lo2"},
+	{ "lo3"},
+	{ "control"},
+};
+
+/* number of mips dummy fp regs fp0 - fp31 + fsr and fir
+ * we also add 18 unknown registers to handle gdb requests */
 
 #define MIPS32_NUM_REGS ARRAY_SIZE(mips32_regs)
 
-static uint8_t mips32_gdb_dummy_fp_value[] = {0, 0, 0, 0};
+/* WAYS MAPPING */
+static const int wayTable[] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};	   /* field->ways mapping */
+static const int setTableISDS[] = {64,128,256,512,1024,2048,4096,32,		  /* field->sets mapping */
+16*1024, 32*1024, 64*1024, 128*1024, 256*1024, 512*1024, 1024*1024, 2048*1024};
+static const int setTable[] = {64,128,256,512,1024,2048,4096,8192,			  /* field->sets mapping */
+16*1024, 32*1024, 64*1024, 128*1024, 256*1024, 512*1024, 1024*1024, 2048*1024};
+
+/* BPL */
+static const int bplTable[] = {0,4,8,16,32,64,128,256,512,1024,2048,4*1024,8*1024,16*1024,32*1024,64*1024}; /* field->bytes per line */
+static const int bplbitTable[] = {0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};									/* field->bits in bpl */
+
+static uint32_t  ftlb_ways[16] = {2,3,4,5, 6,7,8,0,   0,0,0,0, 0,0,0,0};
+static uint32_t  ftlb_sets[16] = {1,2,4,8, 16,32,64,128, 256,0,0,0, 0,0,0,0};
 
 static int mips32_get_core_reg(struct reg *reg)
 {
@@ -178,7 +218,6 @@ static int mips32_get_core_reg(struct reg *reg)
 		return ERROR_TARGET_NOT_HALTED;
 
 	retval = mips32_target->read_core_reg(target, mips32_reg->num);
-
 	return retval;
 }
 
@@ -186,6 +225,15 @@ static int mips32_set_core_reg(struct reg *reg, uint8_t *buf)
 {
 	struct mips32_core_reg *mips32_reg = reg->arch_info;
 	struct target *target = mips32_reg->target;
+
+	/* get pointers to arch-specific information */
+	struct mips32_common *mips32 = target_to_mips32(target);
+
+	if ((mips32->fp_implemented != FP_IMP)&& (mips32_reg->num > MIPS32_PC)){
+		LOG_USER ("No Upate - No FPU Available");
+		return ERROR_OK;
+	}
+
 	uint32_t value = buf_get_u32(buf, 0, 32);
 
 	if (target->state != TARGET_HALTED)
@@ -226,11 +274,15 @@ static int mips32_write_core_reg(struct target *target, unsigned int num)
 	if (num >= MIPS32_NUM_REGS)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
-	reg_value = buf_get_u32(mips32->core_cache->reg_list[num].value, 0, 32);
-	mips32->core_regs[num] = reg_value;
-	LOG_DEBUG("write core reg %i value 0x%" PRIx32 "", num , reg_value);
-	mips32->core_cache->reg_list[num].valid = 1;
-	mips32->core_cache->reg_list[num].dirty = 0;
+	if ((mips32->fp_implemented != FP_IMP)&& (num > MIPS32_PC)){
+		LOG_USER ("No FPU Available");
+	} else {
+		reg_value = buf_get_u32(mips32->core_cache->reg_list[num].value, 0, 32);
+		mips32->core_regs[num] = reg_value;
+		LOG_DEBUG("write core reg %i value 0x%" PRIx32 "", num , reg_value);
+		mips32->core_cache->reg_list[num].valid = 1;
+		mips32->core_cache->reg_list[num].dirty = 0;
+	}
 
 	return ERROR_OK;
 }
@@ -255,17 +307,147 @@ int mips32_get_gdb_reg_list(struct target *target, struct reg **reg_list[],
 int mips32_save_context(struct target *target)
 {
 	unsigned int i;
+	int retval;
+	uint32_t config1;
 
 	/* get pointers to arch-specific information */
 	struct mips32_common *mips32 = target_to_mips32(target);
 	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
 
 	/* read core registers */
-	mips32_pracc_read_regs(ejtag_info, mips32->core_regs);
+	retval = mips32_pracc_read_regs(ejtag_info, mips32->core_regs);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("mips32_pracc_read_regs failed");
+		return retval;
+	}
 
 	for (i = 0; i < MIPS32_NUM_REGS; i++) {
-		if (!mips32->core_cache->reg_list[i].valid)
-			mips32->read_core_reg(target, i);
+		if (!mips32->core_cache->reg_list[i].valid) {
+			retval = mips32->read_core_reg(target, i);
+			if (retval != ERROR_OK) {
+				LOG_DEBUG("mips32->read_core_reg failed");
+				return retval;
+			}
+		}
+	}
+
+	/* Read Config1 registers */
+	retval = mips32_pracc_cp0_read(ejtag_info, &config1, 16, 1);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("reading config3 register failed");
+		return retval;
+	}
+
+	/* Retrive if Float Point CoProcessor Implemented */
+	mips32->fp_implemented = (config1 & CFG1_FP);
+
+	/* FP Coprocessor available read FP registers */
+	if (mips32->fp_implemented == FP_IMP) {
+		uint32_t config3;
+		uint32_t mvpconf1;
+		uint32_t status;
+		uint32_t tmp_status;
+
+		/* Read Config1 registers */
+		retval = mips32_pracc_cp0_read(ejtag_info, &config1, 16, 3);
+		if (retval != ERROR_OK) {
+			LOG_DEBUG("reading config3 register failed");
+			return retval;
+		}
+
+		/* Read Config3 registers */
+		retval = mips32_pracc_cp0_read(ejtag_info, &config3, 16, 3);
+		if (retval != ERROR_OK) {
+			LOG_DEBUG("reading config3 register failed");
+			return retval;
+		}
+
+		/* Read mvpconf1 registers */
+		retval = mips32_pracc_cp0_read(ejtag_info, &mvpconf1, 0, 3);
+		if (retval != ERROR_OK) {
+			LOG_DEBUG("reading config3 register failed");
+			return retval;
+		}
+
+		/* check if VPE has access to FPU */
+		if ((config1 & 0x00000001) ) {
+
+			/* Check if multi-thread core with single thread FPU */
+			if ((((config3 & 0x00000004) >> 2) == 1) && ((mvpconf1 & 0x00000001) == 1)) {
+
+				/* Read Status register, save it and modify to enable CP0 */
+				retval = mips32_pracc_cp0_read(ejtag_info, &status, 12, 0);
+				if (retval != ERROR_OK) {
+					LOG_DEBUG("reading status register failed");
+					return retval;
+				}
+
+				/* Check if Access to COP1 enabled */
+				if (((status & 0x20000000) >> 29) == 0) {
+					if ((retval = mips32_pracc_cp0_write(ejtag_info, (status | STATUS_CU1_MASK), 12, 0)) != ERROR_OK) {
+						LOG_DEBUG("writing status register failed");
+						return retval;
+					}
+
+					/* Verify CP1 Enabled */
+					retval = mips32_pracc_cp0_read(ejtag_info, &tmp_status, 12, 0);
+					if (retval != ERROR_OK) {
+						LOG_DEBUG("writing status register failed");
+						return retval;
+					}
+
+					if (((tmp_status & 0x20000000) >> 29)!= 1) {
+						LOG_USER ("1 Access to FPU not available - tmp_status: 0x%x, status: 0x%x", tmp_status, status);
+						return retval;
+					}
+				}
+
+				/* read core registers */
+				retval = mips32_pracc_read_fpu_regs(ejtag_info, (uint32_t *)(&mips32->core_regs[MIPS32_F0]));
+				if (retval != ERROR_OK)
+					LOG_INFO("mips32->read_core_reg failed");
+
+				/* restore previous setting */
+				if ((mips32_pracc_cp0_write(ejtag_info, status, 12, 0)) != ERROR_OK)
+					LOG_DEBUG("writing status register failed");
+			}
+		} else {
+//			LOG_INFO("Enable COP2");
+			/* Read Status register, save it and modify to enable CP0 */
+			retval = mips32_pracc_cp0_read(ejtag_info, &status, 12, 0);
+			if (retval != ERROR_OK) {
+				LOG_DEBUG("reading status register failed");
+				return retval;
+			}
+
+			/* Check if Access to COP1 enabled */
+			if (((status & 0x20000000) >> 29) == 0) {
+				if ((retval = mips32_pracc_cp0_write(ejtag_info, (status | STATUS_CU1_MASK), 12, 0)) != ERROR_OK) {
+					LOG_DEBUG("writing status register failed");
+						return retval;
+				}
+			}
+
+			/* read core registers */
+			retval = mips32_pracc_read_fpu_regs(ejtag_info, (uint32_t *)(&mips32->core_regs[MIPS32_F0]));
+			if (retval != ERROR_OK)
+				LOG_INFO("mips32->read_fpu_reg failed: status: 0x%x, tmp_status: 0x%x", status, tmp_status);
+			
+			/* restore previous setting */
+			if ((mips32_pracc_cp0_write(ejtag_info, status, 12, 0)) != ERROR_OK)
+				LOG_DEBUG("writing status register failed");
+		}
+
+		for (i = MIPS32_F0; i < MIPS32_NUM_REGS; i++) {
+			if (mips32->core_cache->reg_list[i].valid) {
+				retval = mips32->read_core_reg(target, i);
+				if (retval != ERROR_OK) {
+					LOG_DEBUG("mips32->read_core_reg failed");
+					return retval;
+				}
+			}
+		}
+
 	}
 
 	return ERROR_OK;
@@ -274,6 +456,8 @@ int mips32_save_context(struct target *target)
 int mips32_restore_context(struct target *target)
 {
 	unsigned int i;
+	int retval;
+	uint32_t config1;
 
 	/* get pointers to arch-specific information */
 	struct mips32_common *mips32 = target_to_mips32(target);
@@ -284,6 +468,99 @@ int mips32_restore_context(struct target *target)
 			mips32->write_core_reg(target, i);
 	}
 
+	/* If FPU then Update registers */
+	/* FP Coprocessor available read FP registers */
+	if (mips32->fp_implemented == FP_IMP) {
+		uint32_t config3;
+		uint32_t mvpconf1;
+		uint32_t status;
+		uint32_t tmp_status;
+
+		/* Read Config1 registers */
+		retval = mips32_pracc_cp0_read(ejtag_info, &config1, 16, 1);
+		if (retval != ERROR_OK) {
+			LOG_DEBUG("reading config1 register failed");
+			return retval;
+		}
+
+		/* Read Config3 registers */
+		retval = mips32_pracc_cp0_read(ejtag_info, &config3, 16, 3);
+		if (retval != ERROR_OK) {
+			LOG_DEBUG("reading config3 register failed");
+			return retval;
+		}
+
+		/* Read mvpconf1 registers */
+		retval = mips32_pracc_cp0_read(ejtag_info, &mvpconf1, 0, 3);
+		if (retval != ERROR_OK) {
+			LOG_DEBUG("reading config3 register failed");
+			return retval;
+		}
+
+		/* check if FPU configured and Multi-thread core*/
+		if ((config1 & 0x00000001) == 1) {
+
+			/* Check if multi-thread core with single thread FPU */
+			if ((((config3 & 0x00000004) >> 2) == 1) && ((mvpconf1 & 0x00000001) == 1)) {
+
+				/* Read Status register, save it and modify to enable CP0 */
+				retval = mips32_pracc_cp0_read(ejtag_info, &status, 12, 0);
+				if (retval != ERROR_OK) {
+					LOG_DEBUG("reading status register failed");
+					return retval;
+				}
+
+				if ((retval = mips32_pracc_cp0_write(ejtag_info, (status | STATUS_CU1_MASK), 12, 0)) != ERROR_OK) {
+					LOG_DEBUG("writing status register failed");
+					return retval;
+				}
+
+				/* Verify CP1 Enabled */
+				retval = mips32_pracc_cp0_read(ejtag_info, &tmp_status, 12, 0);
+				if (retval != ERROR_OK) {
+					LOG_DEBUG("writing status register failed");
+					return retval;
+				}
+
+				if (((tmp_status & 0x20000000) >> 29)!= 1) {
+					LOG_USER ("1 Access to FPU not available - tmp_status: 0x%x, status: 0x%x", tmp_status, status);
+					return retval;
+				}
+
+				/* read core registers */
+				retval = mips32_pracc_write_fpu_regs(ejtag_info, (uint32_t *)(&mips32->core_regs[MIPS32_F0]));
+				if (retval != ERROR_OK)
+					LOG_INFO("mips32->read_core_reg failed");
+
+				/* restore previous setting */
+				if ((mips32_pracc_cp0_write(ejtag_info, status, 12, 0)) != ERROR_OK)
+					LOG_DEBUG("writing status register failed");
+			} else {
+				/* Read Status register, save it and modify to enable CP0 */
+				retval = mips32_pracc_cp0_read(ejtag_info, &status, 12, 0);
+				if (retval != ERROR_OK) {
+					LOG_DEBUG("reading status register failed");
+					return retval;
+				}
+
+				if ((retval = mips32_pracc_cp0_write(ejtag_info, (status | STATUS_CU1_MASK), 12, 0)) != ERROR_OK) {
+					LOG_DEBUG("writing status register failed");
+					return retval;
+				}
+
+
+				/* read core registers */
+				retval = mips32_pracc_write_fpu_regs(ejtag_info, (uint32_t *)(&mips32->core_regs[MIPS32_F0]));
+				if (retval != ERROR_OK)
+					LOG_INFO("mips32->read_core_reg failed");
+
+				/* restore previous setting */
+				if ((mips32_pracc_cp0_write(ejtag_info, status, 12, 0)) != ERROR_OK)
+					LOG_DEBUG("writing status register failed");
+			}
+		}
+	}
+
 	/* write core regs */
 	mips32_pracc_write_regs(ejtag_info, mips32->core_regs);
 
@@ -294,6 +571,9 @@ int mips32_arch_state(struct target *target)
 {
 	struct mips32_common *mips32 = target_to_mips32(target);
 
+	/* Read interesting Configuration Registers */
+	mips32_read_cpu_config_info (target);
+
 	LOG_USER("target halted in %s mode due to %s, pc: 0x%8.8" PRIx32 "",
 		mips_isa_strings[mips32->isa_mode],
 		debug_reason_name(target),
@@ -302,6 +582,90 @@ int mips32_arch_state(struct target *target)
 	return ERROR_OK;
 }
 
+int mips32_read_cpu_config_info (struct target *target)
+{
+	struct mips32_common *mips32 = target_to_mips32(target);
+	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
+
+	int retval;
+	uint32_t	prid; /* cp0 PRID - 15, 0 */
+	uint32_t config;
+	uint32_t config3;
+	uint32_t config1;
+	uint32_t config23;
+	uint32_t dcr;
+
+	/* Read PRID registers */
+	if ((retval = mips32_pracc_cp0_read(ejtag_info, &prid, 15, 0)) != ERROR_OK) {
+		LOG_DEBUG("READ of PRID Failed");
+		return retval;
+	}
+
+	/* Read Config register */
+	if ((retval = mips32_pracc_cp0_read(ejtag_info, &config, 16, 0))!= ERROR_OK) {
+		LOG_DEBUG("Read of Config reg Failed");
+		return retval;
+	}
+
+	/* Read Config1 register */
+	if ((retval = mips32_pracc_cp0_read(ejtag_info, &config1, 16, 1))!= ERROR_OK) {
+		LOG_DEBUG("Read of Config1 read Failed");
+		return retval;
+	}
+
+	/* Read debug(config 32, 0 register */
+	if ((retval = mips32_pracc_cp0_read(ejtag_info, &config23, 23, 0))!= ERROR_OK) {
+		LOG_DEBUG("Read of Config1 read Failed");
+		return retval;
+	} else
+		LOG_DEBUG("Debug register: 0x%8.8x", config23);
+
+	/* Read Config3 register */
+	retval = mips32_pracc_cp0_read(ejtag_info, &config3, 16, 3);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("reading config3 register failed");
+		return retval;
+	}
+
+	/* Retrive if Float Point CoProcessor Implemented */
+	mips32->fp_implemented = (config1 & CFG1_FP);
+
+	/* Retrieve DSP info */
+	mips32->dsp_implemented = ((config3 & CFG3_DSPP) >>  10);
+	mips32->dsp_rev = ((config3 & CFG3_DSP_REV) >>  11);
+
+	/* Retrieve ISA Mode */
+	mips32->mmips = ((config3 & CFG3_ISA_MODE) >>  14);
+
+	/* Determine if FDC and CDMM are implemented for this core */
+	if ((retval = target_read_u32(target, EJTAG_DCR, &dcr)) != ERROR_OK)
+		return retval;
+
+	if ((((dcr > 18) & 0x1) == 1) && ((config3 & 0x00000008) != 0)) {
+		retval = target_register_timer_callback(mips_common_handle_target_request, 3, 3, target);
+		if (retval != ERROR_OK)
+			return retval;
+
+		mips32->fdc = 1;
+		mips32->semihosting = ENABLE_SEMIHOSTING;
+	}
+	else {
+		mips32->fdc = 0;
+		mips32->semihosting = DISABLE_SEMIHOSTING;
+	}
+
+	uint32_t cputype = DetermineCpuTypeFromPrid(prid, config, config1);
+
+	/* determine whether uC or uP core */
+	if ((cputype == MIPS_M14KE) || (cputype == MIPS_M14KEf))
+		mips32->cp0_mask = MIPS_CP0_mAPTIV_uC;
+	else
+		if ((cputype == MIPS_M14KEc) || (cputype == MIPS_M14KEcf))
+			mips32->cp0_mask = MIPS_CP0_mAPTIV_uP;
+
+	return ERROR_OK;
+}
+
 static const struct reg_arch_type mips32_reg_type = {
 	.get = mips32_get_core_reg,
 	.set = mips32_set_core_reg,
@@ -329,38 +693,28 @@ struct reg_cache *mips32_build_reg_cache(struct target *target)
 	mips32->core_cache = cache;
 
 	for (i = 0; i < num_regs; i++) {
-		arch_info[i].num = mips32_regs[i].id;
+		arch_info[i].num = i; /* mips32_regs[i].id; */
 		arch_info[i].target = target;
 		arch_info[i].mips32_common = mips32;
 
 		reg_list[i].name = mips32_regs[i].name;
 		reg_list[i].size = 32;
 
-		if (mips32_regs[i].flag == MIPS32_GDB_DUMMY_FP_REG) {
-			reg_list[i].value = mips32_gdb_dummy_fp_value;
-			reg_list[i].valid = 1;
-			reg_list[i].arch_info = NULL;
-			register_init_dummy(&reg_list[i]);
-		} else {
-			reg_list[i].value = calloc(1, 4);
-			reg_list[i].valid = 0;
-			reg_list[i].type = &mips32_reg_type;
-			reg_list[i].arch_info = &arch_info[i];
-
-			reg_list[i].reg_data_type = calloc(1, sizeof(struct reg_data_type));
-			if (reg_list[i].reg_data_type)
-				reg_list[i].reg_data_type->type = mips32_regs[i].type;
-			else
-				LOG_ERROR("unable to allocate reg type list");
-		}
+		reg_list[i].value = calloc(1, 4);
+		reg_list[i].valid = 0;
+		reg_list[i].type = &mips32_reg_type;
+		reg_list[i].arch_info = &arch_info[i];
+		reg_list[i].reg_data_type = calloc(1, sizeof(struct reg_data_type));
+		if (reg_list[i].reg_data_type)
+			reg_list[i].reg_data_type->type = mips32_regs[i].type;
+		else
+			LOG_ERROR("unable to allocate reg type list");
 
 		reg_list[i].dirty = 0;
-
 		reg_list[i].group = mips32_regs[i].group;
 		reg_list[i].number = i;
 		reg_list[i].exist = true;
 		reg_list[i].caller_save = true;	/* gdb defaults to true */
-
 		feature = calloc(1, sizeof(struct reg_feature));
 		if (feature) {
 			feature->name = mips32_regs[i].feature;
@@ -372,13 +726,14 @@ struct reg_cache *mips32_build_reg_cache(struct target *target)
 	return cache;
 }
 
+
 int mips32_init_arch_info(struct target *target, struct mips32_common *mips32, struct jtag_tap *tap)
 {
 	target->arch_info = mips32;
 	mips32->common_magic = MIPS32_COMMON_MAGIC;
 	mips32->fast_data_area = NULL;
 
-	/* has breakpoint/watchpoint unit been scanned */
+	/* has breakpoint/watchpint unit been scanned */
 	mips32->bp_scanned = 0;
 	mips32->data_break_list = NULL;
 
@@ -386,8 +741,9 @@ int mips32_init_arch_info(struct target *target, struct mips32_common *mips32, s
 	mips32->read_core_reg = mips32_read_core_reg;
 	mips32->write_core_reg = mips32_write_core_reg;
 
-	mips32->ejtag_info.scan_delay = 2000000;	/* Initial default value */
+	mips32->ejtag_info.scan_delay = MIPS32_SCAN_DELAY_LEGACY_MODE;	/* Initial default value */
 	mips32->ejtag_info.mode = 0;			/* Initial default value */
+	mips32->fdc = -1;
 
 	return ERROR_OK;
 }
@@ -435,6 +791,7 @@ int mips32_run_algorithm(struct target *target, int num_mem_params,
 	enum mips32_isa_mode isa_mode = mips32->isa_mode;
 
 	uint32_t context[MIPS32_NUM_REGS];
+	unsigned int i;
 	int retval = ERROR_OK;
 
 	LOG_DEBUG("Running algorithm");
@@ -453,20 +810,20 @@ int mips32_run_algorithm(struct target *target, int num_mem_params,
 	}
 
 	/* refresh core register cache */
-	for (unsigned int i = 0; i < MIPS32_NUM_REGS; i++) {
+	for (i = 0; i < MIPS32_NUM_REGS; i++) {
 		if (!mips32->core_cache->reg_list[i].valid)
 			mips32->read_core_reg(target, i);
 		context[i] = buf_get_u32(mips32->core_cache->reg_list[i].value, 0, 32);
 	}
 
-	for (int i = 0; i < num_mem_params; i++) {
+	for (i = 0; i < (unsigned int)num_mem_params; i++) {
 		retval = target_write_buffer(target, mem_params[i].address,
 				mem_params[i].size, mem_params[i].value);
 		if (retval != ERROR_OK)
 			return retval;
 	}
 
-	for (int i = 0; i < num_reg_params; i++) {
+	for (i = 0; i < (unsigned int)num_reg_params; i++) {
 		struct reg *reg = register_get_by_name(mips32->core_cache, reg_params[i].reg_name, 0);
 
 		if (!reg) {
@@ -490,7 +847,7 @@ int mips32_run_algorithm(struct target *target, int num_mem_params,
 	if (retval != ERROR_OK)
 		return retval;
 
-	for (int i = 0; i < num_mem_params; i++) {
+	for (i = 0; i < (unsigned int)num_mem_params; i++) {
 		if (mem_params[i].direction != PARAM_OUT) {
 			retval = target_read_buffer(target, mem_params[i].address, mem_params[i].size,
 					mem_params[i].value);
@@ -499,7 +856,7 @@ int mips32_run_algorithm(struct target *target, int num_mem_params,
 		}
 	}
 
-	for (int i = 0; i < num_reg_params; i++) {
+	for (i = 0; i < (unsigned int)num_reg_params; i++) {
 		if (reg_params[i].direction != PARAM_OUT) {
 			struct reg *reg = register_get_by_name(mips32->core_cache, reg_params[i].reg_name, 0);
 			if (!reg) {
@@ -518,7 +875,7 @@ int mips32_run_algorithm(struct target *target, int num_mem_params,
 	}
 
 	/* restore everything we saved before */
-	for (unsigned int i = 0; i < MIPS32_NUM_REGS; i++) {
+	for (i = 0; i < MIPS32_NUM_REGS; i++) {
 		uint32_t regvalue;
 		regvalue = buf_get_u32(mips32->core_cache->reg_list[i].value, 0, 32);
 		if (regvalue != context[i]) {
@@ -539,7 +896,6 @@ int mips32_run_algorithm(struct target *target, int num_mem_params,
 int mips32_examine(struct target *target)
 {
 	struct mips32_common *mips32 = target_to_mips32(target);
-
 	if (!target_was_examined(target)) {
 		target_set_examined(target);
 
@@ -650,14 +1006,14 @@ int mips32_configure_break_unit(struct target *target)
 	}
 
 	/* check if target endianness settings matches debug control register */
-	if (((ejtag_info->debug_caps & EJTAG_DCR_ENM)
-			&& (target->endianness == TARGET_LITTLE_ENDIAN)) ||
-			(!(ejtag_info->debug_caps & EJTAG_DCR_ENM)
-			 && (target->endianness == TARGET_BIG_ENDIAN)))
+	if (((ejtag_info->debug_caps & EJTAG_DCR_ENM) && (target->endianness == TARGET_LITTLE_ENDIAN)) ||
+		(!(ejtag_info->debug_caps & EJTAG_DCR_ENM) && (target->endianness == TARGET_BIG_ENDIAN))) {
 		LOG_WARNING("DCR endianness settings does not match target settings");
+		LOG_WARNING("Config file does not match DCR endianness - DCR: 0x%8.8x", ejtag_info->debug_caps);
+	}
 
 	LOG_DEBUG("DCR 0x%" PRIx32 " numinst %i numdata %i", dcr, mips32->num_inst_bpoints,
-			mips32->num_data_bpoints);
+			  mips32->num_data_bpoints);
 
 	mips32->bp_scanned = 1;
 
@@ -756,7 +1112,7 @@ int mips32_checksum_memory(struct target *target, uint32_t address,
 	init_reg_param(&reg_params[1], "r5", 32, PARAM_OUT);
 	buf_set_u32(reg_params[1].value, 0, 32, count);
 
-	int timeout = 20000 * (1 + (count / (1024 * 1024)));
+	int timeout = 80000 * (1 + (count / (1024 * 1024)));
 
 	int retval = target_run_algorithm(target, 0, NULL, 2, reg_params,
 			crc_algorithm->address, crc_algorithm->address + (sizeof(mips_crc_code) - 4), timeout,
@@ -831,8 +1187,288 @@ int mips32_blank_check_memory(struct target *target,
 	return retval;
 }
 
+uint32_t DetermineCpuTypeFromPrid(uint32_t prid, uint32_t config, uint32_t config1) {
+
+	uint32_t cpuType;
+
+	/* Determine CPU type from PRID. */
+	if (((prid >> 16) & 0xff) == 16)
+		/* Altera */
+		return (uint32_t)MIPS_MP32;
+
+	if (((prid >> 16) & 0xff) == 2)
+		/* Broadcom */
+		return (uint32_t) MIPS_BCM;
+
+	if (((prid >> 16) & 0xff) == 3) {
+		/* AMD Alchemy processors */
+		switch ((prid >> 24) & 0xff)
+		{
+			case 0x00:
+				cpuType = MIPS_AU1000;
+				break;
+
+			case 0x01:
+				cpuType = MIPS_AU1500;
+				break;
+
+			case 0x02:
+				cpuType = MIPS_AU1100;
+				break;
+
+			case 0x03:
+				cpuType = MIPS_AU1550;
+				break;
+
+			case 0x04:
+				cpuType = MIPS_AU1200;
+				break;
+
+			default:
+				cpuType = CPUTYPE_UNKNOWN;
+				break;
+		} /* end of switch */
+
+		return cpuType;
+	}
+
+	switch ((prid >> 8) & 0xff)
+	{	/* MIPS Technologies cores */
+		case 0x80:
+			cpuType = MIPS_4Kc;
+			break;
+
+		case 0x81:
+			if (config1 & 1)
+				cpuType = MIPS_5Kf;	   /* fpu present */
+			else 
+				cpuType = MIPS_5Kc;
+			break;
+
+		case 0x82:
+			cpuType = MIPS_20Kc;
+			break;
+
+		case 0x83:
+			if ((config >> 20) & 1)
+				cpuType = MIPS_4Kp;
+			else
+				cpuType = MIPS_4Km;
+			break;
+					   
+		case 0x84:
+		case 0x90:
+			cpuType = MIPS_4KEc;
+			break;
+
+		case 0x85:
+		case 0x91:
+			if ((config >> 20) & 1) 
+				cpuType = MIPS_4KEp;
+			else
+				cpuType = MIPS_4KEm;
+			break;
+					   
+		case 0x86:
+			cpuType = MIPS_4KSc;
+			break;
+
+		case 0x87:
+			cpuType = MIPS_M4K;
+			break;
+
+		case 0x88:
+			cpuType = MIPS_25Kf;
+			break;
+
+		case 0x89:
+			if (config1 & 1)
+				cpuType = MIPS_5KEf;	   /* fpu present */
+			else
+				cpuType = MIPS_5KEc;
+			break;
+
+		case 0x92:
+			cpuType = MIPS_4KSd;
+			break;
+
+		case 0x93:
+			if (config1 & 1)
+				cpuType = MIPS_24Kf;	   /* fpu present */
+			else
+				cpuType = MIPS_24Kc;
+			break;
+
+		case 0x95:
+			if (config1 & 1)
+				cpuType = MIPS_34Kf;	   /* fpu present */
+			else {
+				/* In MT with a single-threaded FPU, Config1.FP may be 0   */
+				/* even though an FPU exists.  Scan all TC contexts and if */
+				/* any have Config1.FP, then set processor to 100Kf.	   */
+				/* skip it for now										   */
+				cpuType = MIPS_34Kc;
+			}
+			break;
+
+		case 0x96:
+			if (config1 & 1)
+				cpuType = MIPS_24KEf;	   /* fpu present */
+			else
+				cpuType = MIPS_24KEc;
+			break;
+
+		case 0x97:
+			if (config1 & 1)
+				cpuType = MIPS_74Kf;	   /* fpu present */
+			else 
+				cpuType = MIPS_74Kc;
+			break;
+
+		case 0x99:
+			if (config1 & 1) 
+				cpuType = MIPS_1004Kf;	   /* fpu present */
+			else {
+				/* In MT with a single-threaded FPU, Config1.FP may be 0   */
+				/* even though an FPU exists.  Scan all TC contexts and if */
+				/* any have Config1.FP, then set processor to 100Kf.	   */
+				/* skip it for now										   */
+				cpuType = MIPS_1004Kc;
+			}
+			break;
+
+		case 0x9A:
+			if (config1 & 1)
+				cpuType = MIPS_1074Kf;	   /* fpu present */
+			else {
+				/* In MT with a single-threaded FPU, Config1.FP may be 0   */
+				/* even though an FPU exists.  Scan all TC contexts and if */
+				/* any have Config1.FP, then set processor to 100Kf.	   */
+				/* skip it for now										   */
+				cpuType = MIPS_1074Kc;
+			}
+			break;
+
+		case 0x9B:
+			cpuType = MIPS_M14K;
+			break;
+
+		case 0x9C:
+			if (config1& 1)
+				cpuType = MIPS_M14Kf;	   /* fpu present */
+			else
+				cpuType = MIPS_M14Kc;
+			break;
+			   
+		case 0x9D:
+			if (config1 & 1)
+				cpuType = MIPS_M14KEf;
+			else
+				cpuType = MIPS_M14KE;
+			break;
+
+		case 0x9E:
+			if (config1 & 1)
+				cpuType = MIPS_M14KEcf;
+			else 
+				cpuType = MIPS_M14KEc;
+			break;
+
+		case 0xA0:
+			cpuType = MIPS_INTERAPTIV;
+			break;
+
+		case 0xA1:
+			cpuType = MIPS_INTERAPTIV_CM;
+			break;
+
+		case 0xA2:
+			cpuType = MIPS_PROAPTIV;
+			break;
+
+		case 0xA3:
+			cpuType = MIPS_PROAPTIV_CM;
+			break;
+
+		case 0xA6:
+			cpuType = MIPS_M5100;
+			break;
+
+		case 0xA7:
+			cpuType = MIPS_M5150;
+			break;
+
+		case 0xA8:
+			cpuType = MIPS_P5600;
+			break;
+
+		case 0xA9:
+			cpuType = MIPS_I5500;
+			break;
+
+		default:
+			cpuType = CPUTYPE_UNKNOWN;
+			break;
+	} /* end of switch */
+	
+	return (cpuType);
+}
+
+uint32_t DetermineGuestIdWidth(struct mips_ejtag *ejtag_info, uint32_t *width) {
+	// if GuestCtl1 is implemented {
+	//		save current GuestCtl1 value
+	//    write GuestCtl1, placing all-ones in the ID field
+	//    read GuestCtl1
+	//    in read value, count the consecutive number of 1 bits (starting from bit position 0)
+	//		restore GuestCtl1 value	
+	// } else width is 0
+
+	uint32_t err = ERROR_OK;
+	uint32_t err2 = ERROR_OK;
+	uint32_t count = 0;
+	bool guestCtl1Clobbered = false;
+	uint32_t guestCtl0 = 0;
+	uint32_t guestCtl1 = 0;
+	uint32_t tempReg = 0;
+
+	if ((err = mips32_pracc_cp0_read(ejtag_info, &guestCtl0, 12, 6)) != ERROR_OK) {
+		goto CLEANUP;
+	}
+	
+	if (((guestCtl0 >> 22) & 0x1) != 0) {
+		if ((err = mips32_pracc_cp0_read(ejtag_info, &guestCtl1, 10, 4)) != ERROR_OK) {
+			goto CLEANUP;
+		}
+
+		guestCtl1Clobbered = true;
+		tempReg = guestCtl1;
+		do {
+			tempReg = (((tempReg) & ~0xFF) | 0xFF);
+		} while (0);
+
+		if ((err = mips32_pracc_cp0_write(ejtag_info, tempReg, 10, 4)) != ERROR_OK) {
+			goto CLEANUP;
+		}
+		if ((err = mips32_pracc_cp0_read(ejtag_info, &tempReg, 10, 4)) != ERROR_OK) {
+			goto CLEANUP;
+		}
+		while (count < 8 && (tempReg & 0x1) != 0) {
+			count++;
+			tempReg >>= 1;
+		}
+	}
+
+CLEANUP:
+	if (guestCtl1Clobbered) {
+		// restore
+		err2 = mips32_pracc_cp0_write(ejtag_info, guestCtl1, 10, 4);
+	}
+	*width = count;
+	return (err != ERROR_OK ? err : err2);
+}
+
 static int mips32_verify_pointer(struct command_context *cmd_ctx,
-		struct mips32_common *mips32)
+				 struct mips32_common *mips32)
 {
 	if (mips32->common_magic != MIPS32_COMMON_MAGIC) {
 		command_print(cmd_ctx, "target is not an MIPS32");
@@ -841,17 +1477,59 @@ static int mips32_verify_pointer(struct command_context *cmd_ctx,
 	return ERROR_OK;
 }
 
-/**
- * MIPS32 targets expose command interface
- * to manipulate CP0 registers
- */
-COMMAND_HANDLER(mips32_handle_cp0_command)
+COMMAND_HANDLER(handle_mips_semihosting_command)
 {
-	int retval;
 	struct target *target = get_current_target(CMD_CTX);
 	struct mips32_common *mips32 = target_to_mips32(target);
 	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
 
+	if (target == NULL) {
+		LOG_ERROR("No target selected");
+		return ERROR_FAIL;
+	}
+
+	if (ejtag_info->ejtag_version < EJTAG_VERSION_51) {
+		LOG_ERROR("Ejtag interface does not support FDC");
+		return ERROR_FAIL;
+	}
+
+	if (mips32->fdc == 0) {
+		LOG_ERROR("FDC not supported by this core");
+		return ERROR_FAIL;
+	}
+
+	if (CMD_ARGC > 0) {
+		int semihosting;
+
+		COMMAND_PARSE_ENABLE(CMD_ARGV[0], semihosting);
+
+		if (!target_was_examined(target)) {
+			LOG_ERROR("Target not examined yet");
+			return ERROR_FAIL;
+		}
+
+		if (semihosting) {
+			mips32->semihosting = ENABLE_SEMIHOSTING;
+
+		} else {
+			mips32->semihosting = DISABLE_SEMIHOSTING;
+		}
+	}
+
+	command_print(CMD_CTX, "semihosting is %s",
+				  mips32->semihosting
+				  ? "enabled" : "disabled");
+
+	return ERROR_OK;
+}
+
+int mips32_cp0_command(struct command_invocation *cmd)
+{
+	int retval;
+
+	struct target *target = get_current_target(CMD_CTX);
+	struct mips32_common *mips32 = target_to_mips32(target);
+	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
 
 	retval = mips32_verify_pointer(CMD_CTX, mips32);
 	if (retval != ERROR_OK)
@@ -863,30 +1541,126 @@ COMMAND_HANDLER(mips32_handle_cp0_command)
 	}
 
 	/* two or more argument, access a single register/select (write if third argument is given) */
-	if (CMD_ARGC < 2)
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	else {
-		uint32_t cp0_reg, cp0_sel;
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], cp0_reg);
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], cp0_sel);
+	if (CMD_ARGC < 2) {
+		uint32_t value;
+
+		if (CMD_ARGC == 0) {
+			for (int i = 0; i < MIPS32NUMCP0REGS; i++) {
+				if (mips32_cp0_regs[i].core & mips32->cp0_mask) {
+					retval = mips32_pracc_cp0_read(ejtag_info, &value, mips32_cp0_regs[i].reg, mips32_cp0_regs[i].sel);
+					if (retval != ERROR_OK) {
+						command_print(CMD_CTX, "couldn't access reg %s", mips32_cp0_regs[i].name);
+						return ERROR_OK;
+					}
+				} else /* Register name not valid for this core */
+					continue;
+				
+				command_print(CMD_CTX, "%*s: 0x%8.8x", 14, mips32_cp0_regs[i].name, value);
+			}
+		} else {
+			for (int i = 0; i < MIPS32NUMCP0REGS; i++) {
+				/* find register name */
+				if (mips32_cp0_regs[i].core & mips32->cp0_mask) {
+					if (strcmp(mips32_cp0_regs[i].name, CMD_ARGV[0]) == 0) {
+						retval = mips32_pracc_cp0_read(ejtag_info, &value, mips32_cp0_regs[i].reg, mips32_cp0_regs[i].sel);
+						command_print(CMD_CTX, "0x%8.8x", value);
+						return ERROR_OK;
+					}
+				} else /* Register name not valid for this core */
+					continue;
+			}
 
+			LOG_ERROR("BUG: register '%s' not found", CMD_ARGV[0]);
+			return ERROR_COMMAND_SYNTAX_ERROR;
+		}
+	} else {
 		if (CMD_ARGC == 2) {
 			uint32_t value;
-
-			retval = mips32_cp0_read(ejtag_info, &value, cp0_reg, cp0_sel);
-			if (retval != ERROR_OK) {
-				command_print(CMD_CTX,
-						"couldn't access reg %" PRIi32,
-						cp0_reg);
-				return ERROR_OK;
+			int tmp = *CMD_ARGV[0];
+
+			if (isdigit(tmp) == false) {
+				for (int i = 0; i < MIPS32NUMCP0REGS; i++) {
+					/* find register name */
+					if (mips32_cp0_regs[i].core & mips32->cp0_mask) {
+						if (strcmp(mips32_cp0_regs[i].name, CMD_ARGV[0]) == 0) {
+							COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], value);
+
+							/* Check if user is writing to Status register */
+							if ((mips32_cp0_regs[i].reg == C0_STATUS) && (mips32_cp0_regs[i].sel == 0)) {
+								mips32->core_regs[CACHE_REG_STATUS] = value;
+								buf_set_u32(mips32->core_cache->reg_list[CACHE_REG_STATUS].value, 0, 32, value);
+								mips32->core_cache->reg_list[CACHE_REG_STATUS].dirty = 1;
+							} else /* Cause register ?? Update register cache with new value */
+								if ((mips32_cp0_regs[i].reg == C0_CAUSE) && (mips32_cp0_regs[i].sel == 0)) {
+									mips32->core_regs[CACHE_REG_CAUSE] = value;
+									buf_set_u32(mips32->core_cache->reg_list[CACHE_REG_CAUSE].value, 0, 32, value);
+									mips32->core_cache->reg_list[CACHE_REG_CAUSE].dirty = 1;
+								} else /* DEPC ? Update cached PC */
+									if ((mips32_cp0_regs[i].reg == C0_DEPC) && (mips32_cp0_regs[i].sel == 0)) {
+										mips32->core_regs[CACHE_REG_PC] = value;
+										buf_set_u32(mips32->core_cache->reg_list[CACHE_REG_PC].value, 0, 32, value);
+										mips32->core_cache->reg_list[CACHE_REG_PC].dirty = 1;
+									} else /* guestCtl1 ? Update register cache with new value */
+                                                                            if ((mips32_cp0_regs[i].reg == C0_GUESTCTL1) && (mips32_cp0_regs[i].sel == 4)) {
+                                                                                    mips32->core_regs[CACHE_REG_GUESTCTL1] = value;
+                                                                                    buf_set_u32(mips32->core_cache->reg_list[CACHE_REG_GUESTCTL1].value, 0, 32, value);
+                                                                                    mips32->core_cache->reg_list[CACHE_REG_GUESTCTL1].dirty = 1;
+                                                                            } 
+                                                                            
+
+							retval = mips32_pracc_cp0_write(ejtag_info, value, mips32_cp0_regs[i].reg, mips32_cp0_regs[i].sel);
+							return ERROR_OK;
+						}
+					} else /* Register name not valid for this core */
+						continue;
+				}
+
+				LOG_ERROR("BUG: register '%s' not found", CMD_ARGV[0]);
+				return ERROR_COMMAND_SYNTAX_ERROR;
+			} else {
+				uint32_t cp0_reg, cp0_sel;
+				COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], cp0_reg);
+				COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], cp0_sel);
+
+				retval = mips32_pracc_cp0_read(ejtag_info, &value, cp0_reg, cp0_sel);
+				if (retval != ERROR_OK) {
+					command_print(CMD_CTX,
+								  "couldn't access reg %" PRIi32,
+								  cp0_reg);
+					return ERROR_OK;
+				}
+
+				command_print(CMD_CTX, "cp0 reg %" PRIi32 ", select %" PRIi32 ": %8.8" PRIx32,
+							  cp0_reg, cp0_sel, value);
 			}
-			command_print(CMD_CTX, "cp0 reg %" PRIi32 ", select %" PRIi32 ": %8.8" PRIx32,
-					cp0_reg, cp0_sel, value);
-
 		} else if (CMD_ARGC == 3) {
+			uint32_t cp0_reg, cp0_sel;
 			uint32_t value;
+
+			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], cp0_reg);
+			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], cp0_sel);
 			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], value);
-			retval = mips32_cp0_write(ejtag_info, value, cp0_reg, cp0_sel);
+
+			/* Check if user is writing to Status register */
+			if ((cp0_reg == C0_STATUS) && (cp0_sel == 0)) {
+				mips32->core_regs[CACHE_REG_STATUS] = value;
+				mips32->core_cache->reg_list[CACHE_REG_STATUS].dirty = 1;
+			} else /* Cause register ?? Update register cache with new value */
+				if ((cp0_reg == C0_CAUSE) && (cp0_sel == 0)) {
+					mips32->core_regs[CACHE_REG_CAUSE] = value;
+					mips32->core_cache->reg_list[CACHE_REG_CAUSE].dirty = 1;
+				} else /* DEPC ? Update cached PC */
+					if ((cp0_reg == C0_DEPC) && (cp0_sel == 0)) {
+						mips32->core_regs[CACHE_REG_PC] = value;
+						mips32->core_cache->reg_list[CACHE_REG_PC].dirty = 1;
+					} else /* guestCtl1 ? Update it */
+                                                if ((cp0_reg == C0_GUESTCTL1) && (cp0_sel == 4)) {
+                                                        mips32->core_regs[CACHE_REG_GUESTCTL1] = value;
+                                                        mips32->core_cache->reg_list[CACHE_REG_GUESTCTL1].dirty = 1;
+                                                }  
+					
+
+			retval = mips32_pracc_cp0_write(ejtag_info, value, cp0_reg, cp0_sel);
 			if (retval != ERROR_OK) {
 				command_print(CMD_CTX,
 						"couldn't access cp0 reg %" PRIi32 ", select %" PRIi32,
@@ -894,26 +1668,30 @@ COMMAND_HANDLER(mips32_handle_cp0_command)
 				return ERROR_OK;
 			}
 			command_print(CMD_CTX, "cp0 reg %" PRIi32 ", select %" PRIi32 ": %8.8" PRIx32,
-					cp0_reg, cp0_sel, value);
+						  cp0_reg, cp0_sel, value);
 		}
 	}
 
 	return ERROR_OK;
 }
 
-COMMAND_HANDLER(mips32_handle_scan_delay_command)
+int mips32_scan_delay_command(struct command_invocation *cmd)
 {
 	struct target *target = get_current_target(CMD_CTX);
 	struct mips32_common *mips32 = target_to_mips32(target);
 	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
 
+	int retval = mips32_verify_pointer(CMD_CTX, mips32);
+	if (retval != ERROR_OK)
+		return retval;
+
 	if (CMD_ARGC == 1)
 		COMMAND_PARSE_NUMBER(uint, CMD_ARGV[0], ejtag_info->scan_delay);
 	else if (CMD_ARGC > 1)
-			return ERROR_COMMAND_SYNTAX_ERROR;
+		return ERROR_COMMAND_SYNTAX_ERROR;
 
 	command_print(CMD_CTX, "scan delay: %d nsec", ejtag_info->scan_delay);
-	if (ejtag_info->scan_delay >= 2000000) {
+	if (ejtag_info->scan_delay >= MIPS32_SCAN_DELAY_LEGACY_MODE) {
 		ejtag_info->mode = 0;
 		command_print(CMD_CTX, "running in legacy mode");
 	} else {
@@ -924,21 +1702,1082 @@ COMMAND_HANDLER(mips32_handle_scan_delay_command)
 	return ERROR_OK;
 }
 
+COMMAND_HANDLER(mips32_handle_cp0_command)
+{
+
+	/* Call common code */
+	return mips32_cp0_command(cmd);
+}
+
+COMMAND_HANDLER(mips32_handle_cpuinfo_command)
+{
+	int retval;
+	struct target *target = get_current_target(CMD_CTX);
+	struct mips32_common *mips32 = target_to_mips32(target);
+	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
+
+	CPU_INFO info;
+
+	char text[40]={0};
+	uint32_t ways, sets, bpl;
+
+	uint32_t	prid; /* cp0 PRID - 15, 0 */
+	uint32_t  config; /*	cp0 config - 16, 0 */
+	uint32_t config1; /*	cp0 config - 16, 1 */
+	uint32_t config2; /*	cp0 config - 16, 2 */
+	uint32_t config3; /*	cp0 config - 16, 3 */
+	uint32_t config4; /*	cp0 config - 16, 4 */
+	uint32_t config5; /*	cp0 config - 16, 5 */
+	uint32_t config7; /*	cp0 config - 16, 7 */
+
+	if (target->state != TARGET_HALTED) {
+		command_print(CMD_CTX, "target must be stopped for \"%s\" command", CMD_NAME);
+		return ERROR_OK;
+	}
+
+	/* No arg.s for now */
+	if (CMD_ARGC >= 1)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	/* Read PRID and config registers */
+	if ((retval = mips32_pracc_cp0_read(ejtag_info, &prid, 15, 0)) != ERROR_OK)
+		return retval;
+
+	/* Read Config, Config(1,2,3,5 and 7) registers */
+	if ((retval = mips32_pracc_cp0_read(ejtag_info, &config, 16, 0))!= ERROR_OK)
+		return retval;
+
+	if ((retval = mips32_pracc_cp0_read(ejtag_info, &config1, 16, 1))!= ERROR_OK)
+		return retval;
+
+	if ((retval = mips32_pracc_cp0_read(ejtag_info, &config2, 16, 2))!= ERROR_OK)
+		return retval;
+
+	if ((retval = mips32_pracc_cp0_read(ejtag_info, &config3, 16, 3))!= ERROR_OK)
+		return retval;
+
+	if ((retval = mips32_pracc_cp0_read(ejtag_info, &config4, 16, 4))!= ERROR_OK)
+		return retval;
+
+	if ((retval = mips32_pracc_cp0_read(ejtag_info, &config5, 16, 5))!= ERROR_OK)
+		return retval;
+
+	if ((retval = mips32_pracc_cp0_read(ejtag_info, &config7, 16, 7))!= ERROR_OK)
+		return retval;
+
+	/* Read and store dspase and mtase (and other) architecture extension presence bits */
+	info.dspase = (config3 & 0x00000400) ? 1 : 0;		/* dsp ase */
+	info.smase	= (config3 & 0x00000002) ? 1 : 0;		/* smartmips ase */
+	info.mtase  = (config3 & 0x00000004) ? 1 : 0;		/* multithreading */
+	info.m16ase = (config1 & 0x00000004) ? 1 : 0;		/* mips16(e) ase */
+	info.micromipsase = ((config3 >> 14) & 0x3) != 0;
+	info.mmutype = (config >> 7) & 7;					/* MMU Type Info */
+	info.vzase = (config3 & (1<<23)) ? 1 : 0;			/* VZ */
+	LOG_USER("VZ Module: %d", info.vzase);
+
+	/* Check if Virtualization supported */
+		/* TODO List */
+	if (info.vzase) {
+		/* Core supports Virtualization - now get Guest Info */
+		uint32_t width;
+		uint32_t guestCtl0;
+
+		if ((retval = mips32_pracc_cp0_read(ejtag_info, &guestCtl0, 12, 6)) != ERROR_OK)
+			return retval;
+
+		info.guestCtl1Present = (guestCtl0 >> 22) & 0x1;
+		
+		if ((retval = DetermineGuestIdWidth(ejtag_info, &width)) != ERROR_OK) {
+			return retval;
+		}
+
+		info.vzGuestIdWidth = width;
+
+                LOG_USER ("guest ID width: %d", info.vzGuestIdWidth );
+   }
+
+	/* MIPS SIMD Architecture (MSA) */
+	info.msa = (config3 & 0x10000000) ? 1 : 0;
+	info.cdmm = (config3 & 0x00000008) ? 1 : 0;
+	info.mvh = (config5 & (1<<5)) ? 1 : 0;		/* mvh */
+
+	/* MMU Supported */
+	info.tlbEntries = 0;
+
+	/* MMU types */
+	if (((info.mmutype == 1) || (info.mmutype == 4)) || ((info.mmutype == 3) && info.vzase)) {
+		info.tlbEntries = (((config1 >> 25) & 0x3f)+1);
+		info.mmutype = (config >> 7) & 7;
+		if (info.mmutype == 1)
+			/* VTLB only   !!!Does not account for Config4.ExtVTLB */
+			info.tlbEntries = (uint32_t )(((config1 >> 25) & 0x3f)+1);   
+		else
+			/* root RPU */
+			if ((info.mmutype == 3) && info.vzase)
+				info.tlbEntries = (uint32_t )(((config1 >> 25) & 0x3f)+1);
+			else {
+				/*  VTLB and FTLB */
+				if (info.mmutype == 4) {
+					ways = ftlb_ways[(config4 >> 4) & 0xf];
+					sets = ftlb_sets[config4 & 0xf];
+					info.tlbEntries = (uint32_t )((((config1 >> 25) & 0x3f)+1) + (ways*sets));
+				} else
+					info.tlbEntries = 0;
+			}
+	}
+
+	/* If release 2 of Arch. then get exception base info */
+	if (((config >> 10) & 7) != 0) {	/* release 2 */
+		uint32_t  ebase;
+		if ((retval = mips32_pracc_cp0_read(ejtag_info, &ebase, 15, 1))!= ERROR_OK)
+			return retval;
+
+		info.cpuid = (uint32_t)(ebase & 0x1ff);
+	} else {
+		info.cpuid = 0;
+	}
+
+	info.cpuType = DetermineCpuTypeFromPrid(prid, config, config1);
+
+	/* Determine Core info */
+	switch (info.cpuType) {
+	  case MIPS_4Kc:
+		  info.cpuCore = MIPS_4Kc;
+		  info.vendor = MIPS_CORE;
+		  info.instSet = MIPS32;
+		  strcpy(text, "4Kc");
+		  break;
+
+	  case MIPS_4Km:
+		  info.cpuCore = MIPS_4Km;
+		  info.vendor = MIPS_CORE;
+		  info.instSet = MIPS32;
+		  strcpy(text, "4Km");
+		  break;
+
+	  case MIPS_4Kp:
+		  info.cpuCore = MIPS_4Kp;
+		  info.vendor = MIPS_CORE;
+		  info.instSet = MIPS32;
+		  strcpy(text, "4Kp");
+		  break;
+
+	  case MIPS_4KEc:
+		  info.cpuCore = MIPS_4KEc;
+		  info.vendor = MIPS_CORE;
+		  info.instSet = MIPS32;
+		  strcpy(text, "4KEc");		  
+		  break;
+
+	  case MIPS_4KEm:
+		  info.cpuCore = MIPS_4KEm;
+		  info.vendor = MIPS_CORE;
+		  info.instSet = MIPS32;
+		  strcpy(text, "4KEm");
+		  break;
+	  case MIPS_4KEp:
+		  info.cpuCore = MIPS_4KEp;
+		  info.vendor = MIPS_CORE;
+		  info.instSet = MIPS32;
+		  strcpy(text, "4KEp");
+		  break;
+
+	  case MIPS_4KSc:
+		  info.cpuCore = MIPS_4KSc;
+		  info.vendor = MIPS_CORE;
+		  info.instSet = MIPS32;
+		  strcpy(text, "4KSc");
+		  break;
+
+	  case MIPS_4KSd:
+		  info.cpuCore = MIPS_4KSd;
+		  info.vendor = MIPS_CORE;
+		  info.instSet = MIPS32;
+		  strcpy(text, "4KSd");
+		  break;
+
+	  case MIPS_M4K:
+		  info.cpuCore = MIPS_M4K;
+		  info.vendor = MIPS_CORE;
+		  info.instSet = MIPS32;
+		  strcpy(text, "4K");
+		  break;
+
+	  case MIPS_24Kc:
+		  info.cpuCore = MIPS_24Kc;
+		  info.vendor = MIPS_CORE;
+		  info.instSet = MIPS32;
+		  strcpy(text, "24Kc");
+		  break;
+
+	  case MIPS_24Kf:
+		  info.cpuCore = MIPS_24Kf;
+		  info.vendor = MIPS_CORE;
+		  info.instSet = MIPS32;
+		  strcpy(text, "24Kf");
+		  break;
+
+	  case MIPS_24KEc:
+		  info.cpuCore = MIPS_24KEc;
+		  info.vendor = MIPS_CORE;
+		  info.instSet = MIPS32;
+		  strcpy(text, "24KEc");
+		  break;
+
+	  case MIPS_24KEf:
+		  info.cpuCore = MIPS_24KEf;
+		  info.vendor = MIPS_CORE;
+		  info.instSet = MIPS32;
+		  strcpy(text, "24KEf");
+		  break;
+
+	  case MIPS_34Kc:
+		  info.cpuCore = MIPS_34Kc;
+		  info.vendor = MIPS_CORE;
+		  info.instSet = MIPS32;
+		  strcpy(text, "34Kc");
+		  break;
+
+	  case MIPS_34Kf:
+		  info.cpuCore = MIPS_34Kf;
+		  info.vendor = MIPS_CORE;
+		  info.instSet = MIPS32;
+		  strcpy(text, "3Kf ");
+		  break;
+
+	  case MIPS_5Kc:
+		  info.cpuCore = MIPS_5Kc;
+		  info.vendor = MIPS_CORE;
+		  info.instSet = MIPS64;
+		  strcpy(text, "5Kc");
+		  break;
+
+	  case MIPS_5Kf:
+		  info.cpuCore = MIPS_5Kf;
+		  info.vendor = MIPS_CORE;
+		  info.instSet = MIPS64;
+		  strcpy(text, "5Kf");
+		  break;
+
+	  case MIPS_5KEc:
+		  info.cpuCore = MIPS_5KEc;
+		  info.vendor = MIPS_CORE;
+		  info.instSet = MIPS64;
+		  strcpy(text, "5KEc");
+		  break;
+
+	  case MIPS_5KEf:
+		  info.cpuCore = MIPS_5KEf;
+		  info.vendor = MIPS_CORE;
+		  info.instSet = MIPS64;
+		  strcpy(text, "5KEf");
+		  break;
+
+	  case MIPS_20Kc:
+		  info.cpuCore = MIPS_20Kc;
+		  info.vendor = MIPS_CORE;
+		  info.instSet = MIPS64;
+		  strcpy(text, "20Kc");
+		  break;
+
+	  case MIPS_25Kf:
+		  info.cpuCore = MIPS_25Kf;
+		  info.vendor = MIPS_CORE;
+		  info.instSet = MIPS64;
+		  strcpy(text, "25Kf");
+		  break;
+
+	  case MIPS_AU1000:
+		  info.cpuCore = MIPS_AU1000;
+		  info.vendor = ALCHEMY_CORE;
+		  info.instSet = MIPS32;
+		  strcpy(text, "AU1000");
+		  break;
+	  case MIPS_AU1100:
+		  info.cpuCore = MIPS_AU1100;
+		  info.vendor = ALCHEMY_CORE;
+		  info.instSet = MIPS32;
+		  strcpy(text, "AU1100");
+		  break;
+
+	  case MIPS_AU1200:
+		  info.cpuCore = MIPS_AU1200;
+		  info.vendor = ALCHEMY_CORE;
+		  info.instSet = MIPS32;
+		  strcpy(text, "AU1200");
+		  break;
+
+	  case MIPS_AU1500:
+		  info.cpuCore = MIPS_AU1500;
+		  info.vendor = ALCHEMY_CORE;
+		  info.instSet = MIPS32;
+		  strcpy(text, "AU1500");
+		  break;
+
+	  case MIPS_AU1550:
+		  info.cpuCore = MIPS_AU1550;
+		  info.vendor = ALCHEMY_CORE;
+		  info.instSet = MIPS32;
+		  strcpy(text, "AU1550");
+		  break;
+
+	  case MIPS_74Kc:
+		  info.cpuCore = MIPS_74Kc;
+		  info.vendor = MIPS_CORE;
+		  info.instSet = MIPS32;
+		  strcpy(text, "74Kc");
+		  break;
+
+	  case MIPS_74Kf:
+		  info.cpuCore = MIPS_74Kf;
+		  info.vendor = MIPS_CORE;
+		  info.instSet = MIPS32;
+		  strcpy(text, "74Kf");
+		  break;
+
+	  case MIPS_84Kc:
+		  info.cpuCore = MIPS_84Kc;
+		  info.vendor = MIPS_CORE;
+		  info.instSet = MIPS32;
+		  strcpy(text, "84Kc");
+		  break;
+
+	  case MIPS_84Kf:
+		  info.cpuCore = MIPS_84Kf;
+		  info.vendor = MIPS_CORE;
+		  info.instSet = MIPS32;
+		  strcpy(text, "84Kf");
+		  break;
+
+	  case MIPS_M14K:
+		  info.cpuCore = MIPS_M14K;
+		  info.vendor = MIPS_CORE;
+		  /*		  if ((err = GetM14KInstSet(handle, &info.instSet)) != SUCCESS) return err; */
+		  strcpy(text, "M14K");
+		  break;
+
+	  case MIPS_M14Kc:
+		  info.cpuCore = MIPS_M14Kc;
+		  info.vendor = MIPS_CORE;
+		  /*		  if ((err = GetM14KInstSet(handle, &info.instSet)) != SUCCESS) return err; */
+		  strcpy(text, "M14Kc");
+		  break;
+
+	  case MIPS_M14Kf:
+		  info.cpuCore = MIPS_M14Kf;
+		  info.vendor = MIPS_CORE;
+		  /*		  if ((err = GetM14KInstSet(handle, &info.instSet)) != SUCCESS) return err; */
+		  strcpy(text, "M14Kf");
+		  break;
+
+	  case MIPS_M14KE:
+		  info.cpuCore = MIPS_M14KE;
+		  info.vendor = MIPS_CORE;
+		  /*		  if ((err = GetM14KInstSet(handle, &info.instSet)) != SUCCESS) return err; */
+		  strcpy(text, "microAptiv_UC");
+		  break;
+
+	  case MIPS_M14KEf:
+		  info.cpuCore = MIPS_M14KEf;
+		  info.vendor = MIPS_CORE;
+		  /*		  if ((err = GetM14KInstSet(handle, &info.instSet)) != SUCCESS) return err; */
+		  strcpy(text, "microAptiv_UCF");
+		  break;
+
+	  case MIPS_M14KEc:
+		  info.cpuCore = MIPS_M14KEc;
+		  info.vendor = MIPS_CORE;
+		  /*		  if ((err = GetM14KInstSet(handle, &info.instSet)) != SUCCESS) return err; */
+		  strcpy(text, "microAptiv_UP");
+		  break;
+
+	  case MIPS_M14KEcf:
+		  info.cpuCore = MIPS_M14KEcf;
+		  info.vendor = MIPS_CORE;
+		  /*		  if ((err = GetM14KInstSet(handle, &info.instSet)) != SUCCESS) return err; */
+		  strcpy(text, "microAptiv_UPF");
+		  break;
+
+	  case MIPS_M5100:
+		  info.cpuCore = MIPS_M5100;
+		  info.vendor = MIPS_CORE;
+		  /*		  if ((err = GetM14KInstSet(handle, &info.instSet)) != SUCCESS) return err; */
+		  strcpy(text, "M5100");
+		  break;
+
+	  case MIPS_M5150:
+		  info.cpuCore = MIPS_M5150;
+		  info.vendor = MIPS_CORE;
+		  /*		  if ((err = GetM14KInstSet(handle, &info.instSet)) != SUCCESS) return err; */
+		  strcpy(text, "M5150");
+		  break;
+
+	  case MIPS_BCM:
+		  info.cpuCore = MIPS_BCM;
+		  info.vendor = BROADCOM_CORE;
+		  info.instSet = MIPS32;
+		  strcpy(text, "BCM");
+		  break;
+
+	  case MIPS_MP32:
+		  info.cpuCore = MIPS_MP32;
+		  info.vendor = ALTERA_CORE;
+		  info.instSet = MIPS32;
+		  strcpy(text, "MP32");
+		  break;
+
+	  case MIPS_1004Kc:
+		  info.cpuCore = MIPS_1004Kc;
+		  info.vendor = MIPS_CORE;
+		  info.instSet = MIPS32;
+		  strcpy(text, "1004Kc");
+		  break;
+
+	  case MIPS_1004Kf:
+		  info.cpuCore = MIPS_1004Kf;
+		  info.vendor = MIPS_CORE;
+		  info.instSet = MIPS32;
+		  strcpy(text, "1004Kf");
+		  break;
+
+	  case MIPS_1074Kc:
+		  info.cpuCore = MIPS_1074Kc;
+		  info.vendor = MIPS_CORE;
+		  info.instSet = MIPS32;
+		  strcpy(text, "1074Kc");
+		  break;
+
+	  case MIPS_1074Kf:
+		  info.cpuCore = MIPS_1074Kf;
+		  info.vendor = MIPS_CORE;
+		  info.instSet = MIPS32;
+		  strcpy(text, "1074Kf");
+		  break;
+
+	  case MIPS_PROAPTIV:
+		  info.cpuCore = MIPS_PROAPTIV;
+		  info.vendor = MIPS_CORE;
+		  info.instSet = MIPS32;
+		  strcpy(text, "PROAPTIV");
+		  break;
+
+	  case MIPS_PROAPTIV_CM:
+		  info.cpuCore = MIPS_PROAPTIV_CM;
+		  info.vendor = MIPS_CORE;
+		  info.instSet = MIPS32;
+		  strcpy(text, "PROAPTIV_CM");
+		  break;
+
+	  case MIPS_INTERAPTIV:
+		  info.cpuCore = MIPS_INTERAPTIV;
+		  info.vendor = MIPS_CORE;
+		  info.instSet = MIPS32;
+		  strcpy(text, "INTERAPTIV");
+		  break;
+
+	  case MIPS_INTERAPTIV_CM:
+		  info.cpuCore = MIPS_INTERAPTIV_CM;
+		  info.vendor = MIPS_CORE;
+		  info.instSet = MIPS32;
+		  strcpy(text, "INTERAPTIV_CM");
+		  break;
+
+	  case MIPS_P5600:
+		  info.cpuCore = MIPS_P5600;
+		  info.vendor = MIPS_CORE;
+		  info.instSet = MIPS32;
+		  strcpy(text, "P5600");
+		  break;
+
+	  case MIPS_I5500:
+		  info.cpuCore = MIPS_I5500;
+		  info.vendor = MIPS_CORE;
+		  info.instSet = MIPS32;
+		  strcpy(text, "I5500");
+		  break;
+	}
+
+	/* Determine Instr Cache Size */
+	ways = wayTable[(config1 >> CFG1_IASHIFT) & 7];
+	sets = setTableISDS[(config1 >> CFG1_ISSHIFT) & 7];
+	bpl  = bplTable[(config1 >> CFG1_ILSHIFT) & 7];
+	info.iCacheSize = ways*sets*bpl;
+
+	/* Determine data cache size */
+	ways = wayTable[(config1 >>  CFG1_DASHIFT) & 7];
+	sets = setTableISDS[(config1 >> CFG1_DSSHIFT) & 7];
+	bpl  = bplTable[(config1 >> CFG1_DLSHIFT) & 7];
+	info.dCacheSize = ways*sets*bpl;
+
+	/* Display Core Type info */
+	LOG_USER ("cpuCore: MIPS_%s", &text[0]);
+
+	LOG_USER ("cputype: %d", info.cpuType);
+
+	/* Display Core Vendor ID */
+	switch (info.vendor) {
+		case MIPS_CORE:
+			strcpy(text, "MIPS");
+			break;
+
+		case ALCHEMY_CORE:
+			strcpy(text, "Alchemy");
+			break;
+
+		case BROADCOM_CORE:
+			strcpy(text, "Broadcom");
+			break;
+
+		case ALTERA_CORE:
+			strcpy(text, "Altera");
+			break;
+
+		default:
+			sprintf (text, "Unknown CPU vendor code %u.", ((prid & 0x00ffff00) >> 16));
+			break;
+	}
+
+	/* Display Core Vendor */
+	LOG_USER (" vendor: %s", &text[0]);
+	LOG_USER ("  cpuid: %d", info.cpuid);
+	switch ((((config3 & 0x0000C000) >>  14))){
+		case 0:
+			strcpy (text, "MIPS32");
+			break;
+		case 1:
+			strcpy (text, "microMIPS");
+			break;
+		case 2:
+			strcpy (text, "MIPS32 (at reset) and microMIPS");
+			break;
+
+		case 3:
+			strcpy (text, "microMIPS (at reset) and MIPS32");
+			break;
+	}
+
+	/* Display Instruction Set Info */
+	LOG_USER ("instr Set: %s", &text[0]);
+	LOG_USER ("prid: %x", prid);
+	uint32_t rev = prid & 0x000000ff;
+	LOG_USER ("rtl: %x.%x.%x", (rev & 0xE0), (rev & 0x1C), (rev & 0x3));
+
+	LOG_USER ("Instr Cache: %d", info.iCacheSize);
+	LOG_USER (" Data Cache: %d", info.dCacheSize);
+
+	LOG_USER ("Max Number of Instr Breakpoints: %d", mips32->num_inst_bpoints);
+	LOG_USER ("Max Number of  Data Breakpoints: %d", mips32->num_data_bpoints);
+
+	if (info.mtase){
+		LOG_USER("mta: true");
+
+		/* Get VPE and Thread info */
+		uint32_t tcbind;
+		uint32_t mvpconf0;
+
+		/* Read tcbind register */
+		if ((retval = mips32_pracc_cp0_read(ejtag_info, &tcbind, 2, 2))!= ERROR_OK)
+			return retval;
+
+		LOG_USER("curvpe: %d", (tcbind & 0xf));
+		LOG_USER(" curtc: %d", ((tcbind >> 21) & 0xff));
+
+		/* Read mvpconf0 register */
+		if ((retval = mips32_pracc_cp0_read(ejtag_info, &mvpconf0, 0, 2))!= ERROR_OK)
+			return retval;
+
+		LOG_USER(" numtc: %d", (mvpconf0 & 0xf)+1);
+		LOG_USER("numvpe: %d", ((mvpconf0 >> 10) & 0xf)+1);
+	}
+	else {
+		LOG_USER("mta: false");
+	}
+
+	switch (info.mmutype) {
+		case MMU_TLB:
+			strcpy (text, "TLB");
+			break;
+		case MMU_BAT:
+			strcpy (text, "BAT");
+			break;
+		case MMU_FIXED:
+			strcpy (text, "FIXED");
+			break;
+		case MMU_DUAL_VTLB_FTLB:
+			strcpy (text, "DUAL VAR/FIXED");
+			break;
+		default:
+			strcpy (text, "Unknown");
+	}
+
+	LOG_USER("MMU Type: %s", &text[0]);
+	LOG_USER("TLB Entries: %d", info.tlbEntries);
+
+	/* does the core support a DSP */
+	if (info.dspase)
+		strcpy(text, "true");
+	else
+		strcpy(text, "false");
+
+	LOG_USER ("DSP Module: %s", &text[0]);
+
+#if 0	// SMARTMIPS not supported any more in contemporary cores
+	if (info.smase)
+		strcpy(text, "true");
+	else
+		strcpy(text, "false");
+
+	LOG_USER ("Smart Mips ASE: %s", &text[0]);
+#endif
+
+	/* MIPS SIMD Architecture (MSA) */
+	if (info.msa)
+		strcpy(text, "true");
+	else
+		strcpy(text, "false");
+
+	LOG_USER ("msa: %s", &text[0]);
+
+	/*Move To/From High COP0 (MTHC0/MFHC0) instructions are implemented. */
+	if (info.mvh)
+		strcpy(text, "true");
+	else
+		strcpy(text, "false");
+
+	LOG_USER ("mvh: %s", &text[0]);
+
+	/* Common Device Memory Map implemented? */
+	if (info.cdmm)
+		strcpy(text, "true");
+	else
+		strcpy(text, "false");
+        
+
+	LOG_USER ("cdmm: %s", &text[0]);
+        
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(mips32_handle_dsp_command)
+{
+	int retval;
+	struct target *target = get_current_target(CMD_CTX);
+	struct mips32_common *mips32 = target_to_mips32(target);
+	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
+
+	retval = mips32_verify_pointer(CMD_CTX, mips32);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (target->state != TARGET_HALTED) {
+		command_print(CMD_CTX, "target must be stopped for \"%s\" command", CMD_NAME);
+		return ERROR_OK;
+	}
+
+	/* Check for too many command arg.s */
+	if (CMD_ARGC >= 3) 
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	/* Check if DSP access supported or not */
+	if (mips32->dsp_implemented == DSP_NOT_IMP) {
+
+		/* Issue Error Message */
+		command_print(CMD_CTX, "DSP not implemented by this processor");
+		return ERROR_OK;
+	}
+
+//	if (mips32->dsp_rev == DSP_REV1) {
+//		command_print(CMD_CTX, "DSP Rev 1 not supported");
+//		return ERROR_OK;
+//	}
+
+	/* two or more argument, access a single register/select (write if third argument is given) */
+	if (CMD_ARGC < 2) {
+		uint32_t value;
+
+		if (CMD_ARGC == 0) {
+			value = 0;
+			for (int i = 0; i < MIPS32NUMDSPREGS; i++) {
+				retval = mips32_pracc_read_dsp_regs(ejtag_info, &value, i);
+				if (retval != ERROR_OK) {
+					command_print(CMD_CTX, "couldn't access reg %s", mips32_dsp_regs[i].name);
+					return retval;
+				}
+				command_print(CMD_CTX, "%*s: 0x%8.8x", 7, mips32_dsp_regs[i].name, value);
+			}
+		} else {
+			for (int i = 0; i < MIPS32NUMDSPREGS; i++) {
+				/* find register name */
+				if (strcmp(mips32_dsp_regs[i].name, CMD_ARGV[0]) == 0) {
+					retval = mips32_pracc_read_dsp_regs(ejtag_info, &value, i);
+					command_print(CMD_CTX, "0x%8.8x", value);
+					return retval;
+				}
+			}
+
+			LOG_ERROR("BUG: register '%s' not found", CMD_ARGV[0]);
+			return ERROR_COMMAND_SYNTAX_ERROR;
+		}
+	} else {
+		if (CMD_ARGC == 2) {
+			uint32_t value;
+			int tmp = *CMD_ARGV[0];
+
+			if (isdigit(tmp) == false) {
+				for (int i = 0; i < MIPS32NUMDSPREGS; i++) {
+					/* find register name */
+					if (strcmp(mips32_dsp_regs[i].name, CMD_ARGV[0]) == 0) {
+						COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], value);
+						retval = mips32_pracc_write_dsp_regs(ejtag_info, value, i);
+						return retval;
+					}
+				}
+
+				LOG_ERROR("BUG: register '%s' not found", CMD_ARGV[0]);
+				return ERROR_COMMAND_SYNTAX_ERROR;
+			}
+		}
+	}
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(mips32_handle_invalidate_cache_command)
+{
+	int retval = -1;
+	struct target *target = get_current_target(CMD_CTX);
+	struct mips32_common *mips32 = target_to_mips32(target);
+	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
+	int i = 0;
+
+	char *cache_msg[] = {"all", "instr", "data", "L23", NULL, NULL, NULL};
+
+	if (target->state != TARGET_HALTED) {
+		LOG_WARNING("target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	if ((CMD_ARGC >= 2) || (CMD_ARGC == 0)){
+		LOG_DEBUG("ERROR_COMMAND_SYNTAX_ERROR");
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	if (CMD_ARGC == 1) {
+		/* PARSE command options - all/inst/data/allnowb/datanowb */
+		for (i = 0; i < 5 ; i++) {
+			if (strcmp(CMD_ARGV[0], invalidate_cmd[i].arg) == 0) {
+				switch (invalidate_cmd[i].option) {
+					case ALL:
+						LOG_INFO("clearing %s cache", cache_msg[1]);
+						/* For this case - ignore any errors checks, just in case core has no instruction cache */
+						mips32_pracc_invalidate_cache(target, ejtag_info, invalidate_cmd[1].option);
+
+						/* TODO: Add L2 code */
+						/* LOG_INFO("clearing %s cache", cache_msg[3]); */
+						/* retval = mips32_pracc_invalidate_cache(target, ejtag_info, L2); */
+						/* if (retval != ERROR_OK) */
+						/*	return retval; */
+
+						LOG_INFO("clearing %s cache", cache_msg[2]);
+						/* For this case - ignore any errors checks, just in case core has no data cache */
+						mips32_pracc_invalidate_cache(target, ejtag_info, invalidate_cmd[2].option);
+
+						break;
+
+					case INST:
+						LOG_INFO("clearing %s cache", cache_msg[invalidate_cmd[i].option]);
+						retval = mips32_pracc_invalidate_cache(target, ejtag_info, invalidate_cmd[i].option);
+						if (retval != ERROR_OK)
+							return retval;
+
+						break;
+
+					case DATA:
+						LOG_INFO("clearing %s cache", cache_msg[invalidate_cmd[i].option]);
+						retval = mips32_pracc_invalidate_cache(target, ejtag_info, invalidate_cmd[i].option);
+						if (retval != ERROR_OK)
+							return retval;
+
+						break;
+
+					case ALLNOWB:
+						LOG_INFO("invalidating %s cache", cache_msg[invalidate_cmd[1].option]);
+						retval = mips32_pracc_invalidate_cache(target, ejtag_info, invalidate_cmd[1].option);
+						if (retval != ERROR_OK)
+							return retval;
+
+						/* TODO: Add L2 code */
+						/* LOG_INFO("invalidating %s cache no writeback", cache_msg[3]); */
+						/* retval = mips32_pracc_invalidate_cache(target, ejtag_info, L2); */
+						/* if (retval != ERROR_OK) */
+						/*	return retval; */
+
+						LOG_INFO("invalidating %s cache - no writeback", cache_msg[2]);
+						retval = mips32_pracc_invalidate_cache(target, ejtag_info, invalidate_cmd[2].option);
+						if (retval != ERROR_OK)
+							return retval;
+
+						break;
+
+					case DATANOWB:
+						LOG_INFO("invalidating %s cache - no writeback", cache_msg[2]);
+						retval = mips32_pracc_invalidate_cache(target, ejtag_info, invalidate_cmd[i].option);
+						if (retval != ERROR_OK)
+							return retval;
+						break;
+
+					default:
+						LOG_ERROR("Invalid command argument '%s' not found", CMD_ARGV[0]);
+						return ERROR_COMMAND_SYNTAX_ERROR;
+						break;
+				}
+
+				if (retval == ERROR_FAIL)
+					return ERROR_FAIL;
+				else
+					break;
+			} else {
+				if (i >= DATANOWB) {
+					LOG_ERROR("Invalid command argument '%s' not found", CMD_ARGV[0]);
+					return ERROR_COMMAND_SYNTAX_ERROR;
+				}
+			}
+
+		}
+	}
+//else {
+//		/* default is All */
+//		LOG_INFO("invalidating %s cache", cache_msg[1]);
+//		retval = mips32_pracc_invalidate_cache(target, ejtag_info, invalidate_cmd[1].option);
+//		if (retval != ERROR_OK)
+//			return retval;
+
+		/* TODO: Add L2 code */
+		/* LOG_INFO("invalidating %s cache", cache_msg[3]); */
+		/* retval = mips32_pracc_invalidate_cache(target, ejtag_info, L2); */
+		/* if (retval != ERROR_OK) */
+		/*	return retval; */
+
+//		LOG_INFO("invalidating %s cache", cache_msg[2]);
+//		retval = mips32_pracc_invalidate_cache(target, ejtag_info, invalidate_cmd[2].option);
+//		if (retval != ERROR_OK)
+//			return retval;
+//	}
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(mips32_handle_dump_tlb_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	struct mips32_common *mips32 = target_to_mips32(target);
+	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
+	int retval;
+
+	uint32_t data[4];
+
+	if (target->state != TARGET_HALTED) {
+		LOG_WARNING("target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	if (CMD_ARGC >= 2){
+		LOG_DEBUG("ERROR_COMMAND_SYNTAX_ERROR");
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	uint32_t config;	/* cp0 config - 16, 0 */
+	uint32_t config1;	/* cp0 config1 - 16, 1 */
+
+	/* Read Config register */
+	if ((retval = mips32_pracc_cp0_read(ejtag_info, &config, 16, 0))!= ERROR_OK)
+		return retval;
+
+	/* Read Config1 register */
+	if ((retval = mips32_pracc_cp0_read(ejtag_info, &config1, 16, 1))!= ERROR_OK)
+		return retval;
+	else {
+		uint32_t mmutype;
+		uint32_t tlbEntries;
+
+		mmutype = (config >> 7) & 7;
+		if (mmutype == 0) {
+			LOG_USER("mmutype: %d, No TLB configured", mmutype);
+			return ERROR_OK;
+		}
+
+		if ((CMD_ARGC == 0) || (CMD_ARGC == 1)){
+			uint32_t i = 0;
+
+			/* Get number of TLB entries */
+			if (CMD_ARGC == 1) {
+				COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], i);
+				tlbEntries = (((config1 >> 25) & 0x3f)+1);
+				if (i >= tlbEntries) {
+					LOG_USER ("Invalid TLB entry specified - Valid entry #'s are 0-%d", tlbEntries-1);
+					return ERROR_COMMAND_SYNTAX_ERROR;
+				}
+
+				tlbEntries = i+1;
+			} else
+				tlbEntries = (((config1 >> 25) & 0x3f)+1);
+
+			LOG_USER("index\t entrylo0\t entrylo1\t  entryhi\t pagemask");
+			for (; i < tlbEntries; i++) {
+				mips32_pracc_read_tlb_entry(ejtag_info, &data[0], i);
+				command_print(CMD_CTX, "  %d\t0x%8.8x\t0x%8.8x\t0x%8.8x\t0x%8.8x", i, data[0], data[1], data[2], data[3]);
+			}
+
+		}
+	}
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(mips32_handle_guest_id)
+{
+	uint32_t value;
+	struct target *target = get_current_target(CMD_CTX);
+	struct mips32_common *mips32 = target_to_mips32(target);
+	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
+        
+	mips32_pracc_cp0_read(ejtag_info, &value, 10, 4);
+	command_print(CMD_CTX, "guest id: %d", value & 0xff);
+	return ERROR_OK;
+}
+
+
+extern void ejtag_main_print_imp(struct mips_ejtag *ejtag_info);
+extern int mips_ejtag_get_impcode(struct mips_ejtag *ejtag_info, uint32_t *impcode);
+COMMAND_HANDLER(mips32_handle_ejtag_reg_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	struct mips32_common *mips32 = target_to_mips32(target);
+	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
+
+	uint32_t idcode;
+	uint32_t impcode;
+	uint32_t ejtag_ctrl;
+	uint32_t dcr;
+	int retval;
+
+	retval = mips_ejtag_get_idcode(ejtag_info, &idcode);
+	retval = mips_ejtag_get_impcode (ejtag_info, &impcode);
+	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL);
+	ejtag_ctrl = ejtag_info->ejtag_ctrl;
+	retval = mips_ejtag_drscan_32(ejtag_info, &ejtag_ctrl);
+
+	if (retval != ERROR_OK)
+		LOG_INFO("Encounter an Error");
+
+	LOG_USER ("       idcode: 0x%8.8x", idcode);
+	LOG_USER ("      impcode: 0x%8.8x", impcode);
+	LOG_USER ("ejtag control: 0x%8.8x", ejtag_ctrl);
+
+	ejtag_main_print_imp(ejtag_info);
+
+	/* Display current DCR */
+	retval = target_read_u32(target, EJTAG_DCR, &dcr);
+	LOG_USER("          DCR: 0x%8.8x", dcr);
+
+	if (((dcr > 22) & 0x1) == 1)
+		LOG_USER("DAS supported");
+
+	if (((dcr > 18) & 0x1) == 1)
+		LOG_USER("FDC supported");
+
+	if (((dcr > 17) & 0x1) == 1)
+		LOG_USER("DataBrk supported");
+
+	if (((dcr > 16) & 0x1) == 1)
+		LOG_USER("InstBrk supported");
+
+	if (((dcr > 15) & 0x1) == 1)
+		LOG_USER("Inverted Data value supported");
+
+	if (((dcr > 14) & 0x1) == 1)
+		LOG_USER("Data value stored supported");
+
+	if (((dcr > 10) & 0x1) == 1)
+		LOG_USER("Complex Breakpoints supported");
+
+	if (((dcr > 9) & 0x1) == 1)
+		LOG_USER("PC Sampling supported");
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(mips32_handle_scan_delay_command)
+{
+	return mips32_scan_delay_command(cmd);
+}
+
 static const struct command_registration mips32_exec_command_handlers[] = {
 	{
 		.name = "cp0",
 		.handler = mips32_handle_cp0_command,
 		.mode = COMMAND_EXEC,
-		.usage = "regnum select [value]",
-		.help = "display/modify cp0 register",
+		.help = "display/modify cp0 register(s)",
+		.usage = "[[reg_name|regnum select] [value]]",
 	},
-		{
+	{
+		.name = "cpuinfo",
+		.handler = mips32_handle_cpuinfo_command,
+		.mode = COMMAND_EXEC,
+		.help = "cpuinfo displays information for the current CPU core.",
+		.usage = "cpuinfo",
+	},
+	{
+		.name = "dsp",
+		.handler = mips32_handle_dsp_command,
+		.mode = COMMAND_EXEC,
+		.help = "display or set DSP register; "
+		"with no arguments, displays all registers and their values",
+		.usage = "[register_name] [value]]",
+	},
+	{
+		.name = "invalidate",
+		.handler = mips32_handle_invalidate_cache_command,
+		.mode = COMMAND_EXEC,
+		.help = "Invalidate either or both the instruction and data caches.",
+		.usage = "all|inst|data|allnowb|datanowb",
+	},
+	{
 		.name = "scan_delay",
 		.handler = mips32_handle_scan_delay_command,
 		.mode = COMMAND_ANY,
 		.help = "display/set scan delay in nano seconds",
 		.usage = "[value]",
 	},
+	{
+		.name = "dump_tlb",
+		.handler = mips32_handle_dump_tlb_command,
+		.mode = COMMAND_ANY,
+		.help = "dump_tlb",
+		.usage = "[entry]",
+	},
+	{
+		"semihosting",
+		.handler = handle_mips_semihosting_command,
+		.mode = COMMAND_EXEC,
+		.usage = "['enable'|'disable']",
+		.help = "activate support for semihosting operations",
+	},
+	{
+		.name = "ejtag_reg",
+		.handler = mips32_handle_ejtag_reg_command,
+		.mode = COMMAND_ANY,
+		.help = "read ejtag registers",
+		.usage = "",
+	},
+	{
+		.name = "guest_id",
+		.handler = mips32_handle_guest_id,
+		.mode = COMMAND_ANY,
+		.help = "Display the current guest ID.",
+		.usage = "guest_id",
+	},
+        
 	COMMAND_REGISTRATION_DONE
 };
 
diff --git b/src/target/mips32.h a/src/target/mips32.h
index 56f4fb4e1..8f9491780 100644
--- b/src/target/mips32.h
+++ a/src/target/mips32.h
@@ -63,18 +63,187 @@
 #define MIPS32_ARCH_REL1 0x0
 #define MIPS32_ARCH_REL2 0x1
 
+#define MIPS32_SCAN_DELAY_LEGACY_MODE 2000000
+
 /* offsets into mips32 core register cache */
 enum {
+	MIPS32_R2 = 2,
+	MIPS32_R4 = 4,
+	MIPS32_R5 = 5,
+	MIPS32_R25 = 25,
 	MIPS32_PC = 37,
-	MIPS32_FIR = 71,
+	MIPS32_F0 = 39,
+	MIPS32_FCSR = 71,
+	MIPS32_FIR = 72,
 	MIPS32NUMCOREREGS
 };
 
+#define CACHE_REG_STATUS 32
+#define CACHE_REG_CAUSE 36
+#define CACHE_REG_PC 37
+#define CACHE_REG_GUESTCTL1 38
+
+#define MIPS32NUMDSPREGS 9
+
+
+
+/* Bit Mask indicating CP0 register supported by this core */
+#define	MIPS_CP0_MK4		0x0001
+#define	MIPS_CP0_mAPTIV_uC	0x0002
+#define	MIPS_CP0_mAPTIV_uP	0x0004
+#define MIPS_CP0_iAPTIV		0x0008
+
+static const struct {
+	unsigned reg;
+	unsigned sel;
+	const char *name;
+	const unsigned core;
+} mips32_cp0_regs[] = {
+	{0, 0, "index", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uP},
+	{0, 1, "mvpcontrol", MIPS_CP0_iAPTIV},
+	{0, 2, "mvpconf0", MIPS_CP0_iAPTIV},
+	{0, 3, "mvpconf1", MIPS_CP0_iAPTIV},
+	{1, 0, "random", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uP},
+	{1, 1, "vpecontrol", MIPS_CP0_iAPTIV},
+	{1, 2, "vpeconf0", MIPS_CP0_iAPTIV},
+	{1, 3, "vpeconf1", MIPS_CP0_iAPTIV},
+	{1, 4, "yqmask", MIPS_CP0_iAPTIV},
+	{1, 5, "vpeschedule", MIPS_CP0_iAPTIV},
+	{1, 6, "vpeschefback", MIPS_CP0_iAPTIV},
+	{1, 7, "vpeopt", MIPS_CP0_iAPTIV},
+	{2, 0, "entrylo0", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uP},
+	{2, 1, "tcstatus", MIPS_CP0_iAPTIV},
+	{2, 2, "tcbind", MIPS_CP0_iAPTIV},
+	{2, 3, "tcrestart", MIPS_CP0_iAPTIV},
+	{2, 4, "tchalt", MIPS_CP0_iAPTIV},
+	{2, 5, "tccontext", MIPS_CP0_iAPTIV},
+	{2, 6, "tcschedule", MIPS_CP0_iAPTIV},
+	{2, 7, "tcschefback", MIPS_CP0_iAPTIV},
+	{3, 0, "entrylo1",MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uP},
+	{3, 7, "tcopt", MIPS_CP0_iAPTIV},
+	{4, 0, "context", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uP},
+	{4, 2, "userlocal", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP | MIPS_CP0_MK4},
+	{5, 0, "pagemask", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uP},
+	{5, 1, "pagegrain", MIPS_CP0_mAPTIV_uP},
+	{5, 2, "segctl0", MIPS_CP0_iAPTIV},
+	{5, 3, "segctl1", MIPS_CP0_iAPTIV},
+	{5, 4, "segctl2", MIPS_CP0_iAPTIV},
+	{6, 0, "wired", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uP},
+	{6, 1, "srsconf0", MIPS_CP0_iAPTIV},
+	{6, 2, "srsconf1", MIPS_CP0_iAPTIV},
+	{6, 3, "srsconf2", MIPS_CP0_iAPTIV},
+	{6, 4, "srsconf3", MIPS_CP0_iAPTIV},
+	{6, 5, "srsconf4", MIPS_CP0_iAPTIV},
+	{7, 0, "hwrena", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP | MIPS_CP0_MK4},
+	{8, 0, "badvaddr", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP | MIPS_CP0_MK4},
+	{8, 1, "badinstr", MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP},
+	{8, 2, "badinstrp", MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP},
+	{9, 0, "count", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP | MIPS_CP0_MK4},
+	{10, 0, "entryhi", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uP},
+	{10, 4, "guestctl1", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uP | MIPS_CP0_mAPTIV_uC | MIPS_CP0_MK4},
+	{10, 5, "guestctl2", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uP | MIPS_CP0_mAPTIV_uC | MIPS_CP0_MK4},
+	{10, 6, "guestctl3", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uP | MIPS_CP0_mAPTIV_uC | MIPS_CP0_MK4},
+	{11, 0, "compare", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP | MIPS_CP0_MK4},
+	{11, 4, "guestctl0ext", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uP | MIPS_CP0_mAPTIV_uC | MIPS_CP0_MK4},
+	{12, 0, "status", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP | MIPS_CP0_MK4},
+	{12, 1, "intctl", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP | MIPS_CP0_MK4},
+	{12, 2, "srsctl", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP | MIPS_CP0_MK4},
+	{12, 3, "srsmap", MIPS_CP0_iAPTIV},
+	{12, 3, "srsmap1", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP},
+	{12, 4, "view_ipl", MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP | MIPS_CP0_MK4},
+	{12, 5, "srsmap2", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP},
+	{12, 6, "guestctl0", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uP | MIPS_CP0_mAPTIV_uC | MIPS_CP0_MK4},
+	{12, 7, "gtoffset", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uP | MIPS_CP0_mAPTIV_uC | MIPS_CP0_MK4},
+	{13, 0, "cause", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP | MIPS_CP0_MK4},
+	{13, 5, "nestedexc", MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP| MIPS_CP0_MK4},
+	{14, 0, "epc", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP | MIPS_CP0_MK4},
+	{14, 2, "nestedepc", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP | MIPS_CP0_MK4},
+	{15, 0, "prid", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP | MIPS_CP0_MK4},
+	{15, 1, "ebase", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP | MIPS_CP0_MK4},
+	{15, 2, "cdmmbase", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP | MIPS_CP0_MK4},
+	{15, 3, "cmgcrbase", MIPS_CP0_iAPTIV},
+	{16, 0, "config", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP | MIPS_CP0_MK4},
+	{16, 1, "config1", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP | MIPS_CP0_MK4},
+	{16, 2, "config2", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP | MIPS_CP0_MK4},
+	{16, 3, "config3", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP | MIPS_CP0_MK4},
+	{16, 4, "config4", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP | MIPS_CP0_MK4},
+	{16, 5, "config5", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP | MIPS_CP0_MK4},
+	{16, 7, "config7", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP | MIPS_CP0_MK4},
+	{17, 0, "lladdr", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uP | MIPS_CP0_MK4},
+	{18, 0, "watchlo0", MIPS_CP0_iAPTIV},
+	{18, 1, "watchlo1", MIPS_CP0_iAPTIV},
+	{18, 2, "watchlo2", MIPS_CP0_iAPTIV},
+	{18, 3, "watchlo3", MIPS_CP0_iAPTIV},
+	{19, 0, "watchhi0", MIPS_CP0_iAPTIV},
+	{19, 1, "watchhi1", MIPS_CP0_iAPTIV},
+	{19, 2, "watchhi2", MIPS_CP0_iAPTIV},
+	{19, 3, "watchhi3", MIPS_CP0_iAPTIV},
+	{23, 0, "debug", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP | MIPS_CP0_MK4},
+	{23, 1, "tracecontrol", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP | MIPS_CP0_MK4},
+	{23, 2, "tracecontrol2", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP | MIPS_CP0_MK4},
+	{23, 3, "usertracedata1", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP | MIPS_CP0_MK4},
+	{23, 4, "tracebpc", MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP | MIPS_CP0_MK4},
+	{23, 4, "traceibpc", MIPS_CP0_iAPTIV},
+	{23, 5, "tracedbpc", MIPS_CP0_iAPTIV},
+	{24, 0, "depc", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP | MIPS_CP0_MK4},
+	{24, 2, "tracecontrol3", MIPS_CP0_iAPTIV},
+	{24, 3, "usertracedata2", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP | MIPS_CP0_MK4},
+	{25, 0, "perfctl0", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP | MIPS_CP0_MK4},
+	{25, 1, "perfcnt0", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP | MIPS_CP0_MK4},
+	{25, 2, "perfctl1", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP | MIPS_CP0_MK4},
+	{25, 3, "perfcnt1", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP | MIPS_CP0_MK4},
+	{26, 0, "errctl", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP | MIPS_CP0_MK4},
+	{27, 0, "cacheerr", MIPS_CP0_iAPTIV},
+	{28, 0, "itaglo", MIPS_CP0_iAPTIV},
+	{28, 0, "taglo", MIPS_CP0_iAPTIV},
+	{28, 1, "idatalo", MIPS_CP0_iAPTIV},
+	{28, 1, "datalo", MIPS_CP0_iAPTIV},
+	{28, 2, "dtaglo", MIPS_CP0_iAPTIV},
+	{28, 3, "ddatalo", MIPS_CP0_iAPTIV},
+	{28, 4, "l23taglo", MIPS_CP0_iAPTIV},
+	{28, 5, "l23datalo", MIPS_CP0_iAPTIV},
+	{29, 1, "idatahi", MIPS_CP0_iAPTIV},
+	{29, 2, "dtaghi", MIPS_CP0_iAPTIV},
+	{29, 5, "l23datahi", MIPS_CP0_iAPTIV},
+	{30, 0, "errorepc", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP | MIPS_CP0_MK4},
+	{31, 0, "desave", MIPS_CP0_iAPTIV | MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP | MIPS_CP0_MK4},
+	{31, 2, "kscratch1", MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP},
+	{31, 3, "kscratch2", MIPS_CP0_mAPTIV_uC | MIPS_CP0_mAPTIV_uP},
+};
+
+#define MIPS32NUMCP0REGS ((int)ARRAY_SIZE(mips32_cp0_regs))
+
 enum mips32_isa_mode {
 	MIPS32_ISA_MIPS32 = 0,
 	MIPS32_ISA_MIPS16E = 1,
 };
 
+enum micro_mips_enabled {
+	MIPS32_ONLY = 0,
+	MICRO_MIPS_ONLY = 1,
+	MICRO_MIPS32_16_ONRESET_MIPS32 = 2,
+	MICRO_MIPS32_16_ONRESET_MIPS16 = 3,
+};
+
+enum fp {
+	FP_NOT_IMP = 0,
+	FP_IMP = 1,
+};
+
+enum dsp {
+	DSP_NOT_IMP = 0,
+	DSP_IMP = 1,
+};
+
+enum dsp_rev {
+	DSP_REV1 = 0,
+	DSP_REV2 = 1,
+};
+
+enum semihosting {
+	DISABLE_SEMIHOSTING = false,
+	ENABLE_SEMIHOSTING = true,
+};
 struct mips32_comparator {
 	int used;
 	uint32_t bp_value;
@@ -88,6 +257,16 @@ struct mips32_common {
 	struct mips_ejtag ejtag_info;
 	uint32_t core_regs[MIPS32NUMCOREREGS];
 	enum mips32_isa_mode isa_mode;
+	enum micro_mips_enabled mmips;
+	enum dsp dsp_implemented;
+	enum dsp_rev dsp_rev;
+	enum fp fp_implemented;
+	int fdc;
+	enum semihosting semihosting;
+
+	/* Mask used to determine is CP0 name valid for core */
+	/* note hard coded for M4K to support backward compatibility */
+	uint32_t cp0_mask;
 
 	/* working area for fastdata access */
 	struct working_area *fast_data_area;
@@ -122,7 +301,291 @@ struct mips32_algorithm {
 	enum mips32_isa_mode isa_mode;
 };
 
-#define MIPS32_OP_ADDIU 0x21
+#define zero	0
+
+#define AT	1
+
+#define v0	2
+#define v1	3
+
+#define a0	4
+#define a1	5
+#define a2	6
+#define	a3	7
+#define t0	8
+#define t1	9
+#define t2	10
+#define t3	11
+#define t4	12
+#define t5	13
+#define t6	14
+#define t7	15
+#define ta0	12	/* alias for $t4 */
+#define ta1	13	/* alias for $t5 */
+#define ta2	14	/* alias for $t6 */
+#define ta3	15	/* alias for $t7 */
+
+#define s0	16
+#define s1	17
+#define s2	18
+#define s3	19
+#define s4	20
+#define s5	21
+#define s6	22
+#define s7	23
+#define s8	30		/* == fp */
+
+#define t8	24
+#define t9	25
+#define k0	26
+#define k1	27
+
+#define gp	28
+
+#define sp	29
+#define fp	30
+#define ra	31
+
+#define ALL 0
+#define INST 1
+#define DATA 2
+#define ALLNOWB 3
+#define DATANOWB 4
+#define L2 5
+
+/*
+ * MIPS32 Config0 Register	(CP0 Register 16, Select 0)
+ */
+#define CFG0_M			0x80000000		/* Config1 implemented */
+#define CFG0_BE			0x00008000		/* Big Endian */
+#define CFG0_ATMASK		0x00006000		/* Architecture type: */
+#define CFG0_AT_M32		(0<<13)			/* MIPS32 */
+#define CFG0_AT_M64_A32 (1<<13)			/* MIPS64, 32-bit addresses */
+#define CFG0_AT_M64_A64 (2<<13)			/* MIPS64, 64-bit addresses */
+#define CFG0_AT_RES		(3<<13)
+#define CFG0_ARMASK		0x00001c00
+#define CFG0_ARSHIFT	10
+#define CFG0_MTMASK		0x00000380
+#define CFG0_MT_NONE	(0<<7)
+#define CFG0_MT_TLB		(1<<7)
+#define CFG0_MT_BAT		(2<<7)
+#define CFG0_MT_NONSTD	(3<<7)
+#define CFG0_VI			0x00000008		/* Icache is virtual */
+#define CFG0_K0MASK		0x00000007		/* KSEG0 coherency algorithm */
+
+/*
+ * MIPS32 Config1 Register (CP0 Register 16, Select 1)
+ */
+#define CFG1_M			0x80000000		/* Config2 implemented */
+#define CFG1_MMUSMASK	0x7e000000		/* mmu size - 1 */
+#define CFG1_MMUSSHIFT	25
+#define CFG1_ISMASK		0x01c00000		/* icache lines 64<<n */
+#define CFG1_ISSHIFT	22
+#define CFG1_ILMASK		0x00380000		/* icache line size 2<<n */
+#define CFG1_ILSHIFT	19
+#define CFG1_IAMASK		0x00070000		/* icache ways - 1 */
+#define CFG1_IASHIFT	16
+#define CFG1_DSMASK		0x0000e000		/* dcache lines 64<<n */
+#define CFG1_DSSHIFT	13
+#define CFG1_DLMASK		0x00001c00		/* dcache line size 2<<n */
+#define CFG1_DLSHIFT	10
+
+/*
+ * MIPS32 Config1 Register (CP0 Register 16, Select 1)
+ */
+#define CFG1_M			0x80000000		/* Config2 implemented */
+#define CFG1_MMUSMASK	0x7e000000		/* mmu size - 1 */
+#define CFG1_MMUSSHIFT	25
+#define CFG1_ISMASK		0x01c00000		/* icache lines 64<<n */
+#define CFG1_ISSHIFT	22
+#define CFG1_ILMASK		0x00380000		/* icache line size 2<<n */
+#define CFG1_ILSHIFT	19
+#define CFG1_IAMASK		0x00070000		/* icache ways - 1 */
+#define CFG1_IASHIFT	16
+#define CFG1_DSMASK		0x0000e000		/* dcache lines 64<<n */
+#define CFG1_DSSHIFT	13
+#define CFG1_DLMASK		0x00001c00		/* dcache line size 2<<n */
+#define CFG1_DLSHIFT	10
+#define CFG1_DAMASK		0x00000380		/* dcache ways - 1 */
+#define CFG1_DASHIFT	7
+#define CFG1_C2			0x00000040		/* Coprocessor 2 present */
+#define CFG1_MD			0x00000020		/* MDMX implemented */
+#define CFG1_PC			0x00000010		/* performance counters implemented */
+#define CFG1_WR			0x00000008		/* watch registers implemented */
+#define CFG1_CA			0x00000004		/* compression (mips16) implemented */
+#define CFG1_EP			0x00000002		/* ejtag implemented */
+#define CFG1_FP			0x00000001		/* fpu implemented */
+
+/*
+ * MIPS32r2 Config2 Register (CP0 Register 16, Select 2)
+ */
+#define CFG2_M			0x80000000		/* Config3 implemented */
+#define CFG2_TUMASK		0x70000000		/* tertiary cache control */
+#define CFG2_TUSHIFT	28
+#define CFG2_TSMASK		0x0f000000		/* tcache sets per wway 64<<n */
+#define CFG2_TSSHIFT	24
+#define CFG2_TLMASK		0x00f00000		/* tcache line size 2<<n */
+#define CFG2_TLSHIFT	20
+#define CFG2_TAMASK		0x000f0000		/* tcache ways - 1 */
+#define CFG2_TASHIFT	16
+#define CFG2_SUMASK		0x0000f000		/* secondary cache control */
+#define CFG2_SUSHIFT	12
+#define CFG2_SSMASK		0x00000f00		/* scache sets per wway 64<<n */
+#define CFG2_SSSHIFT	8
+#define CFG2_SLMASK		0x000000f0		/* scache line size 2<<n */
+#define CFG2_SLSHIFT	4
+#define CFG2_SAMASK		0x0000000f		/* scache ways - 1 */
+#define CFG2_SASHIFT	0
+
+/*
+ * MIPS32r2 Config3 Register (CP0 Register 16, Select 3)
+ */
+#define CFG3_M			0x80000000		/* Config4 implemented */
+#define CFG3_ISAONEXC	0x00010000		/* ISA mode on exception entry */
+#define CFG3_ISA_MODE	0x0000C000		/* ISA mode */
+#define CFG3_DSP_REV	0x00000800		/* DSP Rev */
+#define CFG3_DSPP		0x00000400		/* DSP ASE present */
+#define CFG3_LPA		0x00000080		/* Large physical addresses */
+#define CFG3_VEIC		0x00000040		/* Vectored external i/u controller */
+#define CFG3_VI			0x00000020		/* Vectored i/us */
+#define CFG3_SP			0x00000010		/* Small page support */
+#define CFG3_MT			0x00000004		/* MT ASE present */
+#define CFG3_SM			0x00000002		/* SmartMIPS ASE */
+#define CFG3_TL			0x00000001		/* Trace Logic */
+
+/* Enable CoProcessor - CP0 12, 0 (status) */
+#define STATUS_CU3_MASK 0x80000000
+#define STATUS_CU2_MASK 0x40000000
+#define STATUS_CU1_MASK 0x20000000
+#define STATUS_CU0_MASK 0x10000000
+
+/*
+ * Cache operations
+ */
+#define Index_Invalidate_I				 0x00		 /* 0		0 */
+#define Index_Writeback_Inv_D			 0x01		 /* 0		1 */
+#define Index_Writeback_Inv_T			 0x02		 /* 0		2 */
+#define Index_Writeback_Inv_S			 0x03		 /* 0		3 */
+#define Index_Load_Tag_I				 0x04		 /* 1		0 */
+#define Index_Load_Tag_D				 0x05		 /* 1		1 */
+#define Index_Load_Tag_T				 0x06		 /* 1		2 */
+#define Index_Load_Tag_S				 0x07		 /* 1		3 */
+#define Index_Store_Tag_I				 0x08		 /* 2		0 */
+#define Index_Store_Tag_D				 0x09		 /* 2		1 */
+#define Index_Store_Tag_T				 0x0A		 /* 2		2 */
+#define Index_Store_Tag_S				 0x0B		 /* 2		3 */
+#define Hit_Invalidate_I				 0x10		 /* 4		0 */
+#define Hit_Invalidate_D				 0x11		 /* 4		1 */
+#define Hit_Invalidate_T				 0x12		 /* 4		2 */
+#define Hit_Invalidate_S				 0x13		 /* 4		3 */
+#define Fill_I							 0x14		 /* 5		0 */
+#define Hit_Writeback_Inv_D				 0x15		 /* 5		1 */
+#define Hit_Writeback_Inv_T				 0x16		 /* 5		2 */
+#define Hit_Writeback_Inv_S				 0x17		 /* 5		3 */
+#define Hit_Writeback_D					 0x19		 /* 6		1 */
+#define Hit_Writeback_T					 0x1A		 /* 6		1 */
+#define Hit_Writeback_S					 0x1B		 /* 6		3 */
+#define Fetch_Lock_I					 0x1C		 /* 7		0 */
+#define Fetch_Lock_D					 0x1D		 /* 7		1 */
+
+/*
+ *    Cache Coherency Attribute
+ *    
+ *    0 Cacheable, noncoherent, write-through, no write allocate (microAptiv)
+ *    0 Reserved (interAptiv)
+ *
+ *	  1 Cacheable, noncoherent, write-through, write allocate (microAptiv)
+ *	  1 Reserved (interAptiv)
+ *
+ *	  2 Uncached (microAptiv, interAptiv)
+ *
+ *	  3 Cacheable, noncoherent, write-back, write allocate (microAptiv, interAptiv)
+ *
+ *	  4 Cacheable, coherent, write-back, write-allocate, read misses request Exclusive (interAptiv)
+ *	  4 Cacheable, noncoherent, write-back, write allocate (interAptiv)
+ *
+ *	  5 Cacheable, noncoherent, write-back, write allocate (microAptiv)
+ *	  5 Cacheable, coherent, write-back, write-allocate, read misses request Shared (interAptiv)
+ *
+ *	  6 Cacheable, noncoherent, write-back, write allocate (microAptiv)
+ *	  6 Reserved (interAptiv)
+ *
+ *	  7 Uncached (microAptiv, interAptiv)
+ */
+
+#define CCA_WT_NOWA     0
+#define CCA_WT_WA       1
+#define CCA_UC          2
+#define CCA_WB          3
+#define CCA_IAPTIV_CWBE 4
+#define CCA_IAPTIV_CWB  5
+#define CCA_IAPTIV_RES  6
+#define CCA_IAPTIV_UCA  7
+
+/*
+ * MIPS32 Coprocessor 0 register numbers
+ */
+#define C0_INDEX		0
+#define C0_INX			0
+#define C0_RANDOM		1
+#define C0_RAND			1
+#define C0_ENTRYLO0		2
+#define C0_TLBLO0		2
+#define C0_ENTRYLO1		3
+#define C0_TLBLO1		3
+#define C0_CONTEXT		4
+#define C0_CTXT			4
+#define C0_PAGEMASK		5
+#define C0_PAGEGRAIN	(5, 1)
+#define C0_WIRED		6
+#define C0_HWRENA		7
+#define C0_BADVADDR		8
+#define C0_VADDR		8
+#define C0_COUNT		9
+#define C0_ENTRYHI		10
+#define C0_TLBHI		10
+#define C0_GUESTCTL1            10
+#define C0_COMPARE		11
+#define C0_STATUS		12
+#define C0_SR			12
+#define C0_INTCTL		(12, 1)
+#define C0_SRSCTL		(12, 2)
+#define C0_SRSMAP		(12, 3)
+#define C0_CAUSE		13
+#define C0_CR			13
+#define C0_EPC			14
+#define C0_PRID			15
+#define C0_EBASE		(15, 1)
+#define C0_CONFIG		16
+#define C0_CONFIG0		(16, 0)
+#define C0_CONFIG1		(16, 1)
+#define C0_CONFIG2		(16, 2)
+#define C0_CONFIG3		(16, 3)
+#define C0_LLADDR		17
+#define C0_WATCHLO		18
+#define C0_WATCHHI		19
+#define C0_DEBUG		23
+#define C0_DEPC			24
+#define C0_PERFCNT		25
+#define C0_ERRCTL		26
+#define C0_CACHEERR		27
+#define C0_TAGLO		28
+#define C0_ITAGLO		28
+#define C0_DTAGLO		(28, 2)
+#define C0_TAGLO2		(28, 4)
+#define C0_DATALO		(28, 1)
+#define C0_IDATALO		(28, 1)
+#define C0_DDATALO		(28, 3)
+#define C0_DATALO2		(28, 5)
+#define C0_TAGHI		29
+#define C0_ITAGHI		29
+#define C0_DATAHI		(29, 1)
+#define C0_ERRPC		30
+#define C0_DESAVE		31
+
+#define MIPS32_OP_ADD 0x20
+#define MIPS32_OP_ADDU 0x21
+#define MIPS32_OP_ADDIU 0x9
 #define MIPS32_OP_ANDI	0x0C
 #define MIPS32_OP_BEQ	0x04
 #define MIPS32_OP_BGTZ	0x07
@@ -131,7 +594,9 @@ struct mips32_algorithm {
 #define MIPS32_OP_AND	0x24
 #define MIPS32_OP_CACHE	0x2F
 #define MIPS32_OP_COP0	0x10
-#define MIPS32_OP_J	0x02
+#define MIPS32_OP_COP1	0x11
+#define MIPS32_OP_EXT	0x1F
+#define MIPS32_OP_J     0x02
 #define MIPS32_OP_JR	0x08
 #define MIPS32_OP_LUI	0x0F
 #define MIPS32_OP_LW	0x23
@@ -140,6 +605,7 @@ struct mips32_algorithm {
 #define MIPS32_OP_MFHI	0x10
 #define MIPS32_OP_MTHI	0x11
 #define MIPS32_OP_MFLO	0x12
+#define MIPS32_OP_MUL	0x2
 #define MIPS32_OP_MTLO	0x13
 #define MIPS32_OP_RDHWR 0x3B
 #define MIPS32_OP_SB	0x28
@@ -148,8 +614,11 @@ struct mips32_algorithm {
 #define MIPS32_OP_ORI	0x0D
 #define MIPS32_OP_XORI	0x0E
 #define MIPS32_OP_XOR	0x26
+#define MIPS32_OP_TLB	0x10
 #define MIPS32_OP_SLTU  0x2B
-#define MIPS32_OP_SRL	0x03
+#define MIPS32_OP_SLLV	0x04
+#define MIPS32_OP_SRA	0x03
+#define MIPS32_OP_SRL	0x02
 #define MIPS32_OP_SYNCI	0x1F
 
 #define MIPS32_OP_REGIMM	0x01
@@ -159,28 +628,45 @@ struct mips32_algorithm {
 #define MIPS32_OP_SPECIAL3	0x1F
 
 #define MIPS32_COP0_MF	0x00
+#define MIPS32_COP1_MF	0x00
+#define MIPS32_COP1_CF	0x02
 #define MIPS32_COP0_MT	0x04
+#define MIPS32_COP1_MT	0x04
+#define MIPS32_COP1_CT	0x06
 
 #define MIPS32_R_INST(opcode, rs, rt, rd, shamt, funct) \
 	(((opcode) << 26) | ((rs) << 21) | ((rt) << 16) | ((rd) << 11) | ((shamt) << 6) | (funct))
 #define MIPS32_I_INST(opcode, rs, rt, immd) \
 	(((opcode) << 26) | ((rs) << 21) | ((rt) << 16) | (immd))
+
+#define MIPS32_TLB_INST(opcode, co, rs, rt)						\
+	(((opcode) << 26) | ((co) << 25) | ((rs) << 6) | (rt))
+
+
 #define MIPS32_J_INST(opcode, addr)	(((opcode) << 26) | (addr))
 
 #define MIPS32_NOP						0
+#define MIPS32_ADD(dst, src, tar)		MIPS32_R_INST(MIPS32_OP_SPECIAL, src, tar, dst, 0, MIPS32_OP_ADD)
 #define MIPS32_ADDI(tar, src, val)		MIPS32_I_INST(MIPS32_OP_ADDI, src, tar, val)
-#define MIPS32_ADDU(dst, src, tar)		MIPS32_R_INST(MIPS32_OP_SPECIAL, src, tar, dst, 0, MIPS32_OP_ADDIU)
-#define MIPS32_AND(reg, off, val)		MIPS32_R_INST(0, off, val, reg, 0, MIPS32_OP_AND)
+#define MIPS32_ADDIU(tar, src, val)		MIPS32_I_INST(MIPS32_OP_ADDIU, src, tar, val)
+#define MIPS32_ADDU(dst, src, tar)		MIPS32_R_INST(MIPS32_OP_SPECIAL, src, tar, dst, 0, MIPS32_OP_ADDU)
+#define MIPS32_AND(reg, off, val)		MIPS32_R_INST(MIPS32_OP_SPECIAL, off, val, reg, 0, MIPS32_OP_AND)
 #define MIPS32_ANDI(tar, src, val)		MIPS32_I_INST(MIPS32_OP_ANDI, src, tar, val)
 #define MIPS32_B(off)					MIPS32_BEQ(0, 0, off)
 #define MIPS32_BEQ(src, tar, off)		MIPS32_I_INST(MIPS32_OP_BEQ, src, tar, off)
 #define MIPS32_BGTZ(reg, off)			MIPS32_I_INST(MIPS32_OP_BGTZ, reg, 0, off)
 #define MIPS32_BNE(src, tar, off)		MIPS32_I_INST(MIPS32_OP_BNE, src, tar, off)
 #define MIPS32_CACHE(op, off, base)		MIPS32_I_INST(MIPS32_OP_CACHE, base, op, off)
-#define MIPS32_J(tar)				MIPS32_J_INST(MIPS32_OP_J, tar)
+#define MIPS32_EXT(dst, src, shf, sz)		MIPS32_R_INST(MIPS32_OP_EXT, src, dst, (sz-1), shf, 0)
+#define MIPS32_J(tar)					MIPS32_J_INST(MIPS32_OP_J, tar)
 #define MIPS32_JR(reg)					MIPS32_R_INST(0, reg, 0, 0, 0, MIPS32_OP_JR)
 #define MIPS32_MFC0(gpr, cpr, sel)		MIPS32_R_INST(MIPS32_OP_COP0, MIPS32_COP0_MF, gpr, cpr, 0, sel)
+#define MIPS32_MFC1(rt, fs)				MIPS32_R_INST(MIPS32_OP_COP1, MIPS32_COP1_MF, rt, fs, 0, 0)
+#define MIPS32_CFC1(rt, fs)				MIPS32_R_INST(MIPS32_OP_COP1, MIPS32_COP1_CF, rt, fs, 0, 0)
+#define MIPS32_MOVE(dst, src)			MIPS32_R_INST(17, 16, 0, src, dst, 6)
 #define MIPS32_MTC0(gpr, cpr, sel)		MIPS32_R_INST(MIPS32_OP_COP0, MIPS32_COP0_MT, gpr, cpr, 0, sel)
+#define MIPS32_MTC1(rt, fs)				MIPS32_R_INST(MIPS32_OP_COP1, MIPS32_COP1_MT, rt, fs, 0, 0)
+#define MIPS32_CTC1(rt, fs)				MIPS32_R_INST(MIPS32_OP_COP1, MIPS32_COP1_CT, rt, fs, 0, 0)
 #define MIPS32_LBU(reg, off, base)		MIPS32_I_INST(MIPS32_OP_LBU, base, reg, off)
 #define MIPS32_LHU(reg, off, base)		MIPS32_I_INST(MIPS32_OP_LHU, base, reg, off)
 #define MIPS32_LUI(reg, val)			MIPS32_I_INST(MIPS32_OP_LUI, 0, reg, val)
@@ -189,6 +675,8 @@ struct mips32_algorithm {
 #define MIPS32_MFHI(reg)				MIPS32_R_INST(0, 0, 0, reg, 0, MIPS32_OP_MFHI)
 #define MIPS32_MTLO(reg)				MIPS32_R_INST(0, reg, 0, 0, 0, MIPS32_OP_MTLO)
 #define MIPS32_MTHI(reg)				MIPS32_R_INST(0, reg, 0, 0, 0, MIPS32_OP_MTHI)
+#define MIPS32_MUL(dst, src, t)			MIPS32_R_INST(28, src, t, dst, 0, MIPS32_OP_MUL)
+#define MIPS32_OR(dst, src, val)		MIPS32_R_INST(0, src, val, dst, 0, 37)
 #define MIPS32_ORI(tar, src, val)		MIPS32_I_INST(MIPS32_OP_ORI, src, tar, val)
 #define MIPS32_XORI(tar, src, val)		MIPS32_I_INST(MIPS32_OP_XORI, src, tar, val)
 #define MIPS32_RDHWR(tar, dst)			MIPS32_R_INST(MIPS32_OP_SPECIAL3, 0, tar, dst, 0, MIPS32_OP_RDHWR)
@@ -196,15 +684,18 @@ struct mips32_algorithm {
 #define MIPS32_SH(reg, off, base)		MIPS32_I_INST(MIPS32_OP_SH, base, reg, off)
 #define MIPS32_SW(reg, off, base)		MIPS32_I_INST(MIPS32_OP_SW, base, reg, off)
 #define MIPS32_XOR(reg, val1, val2)		MIPS32_R_INST(0, val1, val2, reg, 0, MIPS32_OP_XOR)
+#define MIPS32_SRA(reg, src, off)		MIPS32_R_INST(0, 0, src, reg, off, MIPS32_OP_SRL)
 #define MIPS32_SRL(reg, src, off)		MIPS32_R_INST(0, 0, src, reg, off, MIPS32_OP_SRL)
 #define MIPS32_SLTU(dst, src, tar)		MIPS32_R_INST(MIPS32_OP_SPECIAL, src, tar, dst, 0, MIPS32_OP_SLTU)
+#define MIPS32_SLLV(dst, tar, src)		MIPS32_R_INST(MIPS32_OP_SPECIAL, src, tar, dst, 0, MIPS32_OP_SLLV)
 #define MIPS32_SYNCI(off, base)			MIPS32_I_INST(MIPS32_OP_REGIMM, base, MIPS32_OP_SYNCI, off)
+#define MIPS32_TLBR()					MIPS32_TLB_INST(MIPS32_OP_TLB, 1, 0, 1)
 
 #define MIPS32_SYNC			0xF
 #define MIPS32_SYNCI_STEP	0x1	/* reg num od address step size to be used with synci instruction */
 
 /**
- * Cache operations definitions
+ * Cache operations definietions
  * Operation field is 5 bits long :
  * 1) bits 1..0 hold cache type
  * 2) bits 4..2 hold operation code
@@ -216,10 +707,217 @@ struct mips32_algorithm {
 #define MIPS32_DRET					0x4200001F
 #define MIPS32_SDBBP				0x7000003F	/* MIPS32_J_INST(MIPS32_OP_SPECIAL2, MIPS32_OP_SDBBP) */
 #define MIPS16_SDBBP				0xE801
+#define MICRO_MIPS32_SDBBP			0x000046C0
+#define MICRO_MIPS_SDBBP			0x46C0
+#define MIPS32_DSP_ENABLE			0x1000000
+
+#define MIPS32_S_INST(rs, rac, opcode)			\
+	(((rs) << 21) | ((rac) << 11) | (opcode))
+
+#define MIPS32_DSP_R_INST(rt, immd, opcode, extrw) \
+	((0x1F << 26) | ((immd) << 16) | ((rt) << 11) | ((opcode) << 6) | (extrw))
+#define MIPS32_DSP_W_INST(rs, immd, opcode, extrw) \
+	((0x1F << 26) | ((rs) << 21) | ((immd) << 11) | ((opcode) << 6) | (extrw))
+
+#define MIPS32_DSP_MFHI(reg,ac)		MIPS32_R_INST(0, ac, 0, reg, 0, MIPS32_OP_MFHI)
+#define MIPS32_DSP_MFLO(reg, ac)	MIPS32_R_INST(0, ac, 0, reg, 0, MIPS32_OP_MFLO)
+#define MIPS32_DSP_MTLO(reg, ac)	MIPS32_S_INST(reg, ac, MIPS32_OP_MTLO)
+#define MIPS32_DSP_MTHI(reg, ac)	MIPS32_S_INST(reg, ac, MIPS32_OP_MTHI)
+#define MIPS32_DSP_RDDSP(rt, mask)	MIPS32_DSP_R_INST(rt, mask, 0x12, 0x38)
+#define MIPS32_DSP_WRDSP(rs, mask)	MIPS32_DSP_W_INST(rs, mask, 0x13, 0x38)
+
+//CPU types
+//NOTE!	 If any cores added, must also add in mdi/mdi_internal.c
+//CPU TYPES
+#define MIPS_CORE_4K   0x0000
+#define MIPS_CORE_4KE  0x0100
+#define MIPS_CORE_4KS  0x0200
+#define MIPS_CORE_5K   0x0400
+#define MIPS_CORE_20K  0x0800
+#define MIPS_CORE_M4K  0x1000
+#define MIPS_CORE_24K  0x2000
+#define MIPS_CORE_34K  0x4000
+#define MIPS_CORE_AU1  0x8000
+#define MIPS_CORE_24KE 0x10000
+#define MIPS_CORE_74K  0x20000
+#define MIPS_CORE_84K  0x40000
+#define MIPS_CORE_BCM  0x80000
+#define MIPS_CORE_1004K	 0x100000
+#define MIPS_CORE_1074K	 0x200000
+#define MIPS_CORE_M14K	  0x400000
+#define MIPS_CORE_ALTERA  0x800000
+#define MIPS_CORE_PROAPTIV	0x1000000
+#define MIPS_CORE_INTERAPTIV  0x2000000
+#define MIPS_CORE_5KE	0x4000000
+#define MIPS_CORE_P5600 0x8000000
+#define MIPS_CORE_I5500 0x10000000
+
+#define MIPS_CORE_MASK 0xFFFFFF00
+#define MIPS_VARIANT_MASK 0x00FF
+
+//DEVICE: cpu information
+//CPU
+typedef enum {
+   CPUTYPE_UNKNOWN = 0,
+   MIPS_4Kc	  =0x0001 | MIPS_CORE_4K,
+   MIPS_4Km	  =0x0002 | MIPS_CORE_4K,
+   MIPS_4Kp	  =0x0004 | MIPS_CORE_4K,
+   MIPS_4KEc  =0x0001 | MIPS_CORE_4KE,
+   MIPS_4KEm  =0x0002 | MIPS_CORE_4KE,
+   MIPS_4KEp  =0x0004 | MIPS_CORE_4KE,
+   MIPS_4KSc  =0x0001 | MIPS_CORE_4KS,
+   MIPS_4KSd  =0x0002 | MIPS_CORE_4KS,
+   MIPS_M4K	  =0x0008 | MIPS_CORE_M4K,
+   MIPS_24Kc  =0x0001 | MIPS_CORE_24K,
+   MIPS_24Kf  =0x0010 | MIPS_CORE_24K,
+   MIPS_24KEc =0x0001 | MIPS_CORE_24KE,
+   MIPS_24KEf =0x0010 | MIPS_CORE_24KE,
+   MIPS_34Kc  =0x0001 | MIPS_CORE_34K,
+   MIPS_34Kf  =0x0010 | MIPS_CORE_34K,
+   MIPS_5Kc	  =0x0001 | MIPS_CORE_5K,
+   MIPS_5Kf	  =0x0010 | MIPS_CORE_5K,
+   MIPS_5KEc  =0x0001 | MIPS_CORE_5KE,
+   MIPS_5KEf  =0x0010 | MIPS_CORE_5KE,
+   MIPS_20Kc  =0x0001 | MIPS_CORE_20K,
+   MIPS_25Kf  =0x0010 | MIPS_CORE_20K,
+   MIPS_AU1000=0x0001 | MIPS_CORE_AU1,
+   MIPS_AU1100=0x0002 | MIPS_CORE_AU1,
+   MIPS_AU1200=0x0003 | MIPS_CORE_AU1,
+   MIPS_AU1500=0x0004 | MIPS_CORE_AU1,
+   MIPS_AU1550=0x0005 | MIPS_CORE_AU1,
+   MIPS_74Kc  =0x0001 | MIPS_CORE_74K,
+   MIPS_74Kf  =0x0010 | MIPS_CORE_74K,
+   MIPS_84Kc  =0x0001 | MIPS_CORE_84K,
+   MIPS_84Kf  =0x0010 | MIPS_CORE_84K,
+   MIPS_BCM	  =0x0000 | MIPS_CORE_BCM,
+   MIPS_MP32   =0x0000 | MIPS_CORE_ALTERA,
+   MIPS_1004Kc=0x0001 | MIPS_CORE_1004K,
+   MIPS_1004Kf=0x0010 | MIPS_CORE_1004K,
+   MIPS_1074Kc=0x0001 | MIPS_CORE_1074K,
+   MIPS_1074Kf=0x0010 | MIPS_CORE_1074K,
+   MIPS_M14Kc  =0x0001 | MIPS_CORE_M14K,
+   MIPS_M14K   =0x0002 | MIPS_CORE_M14K,
+   MIPS_M14Kf  =0x0010 | MIPS_CORE_M14K,
+   MIPS_M14KE  =0x0020 | MIPS_CORE_M14K,	  // now called microAptiv UC
+   MIPS_M14KEf =0x0030 | MIPS_CORE_M14K,	  // now called microAptiv UCF
+   MIPS_M14KEc =0x0040 | MIPS_CORE_M14K,	  // now called microAptiv UP
+   MIPS_M14KEcf=0x0050 | MIPS_CORE_M14K,	  // now called microAptiv UPF
+   MIPS_M5100=0x0090 | MIPS_CORE_M14K,
+   MIPS_M5150=0x00B0 | MIPS_CORE_M14K,
+   MIPS_PROAPTIV =0x0001 | MIPS_CORE_PROAPTIV,
+   MIPS_PROAPTIV_CM =0x0002 | MIPS_CORE_PROAPTIV,
+   MIPS_INTERAPTIV =0x0001 | MIPS_CORE_INTERAPTIV,
+   MIPS_INTERAPTIV_CM =0x0002 | MIPS_CORE_INTERAPTIV,
+   MIPS_P5600 = MIPS_CORE_P5600,
+   MIPS_I5500 = MIPS_CORE_I5500,
+} CPUTYPE;
+
+#define MMU_TLB 1
+#define MMU_BAT 2
+#define MMU_FIXED 3
+#define MMU_DUAL_VTLB_FTLB 4
+
+enum CPU_VENDOR {
+	MIPS_CORE,
+	ALCHEMY_CORE, 
+	BROADCOM_CORE,
+	ALTERA_CORE,
+};
+
+enum CPU_INSTRUCTION_SET {
+	MIPS16,
+	MIPS32,
+	MIPS64,
+	MICROMIPS_ONLY,
+	MIPS32_AT_RESET_AND_MICROMIPS,
+	MICROMIPS_AT_RESET_AND_MIPS32, 
+};
+
+enum EJTAG_VERSION {
+	EJTAG_VER_UNKNOWN,
+	EJTAG_2_0,
+	EJTAG_2_5,
+	EJTAG_2_6,
+	EJTAG_3_1,
+	EJTAG_4_0, 
+	EJTAG_5_0,
+};
+
+typedef struct {
+	uint32_t cpuCore;				// type of CPU	(4Kc, 24Kf, etc.)
+	uint32_t cpuType;					// internal representation of cpu type
+	enum CPU_VENDOR vendor;				// who makes the CPU:
+	enum CPU_INSTRUCTION_SET instSet;	// MIPS16, MIPS32, microMIPS.
+	uint32_t prid;						// processor's prid
+	uint32_t numRegs;					//number of registers (same as calling HdiDeviceRegisterTotalGet)
+	uint32_t numInstBkpts;				// number of instruction breakpoints in this CPU
+	uint32_t numDataBkpts;				// number of data breakpoints in this CPU
+	uint32_t numTcbTrig;				// number of TCB triggers in this CPU
+	bool pdtrace;						// CPU has trace?
+	bool asidInstBkpts;					// asid specification supported in Inst Bkpts?
+	bool asidDataBkpts;					// asid specification supported in Data Bkpts?
+	bool sharedInstBkpts;				// Are inst bkpts shared between VPE's
+	bool sharedDataBkpts;				// Are data bkpts shared between VPE's
+	bool armedInstBkpts;				// Do inst bkpts have armed triggering
+	bool armedDataBkpts;				// Do inst bkpts have armed triggering
+	uint32_t bkptRangePresent;			// Bitmask indicating which triggers have address ranging capability (bit 0-15 = inst, 16=31 = data)
+	uint32_t tcbrev;					// TCB revision number
+	uint32_t tcbCpuBits;				// Number of bits in the CPU field of trace words
+	uint32_t tcbVmodes;					// Vmodes field (1=lsa supported, 2=lsad supported)
+	bool pcTraceForcedOn;				// TRUE if hardware always collects PC trace
+	bool mtase;							// CPU has MultiThreading extension?
+	bool dspase;						// CPU has DSP extension?
+	bool smase;							// CPU has SmartMIPS extension?
+	bool m16ase;						// CPU has MIPS16[e] extension?
+	bool micromipsase;					// CPU has microMIPS extension?
+    uint32_t vzase;							// CPU has Virtualization ASE?
+	uint32_t vzGuestIdWidth;
+	bool vzGuestId;						// CPU has Virtualization ASE and supports Guest ID?
+	bool profiling;						// Is profiling present?
+	bool fpuPresent;					// CPU has floating point unit?
+	bool pcSampSupported;				// CPU has PC Sampling capability
+	bool DASampSupported;				// CPU has Data Address Sampling capability
+	uint32_t cpuid;						// ebase.cpuid number
+	uint32_t vpeid;						// VPE id number
+	uint32_t numtc;						// Number of TC's in this processor
+	uint32_t numvpe;					// Number of VPE's in this processor
+	uint32_t numitc;					// Number of ITC cells in this processor
+	bool offchip;						// Sofware supports off-chip trace?
+	bool onchip;						// Sofware supports on-chip trace?
+	bool cbtrig;						// CPU has complex break and trigger block?
+	bool cbtrigPassCounters;			//CBT pass counters present?
+	bool cbtrigTuples;					//CBT tuples present?
+	bool cbtrigDataQualifiers;			//CBT data qualifiers present?
+	bool cbtrigPrimedBreaks;			//CBT primed breaks present?
+	bool cbtrigStopWatch;				//CBT stop watch present?
+	bool cbtrigNot;						//CBT not (invert data value match) supported?
+	bool pmtrace;						//Does system have performance monitor trace?
+	uint32_t adsize;					//Address size
+	enum EJTAG_VERSION ejtagVersion;	//EJTAG version
+	uint32_t iCacheSize;
+	uint32_t dCacheSize;
+	uint32_t mmutype;
+	uint32_t tlbEntries;
+	uint32_t gtlbEntries;   // guest TLB
+	bool fdcPresent;
+	bool evaPresent;					// Enhanced virtual address (introduced with proAptiv).
+	bool systemTracePresent;
+	uint32_t numshadowregs;
+	uint32_t impcode;
+	uint32_t idcode;
+	uint32_t onchipSize;
+	bool cmPresent;
+	bool msaPresent;
+	bool msa;							// does cpu have MSA module
+	bool mvh;							// are mfhc0 and mthc0 instructions implemented?
+	bool guestCtl1Present;
+	bool cdmm;
+} CPU_INFO;
 
 extern const struct command_registration mips32_command_handlers[];
 
 int mips32_arch_state(struct target *target);
+int mips32_read_cpu_config_info (struct target *target);
 
 int mips32_init_arch_info(struct target *target,
 		struct mips32_common *mips32, struct jtag_tap *tap);
@@ -251,4 +949,7 @@ int mips32_checksum_memory(struct target *target, uint32_t address,
 int mips32_blank_check_memory(struct target *target,
 		uint32_t address, uint32_t count, uint32_t *blank);
 
+uint32_t DetermineCpuTypeFromPrid(uint32_t prid, uint32_t config, uint32_t config1);
+int mips32_cp0_command(struct command_invocation *cmd);
+int mips32_scan_delay_command(struct command_invocation *cmd);
 #endif	/*MIPS32_H*/
diff --git b/src/target/mips32_pracc.c a/src/target/mips32_pracc.c
index e97626cb2..d37dd9c8f 100644
--- b/src/target/mips32_pracc.c
+++ a/src/target/mips32_pracc.c
@@ -96,15 +96,17 @@ static int wait_for_pracc_rw(struct mips_ejtag *ejtag_info, uint32_t *ctrl)
 	while (1) {
 		ejtag_ctrl = ejtag_info->ejtag_ctrl;
 		int retval = mips_ejtag_drscan_32(ejtag_info, &ejtag_ctrl);
-		if (retval != ERROR_OK)
+		if (retval != ERROR_OK) {
+			LOG_DEBUG("mips_ejtag_drscan_32 Failed");
 			return retval;
+		}
 
 		if (ejtag_ctrl & EJTAG_CTRL_PRACC)
 			break;
 
 		int timeout = timeval_ms() - then;
 		if (timeout > 1000) {
-			LOG_DEBUG("DEBUGMODULE: No memory access in progress!");
+			LOG_DEBUG("Timeout: No memory access in progress!");
 			return ERROR_JTAG_DEVICE_ERROR;
 		}
 	}
@@ -117,8 +119,10 @@ static int wait_for_pracc_rw(struct mips_ejtag *ejtag_info, uint32_t *ctrl)
 static int mips32_pracc_read_ctrl_addr(struct mips_ejtag *ejtag_info)
 {
 	int retval = wait_for_pracc_rw(ejtag_info, &ejtag_info->pa_ctrl);
-	if (retval != ERROR_OK)
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("wait_for_pracc_rw failed");
 		return retval;
+	}
 
 	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_ADDRESS);
 	ejtag_info->pa_addr = 0;
@@ -168,6 +172,7 @@ int mips32_pracc_clean_text_jump(struct mips_ejtag *ejtag_info)
 		return retval;
 
 	if (ejtag_info->pa_addr != MIPS32_PRACC_TEXT) {			/* LEXRA/BMIPS ?, shift out another NOP */
+//		LOG_INFO ("Clean text - LEXRA/BMIPS");
 		mips_ejtag_set_instr(ejtag_info, EJTAG_INST_DATA);
 		mips_ejtag_drscan_32_out(ejtag_info, MIPS32_NOP);
 		retval = mips32_pracc_finish(ejtag_info);
@@ -194,10 +199,13 @@ int mips32_pracc_exec(struct mips_ejtag *ejtag_info, struct pracc_queue_info *ct
 		if (restart) {
 			if (restart_count < 3) {					/* max 3 restarts allowed */
 				retval = mips32_pracc_clean_text_jump(ejtag_info);
-				if (retval != ERROR_OK)
+				if (retval != ERROR_OK) {
+					LOG_DEBUG("mips32_pracc_clean_text_jump failed");
 					return retval;
+				}
 			} else
 				return ERROR_JTAG_DEVICE_ERROR;
+
 			restart_count++;
 			restart = 0;
 			code_count = 0;
@@ -205,8 +213,10 @@ int mips32_pracc_exec(struct mips_ejtag *ejtag_info, struct pracc_queue_info *ct
 		}
 
 		retval = mips32_pracc_read_ctrl_addr(ejtag_info);		/* update current pa info: control and address */
-		if (retval != ERROR_OK)
+		if (retval != ERROR_OK) {
+			LOG_DEBUG("mips32_pracc_read_ctrl_addr failed");
 			return retval;
+		}
 
 		/* Check for read or write access */
 		if (ejtag_info->pa_ctrl & EJTAG_CTRL_PRNW) {						/* write/store access */
@@ -230,8 +240,10 @@ int mips32_pracc_exec(struct mips_ejtag *ejtag_info, struct pracc_queue_info *ct
 			uint32_t data = 0;
 			mips_ejtag_set_instr(ejtag_info, EJTAG_INST_DATA);
 			retval = mips_ejtag_drscan_32(ejtag_info, &data);
-			if (retval != ERROR_OK)
+			if (retval != ERROR_OK) {
+				LOG_DEBUG("mips_ejtag_drscan_32 failed");
 				return retval;
+			}
 
 			/* store data at param out, address based offset */
 			param_out[(ejtag_info->pa_addr - MIPS32_PRACC_PARAM_OUT) / 4] = data;
@@ -283,7 +295,7 @@ int mips32_pracc_exec(struct mips_ejtag *ejtag_info, struct pracc_queue_info *ct
 					}
 				} else {
 					if (ejtag_info->pa_addr != (MIPS32_PRACC_TEXT + code_count * 4)) {
-						LOG_DEBUG("unexpected read address in final check: %" PRIx32 ", expected: %x",
+						LOG_DEBUG("unexpected read address in final check: %" PRIx32 ", expected: %" PRIx32,
 							  ejtag_info->pa_addr, MIPS32_PRACC_TEXT + code_count * 4);
 						return ERROR_JTAG_DEVICE_ERROR;
 					}
@@ -308,17 +320,23 @@ int mips32_pracc_exec(struct mips_ejtag *ejtag_info, struct pracc_queue_info *ct
 		}
 		/* finish processor access, let the processor eat! */
 		retval = mips32_pracc_finish(ejtag_info);
-		if (retval != ERROR_OK)
+		if (retval != ERROR_OK) {
+			LOG_DEBUG("mips32_pracc_finish failed");
 			return retval;
+		}
 
-		if (instr == MIPS32_DRET)	/* after leaving debug mode nothing to do */
+		if (instr == MIPS32_DRET) {	/* after leaving debug mode nothing to do */
+			LOG_DEBUG("MIPS32_DRET executed");
 			return ERROR_OK;
+		}
 
 		if (store_pending == 0 && pass) {	/* store access done, but after passing pracc text */
 			LOG_DEBUG("warning: store access pass pracc text");
 			return ERROR_OK;
 		}
 	}
+
+	return ERROR_OK; /* ??? */
 }
 
 inline void pracc_queue_init(struct pracc_queue_info *ctx)
@@ -334,10 +352,15 @@ inline void pracc_queue_init(struct pracc_queue_info *ctx)
 	}
 }
 
+unsigned int dump = 0;
 inline void pracc_add(struct pracc_queue_info *ctx, uint32_t addr, uint32_t instr)
 {
 	ctx->pracc_list[ctx->max_code + ctx->code_count] = addr;
 	ctx->pracc_list[ctx->code_count++] = instr;
+
+	if (dump == 1)
+		LOG_DEBUG("addr:0x%8.8x, data: 0x%8.8x", addr, instr);
+	
 	if (addr)
 		ctx->store_count++;
 }
@@ -352,8 +375,9 @@ inline void pracc_queue_free(struct pracc_queue_info *ctx)
 
 int mips32_pracc_queue_exec(struct mips_ejtag *ejtag_info, struct pracc_queue_info *ctx, uint32_t *buf)
 {
-	if (ejtag_info->mode == 0)
+	if (ejtag_info->mode == 0) {
 		return mips32_pracc_exec(ejtag_info, ctx, buf);
+	}
 
 	union scan_in {
 		uint8_t scan_96[12];
@@ -389,8 +413,10 @@ int mips32_pracc_queue_exec(struct mips_ejtag *ejtag_info, struct pracc_queue_in
 	}
 
 	int retval = jtag_execute_queue();		/* execute queued scans */
-	if (retval != ERROR_OK)
+	if (retval != ERROR_OK) {
+		LOG_INFO ("jtag_execute_queue");
 		goto exit;
+	}
 
 	uint32_t fetch_addr = MIPS32_PRACC_TEXT;		/* start address */
 	scan_count = 0;
@@ -404,16 +430,17 @@ int mips32_pracc_queue_exec(struct mips_ejtag *ejtag_info, struct pracc_queue_in
 
 		ejtag_ctrl = buf_get_u32(scan_in[scan_count].scan_32.ctrl, 0, 32);
 		if (!(ejtag_ctrl & EJTAG_CTRL_PRACC)) {
-			LOG_ERROR("Error: access not pending  count: %d", scan_count);
+			LOG_ERROR("Error: access not pending count: %d", scan_count);
+			LOG_ERROR("Ejtag control: 0x%x -- store_addr: 0x%x",ejtag_ctrl, store_addr);
 			retval = ERROR_FAIL;
 			goto exit;
 		}
 
 		uint32_t addr = buf_get_u32(scan_in[scan_count].scan_32.addr, 0, 32);
-
+                
 		if (store_addr != 0) {
 			if (!(ejtag_ctrl & EJTAG_CTRL_PRNW)) {
-				LOG_ERROR("Not a store/write access, count: %d", scan_count);
+				LOG_ERROR("Not a store/write access(addr:%x), count: %d", addr, scan_count);
 				retval = ERROR_FAIL;
 				goto exit;
 			}
@@ -428,7 +455,7 @@ int mips32_pracc_queue_exec(struct mips_ejtag *ejtag_info, struct pracc_queue_in
 
 		} else {
 			if (ejtag_ctrl & EJTAG_CTRL_PRNW) {
-				LOG_ERROR("Not a fetch/read access, count: %d", scan_count);
+				LOG_ERROR("Not a fetch/read access, count: %d addr: %x", scan_count, addr);
 				retval = ERROR_FAIL;
 				goto exit;
 			}
@@ -444,12 +471,20 @@ int mips32_pracc_queue_exec(struct mips_ejtag *ejtag_info, struct pracc_queue_in
 	}
 exit:
 	free(scan_in);
+
+	if (retval != ERROR_OK) {
+		int tmp_retval = mips32_pracc_clean_text_jump(ejtag_info);
+		if (tmp_retval != ERROR_OK) {
+			LOG_DEBUG("mips32_pracc_clean_text_jump failed");
+		}
+	}
+
 	return retval;
 }
 
 int mips32_pracc_read_u32(struct mips_ejtag *ejtag_info, uint32_t addr, uint32_t *buf)
 {
-	struct pracc_queue_info ctx = {.max_code = 8};
+	struct pracc_queue_info ctx = {.max_code = 9};
 	pracc_queue_init(&ctx);
 	if (ctx.retval != ERROR_OK)
 		goto exit;
@@ -461,22 +496,26 @@ int mips32_pracc_read_u32(struct mips_ejtag *ejtag_info, uint32_t addr, uint32_t
 				MIPS32_SW(8, PRACC_OUT_OFFSET, 15));			/* sw $8,PRACC_OUT_OFFSET($15) */
 	pracc_add(&ctx, 0, MIPS32_LUI(8, UPPER16(ejtag_info->reg8)));		/* restore upper 16 of $8 */
 	pracc_add(&ctx, 0, MIPS32_ORI(8, 8, LOWER16(ejtag_info->reg8)));		/* restore lower 16 of $8 */
+
+	pracc_add(&ctx, 0, MIPS32_SYNC);
 	pracc_add(&ctx, 0, MIPS32_B(NEG16(ctx.code_count + 1)));					/* jump to start */
 	pracc_add(&ctx, 0, MIPS32_MFC0(15, 31, 0));					/* move COP0 DeSave to $15 */
 
 	ctx.retval = mips32_pracc_queue_exec(ejtag_info, &ctx, buf);
+
 exit:
 	pracc_queue_free(&ctx);
 	return ctx.retval;
 }
 
-int mips32_pracc_read_mem(struct mips_ejtag *ejtag_info, uint32_t addr, int size, int count, void *buf)
+int mips32_pracc_read_mem(struct mips_ejtag *ejtag_info, uint32_t addr, int size, int count, void *buf, int cputype)
 {
 	if (count == 1 && size == 4)
 		return mips32_pracc_read_u32(ejtag_info, addr, (uint32_t *)buf);
 
 	uint32_t *data = NULL;
-	struct pracc_queue_info ctx = {.max_code = 256 * 3 + 8 + 1};	/* alloc memory for the worst case */
+	struct pracc_queue_info ctx = {.max_code = 256 * 3 + 9 + 1};	/* alloc memory for the worst case */
+
 	pracc_queue_init(&ctx);
 	if (ctx.retval != ERROR_OK)
 		goto exit;
@@ -511,10 +550,18 @@ int mips32_pracc_read_mem(struct mips_ejtag *ejtag_info, uint32_t addr, int size
 
 			if (size == 4)
 				pracc_add(&ctx, 0, MIPS32_LW(8, LOWER16(addr), 9));		/* load from memory to $8 */
-			else if (size == 2)
+			else if (size == 2) {
 				pracc_add(&ctx, 0, MIPS32_LHU(8, LOWER16(addr), 9));
-			else
+//				LOG_INFO ("LH addr: %x size: %x cputype: 0x%x", addr, size, cputype);
+				if (cputype == MIPS_CP0_mAPTIV_uP)
+					pracc_add(&ctx, 0, MIPS32_NOP);						/* nop - Added to allow read to complete before store. Possible hardware bug */
+			}
+			else {
 				pracc_add(&ctx, 0, MIPS32_LBU(8, LOWER16(addr), 9));
+//				LOG_INFO ("LB addr: %x size: %x cputype: 0x%x", addr, size, cputype);
+				if (cputype == MIPS_CP0_mAPTIV_uP)
+					pracc_add(&ctx, 0, MIPS32_NOP);						/* nop - Added to allow read to complete before store. Possible hardware bug */
+			}
 
 			pracc_add(&ctx, MIPS32_PRACC_PARAM_OUT + i * 4,
 					  MIPS32_SW(8, PRACC_OUT_OFFSET + i * 4, 15));		/* store $8 at param out */
@@ -524,19 +571,24 @@ int mips32_pracc_read_mem(struct mips_ejtag *ejtag_info, uint32_t addr, int size
 		pracc_add(&ctx, 0, MIPS32_ORI(8, 8, LOWER16(ejtag_info->reg8)));	/* restore lower 16 bits of reg 8 */
 		pracc_add(&ctx, 0, MIPS32_LUI(9, UPPER16(ejtag_info->reg9)));		/* restore upper 16 bits of reg 9 */
 		pracc_add(&ctx, 0, MIPS32_ORI(9, 9, LOWER16(ejtag_info->reg9)));	/* restore lower 16 bits of reg 9 */
-
+		pracc_add(&ctx, 0, MIPS32_SYNC);
 		pracc_add(&ctx, 0, MIPS32_B(NEG16(ctx.code_count + 1)));				/* jump to start */
 		pracc_add(&ctx, 0, MIPS32_MFC0(15, 31, 0));					/* restore $15 from DeSave */
 
 		if (size == 4) {
-			ctx.retval = mips32_pracc_queue_exec(ejtag_info, &ctx, buf32);
-			if (ctx.retval != ERROR_OK)
+			ctx.retval = mips32_pracc_exec(ejtag_info, &ctx, buf32);
+			if (ctx.retval != ERROR_OK){
+				LOG_DEBUG("mips32_pracc_exec failed");
 				goto exit;
+			}
 			buf32 += this_round_count;
 		} else {
 			ctx.retval = mips32_pracc_queue_exec(ejtag_info, &ctx, data);
-			if (ctx.retval != ERROR_OK)
+
+			if (ctx.retval != ERROR_OK){
+				LOG_DEBUG("mips32_pracc_queue_exec failed");
 				goto exit;
+			}
 
 			uint32_t *data_p = data;
 			for (int i = 0; i != this_round_count; i++) {
@@ -555,19 +607,20 @@ exit:
 	return ctx.retval;
 }
 
-int mips32_cp0_read(struct mips_ejtag *ejtag_info, uint32_t *val, uint32_t cp0_reg, uint32_t cp0_sel)
+int mips32_pracc_cp0_read(struct mips_ejtag *ejtag_info, uint32_t *val, uint32_t cp0_reg, uint32_t cp0_sel)
 {
-	struct pracc_queue_info ctx = {.max_code = 7};
+	struct pracc_queue_info ctx = {.max_code = 8};
+
 	pracc_queue_init(&ctx);
 	if (ctx.retval != ERROR_OK)
 		goto exit;
-
 	pracc_add(&ctx, 0, MIPS32_LUI(15, PRACC_UPPER_BASE_ADDR));			/* $15 = MIPS32_PRACC_BASE_ADDR */
 	pracc_add(&ctx, 0, MIPS32_MFC0(8, 0, 0) | (cp0_reg << 11) | cp0_sel);	/* move COP0 [cp0_reg select] to $8 */
 	pracc_add(&ctx, MIPS32_PRACC_PARAM_OUT,
 				MIPS32_SW(8, PRACC_OUT_OFFSET, 15));			/* store $8 to pracc_out */
 	pracc_add(&ctx, 0, MIPS32_MFC0(15, 31, 0));					/* move COP0 DeSave to $15 */
 	pracc_add(&ctx, 0, MIPS32_LUI(8, UPPER16(ejtag_info->reg8)));		/* restore upper 16 bits  of $8 */
+	pracc_add(&ctx, 0, MIPS32_SYNC);
 	pracc_add(&ctx, 0, MIPS32_B(NEG16(ctx.code_count + 1)));					/* jump to start */
 	pracc_add(&ctx, 0, MIPS32_ORI(8, 8, LOWER16(ejtag_info->reg8)));		/* restore lower 16 bits of $8 */
 
@@ -594,9 +647,10 @@ exit:
 	 **/
 }
 
-int mips32_cp0_write(struct mips_ejtag *ejtag_info, uint32_t val, uint32_t cp0_reg, uint32_t cp0_sel)
+int mips32_pracc_cp0_write(struct mips_ejtag *ejtag_info, uint32_t val, uint32_t cp0_reg, uint32_t cp0_sel)
 {
 	struct pracc_queue_info ctx = {.max_code = 6};
+
 	pracc_queue_init(&ctx);
 	if (ctx.retval != ERROR_OK)
 		goto exit;
@@ -655,6 +709,7 @@ static int mips32_pracc_synchronize_cache(struct mips_ejtag *ejtag_info,
 	pracc_queue_init(&ctx);
 	if (ctx.retval != ERROR_OK)
 		goto exit;
+
 	/** Find cache line size in bytes */
 	uint32_t clsiz;
 	if (rel) {	/* Release 2 (rel = 1) */
@@ -667,6 +722,7 @@ static int mips32_pracc_synchronize_cache(struct mips_ejtag *ejtag_info,
 
 		pracc_add(&ctx, 0, MIPS32_LUI(8, UPPER16(ejtag_info->reg8)));			/* restore upper 16 bits  of $8 */
 		pracc_add(&ctx, 0, MIPS32_ORI(8, 8, LOWER16(ejtag_info->reg8)));		/* restore lower 16 bits of $8 */
+		pracc_add(&ctx, 0, MIPS32_SYNC);
 		pracc_add(&ctx, 0, MIPS32_B(NEG16(ctx.code_count + 1)));					/* jump to start */
 		pracc_add(&ctx, 0, MIPS32_MFC0(15, 31, 0));					/* move COP0 DeSave to $15 */
 
@@ -676,7 +732,7 @@ static int mips32_pracc_synchronize_cache(struct mips_ejtag *ejtag_info,
 
 	} else {			/* Release 1 (rel = 0) */
 		uint32_t conf;
-		ctx.retval = mips32_cp0_read(ejtag_info, &conf, 16, 1);
+		ctx.retval = mips32_pracc_cp0_read(ejtag_info, &conf, 16, 1);
 		if (ctx.retval != ERROR_OK)
 			goto exit;
 
@@ -753,6 +809,7 @@ static int mips32_pracc_write_mem_generic(struct mips_ejtag *ejtag_info,
 		uint32_t addr, int size, int count, const void *buf)
 {
 	struct pracc_queue_info ctx = {.max_code = 128 * 3 + 5 + 1};	/* alloc memory for the worst case */
+
 	pracc_queue_init(&ctx);
 	if (ctx.retval != ERROR_OK)
 		goto exit;
@@ -785,6 +842,7 @@ static int mips32_pracc_write_mem_generic(struct mips_ejtag *ejtag_info,
 					pracc_add(&ctx, 0, MIPS32_LUI(8, UPPER16(*buf32)));		/* load upper and lower */
 					pracc_add(&ctx, 0, MIPS32_ORI(8, 8, LOWER16(*buf32)));
 				}
+
 				pracc_add(&ctx, 0, MIPS32_SW(8, LOWER16(addr), 15));		/* store word to memory */
 				buf32++;
 
@@ -804,12 +862,17 @@ static int mips32_pracc_write_mem_generic(struct mips_ejtag *ejtag_info,
 		pracc_add(&ctx, 0, MIPS32_LUI(8, UPPER16(ejtag_info->reg8)));		/* restore upper 16 bits of reg 8 */
 		pracc_add(&ctx, 0, MIPS32_ORI(8, 8, LOWER16(ejtag_info->reg8)));	/* restore lower 16 bits of reg 8 */
 
+		pracc_add(&ctx, 0, MIPS32_SYNC);                                        /* if any DRSEG or DMSEG stores were made, */
+		                                                                        /* some cores might leave one or more uncommitted without a SYNC here */
 		pracc_add(&ctx, 0, MIPS32_B(NEG16(ctx.code_count + 1)));				/* jump to start */
 		pracc_add(&ctx, 0, MIPS32_MFC0(15, 31, 0));				/* restore $15 from DeSave */
 
 		ctx.retval = mips32_pracc_queue_exec(ejtag_info, &ctx, NULL);
-		if (ctx.retval != ERROR_OK)
+		if (ctx.retval != ERROR_OK) {
+			LOG_ERROR("mips32_pracc_exec failed");
 			goto exit;
+		}
+
 		count -= this_round_count;
 	}
 exit:
@@ -819,6 +882,9 @@ exit:
 
 int mips32_pracc_write_mem(struct mips_ejtag *ejtag_info, uint32_t addr, int size, int count, const void *buf)
 {
+	LOG_DEBUG("address: 0x%8.8" PRIx32 ", size: 0x%8.8" PRIx32 ", count: 0x%8.8" PRIx32 "",
+ 			addr, size, count);
+
 	int retval = mips32_pracc_write_mem_generic(ejtag_info, addr, size, count, buf);
 	if (retval != ERROR_OK)
 		return retval;
@@ -829,13 +895,26 @@ int mips32_pracc_write_mem(struct mips_ejtag *ejtag_info, uint32_t addr, int siz
 	 * so that changes do not continue to live only in D$ (if CCA = 3), but to be
 	 * replicated in I$ also (maybe we wrote the istructions)
 	 */
-	uint32_t conf = 0;
-	int cached = 0;
-
 	if ((KSEGX(addr) == KSEG1) || ((addr >= 0xff200000) && (addr <= 0xff3fffff)))
 		return retval; /*Nothing to do*/
 
-	mips32_cp0_read(ejtag_info, &conf, 16, 0);
+	int cached = 0;
+
+	uint32_t conf = 0;
+	uint32_t prid;
+	uint32_t config1;
+	uint32_t cpuType;
+
+	if ((retval = mips32_pracc_cp0_read(ejtag_info, &conf, 16, 0))!= ERROR_OK)
+		return retval;
+
+	/* Read PRID registers */
+	if ((retval = mips32_pracc_cp0_read(ejtag_info, &prid, 15, 0)) != ERROR_OK)
+		return retval;
+
+	/* Read Config1 registers */
+	if ((retval = mips32_pracc_cp0_read(ejtag_info, &config1, 16, 1))!= ERROR_OK)
+		return retval;
 
 	switch (KSEGX(addr)) {
 		case KUSEG:
@@ -853,25 +932,199 @@ int mips32_pracc_write_mem(struct mips_ejtag *ejtag_info, uint32_t addr, int siz
 			break;
 	}
 
-	/**
+	/*
 	 * Check cachablitiy bits coherency algorithm
 	 * is the region cacheable or uncached.
 	 * If cacheable we have to synchronize the cache
 	 */
-	if (cached == 3 || cached == 0) {		/* Write back cache or write through cache */
-		uint32_t start_addr = addr;
-		uint32_t end_addr = addr + count * size;
-		uint32_t rel = (conf & MIPS32_CONFIG0_AR_MASK) >> MIPS32_CONFIG0_AR_SHIFT;
-		if (rel > 1) {
-			LOG_DEBUG("Unknown release in cache code");
-			return ERROR_FAIL;
+
+	/* Get core type */
+	cpuType = DetermineCpuTypeFromPrid(prid, conf, config1);
+
+	/* Write back cache or write through cache */
+	if ((cpuType == MIPS_INTERAPTIV) || (cpuType == MIPS_INTERAPTIV_CM)) {
+		if ((cached == CCA_IAPTIV_CWBE) || (cached == CCA_IAPTIV_CWB) || (cached == CCA_WB)) {
+			uint32_t start_addr = addr;
+			uint32_t end_addr = addr + count * size;
+			uint32_t rel = (conf & MIPS32_CONFIG0_AR_MASK) >> MIPS32_CONFIG0_AR_SHIFT;
+			if (rel > 1) {
+				LOG_DEBUG("Unknown release in cache code");
+				return ERROR_FAIL;
+			}
+			retval = mips32_pracc_synchronize_cache(ejtag_info, start_addr, end_addr, cached, rel);
+		}
+	}
+	else {
+		if (cached == 3 || cached == 0) {		/* Write back cache or write through cache */
+			uint32_t start_addr = addr;
+			uint32_t end_addr = addr + count * size;
+			uint32_t rel = (conf & MIPS32_CONFIG0_AR_MASK) >> MIPS32_CONFIG0_AR_SHIFT;
+			if (rel > 1) {
+				LOG_DEBUG("Unknown release in cache code");
+				return ERROR_FAIL;
+			}
+			retval = mips32_pracc_synchronize_cache(ejtag_info, start_addr, end_addr, cached, rel);
 		}
-		retval = mips32_pracc_synchronize_cache(ejtag_info, start_addr, end_addr, cached, rel);
 	}
 
 	return retval;
 }
 
+int mips32_pracc_invalidate_cache(struct target *target, struct mips_ejtag *ejtag_info, int cache)
+{
+	static uint32_t inv_inst_cache[] = {
+
+		/* Determine how big the I$ is */
+		MIPS32_MFC0(t7, 16, 1),						/* C0_Config1 */  	
+		MIPS32_ADDIU(t1, t7, zero),
+		MIPS32_SRL(t1, t7,CFG1_ISSHIFT),
+		MIPS32_ANDI(t1, t1, 0x7),
+		MIPS32_ADDIU(t0, zero, 64),				    /* li t0, 64 */
+		MIPS32_SLLV(t1, t0, t1),				    /* I$ Sets per way */
+
+		MIPS32_SRL(t7, t7,CFG1_IASHIFT),
+		MIPS32_ANDI(t7, t7, 0x7),
+		MIPS32_ADDIU(t7, t7, 1),
+		MIPS32_MUL(t1, t1, t7),					    /* Total number of sets */
+
+		/* Clear TagLo/TagHi registers */
+		MIPS32_MTC0(zero, C0_ITAGLO, 0),		    /* C0_ITagLo */
+		MIPS32_MTC0(zero, C0_ITAGHI, 0),		    /* C0_ITagHi */
+		MIPS32_MFC0(t7, 16, 1),						/* Re-read C0_Config1 */
+
+		/* Isolate I$ Line Size */
+		MIPS32_ADDIU(t0, zero, 2),				    /* li a2, 2 */
+		MIPS32_SRL(t7, t7,CFG1_ILSHIFT),
+		MIPS32_ANDI(t7, t7, 0x7),
+
+		MIPS32_SLLV(t7, t0, t7),					/* Now have true I$ line size in bytes */
+		MIPS32_LUI(t0, 0x8000),					    /* Get a KSeg0 address for cacheops */
+
+		MIPS32_CACHE(Index_Store_Tag_I, 0, t0),
+		MIPS32_ADDI(t1, t1,NEG16(1)),				/* Decrement set counter */
+		MIPS32_BNE(t1, zero, NEG16(3)),
+		MIPS32_ADD(t0, t0, t7),
+	};
+
+    uint32_t inv_data_cache[] = {
+
+        MIPS32_MFC0(t7, 16, 1),						/* read C0_Config1 */
+
+		MIPS32_SRL (t1, t7, CFG1_DSSHIFT),			/* extract DS */
+		MIPS32_ANDI(t1, t1, 0x7),
+		MIPS32_ADDIU(t0, zero, 64),				    /* li t0, 64 */
+		MIPS32_SLLV(t1, t0, t1),					/* D$ Sets per way */
+
+		MIPS32_SRL(t7, t7, CFG1_DASHIFT),			/* extract DA */
+		MIPS32_ANDI(t7, t7, 0x7),
+		MIPS32_ADDIU(t7, t7, 1),
+		MIPS32_MUL(t1, t1, t7),					    /* Total number of sets */
+
+		/* Clear TagLo/TagHi registers */
+		MIPS32_MTC0(zero, C0_TAGLO, 0),				/* write C0_TagLo */
+		MIPS32_MTC0(zero, C0_TAGHI, 0),				/* write C0_TagHi */
+		MIPS32_MTC0(zero, C0_TAGLO, 2),				/* write C0_DTagLo */
+		MIPS32_MTC0(zero, C0_TAGHI, 2),				/* write C0_DTagHi */
+
+		/* Isolate D$ Line Size */
+		MIPS32_MFC0(t7, 16, 1),						/* Re-read C0_Config1 */
+		MIPS32_ADDIU(t0, zero, 2),				    /* li a2, 2 */
+
+		MIPS32_SRL(t7, t7, CFG1_DLSHIFT),			/* extract DL */
+		MIPS32_ANDI(t7, t7, 0x7),
+
+		MIPS32_SLLV(t7, t0, t7),					/* Now have true I$ line size in bytes */
+
+		MIPS32_LUI(t0, 0x8000)					    /* Get a KSeg0 address for cacheops */
+	};
+
+	uint32_t done[] = {
+		MIPS32_LUI(t7, UPPER16(MIPS32_PRACC_TEXT)),
+		MIPS32_ORI(t7, t7, LOWER16(MIPS32_PRACC_TEXT)),
+		MIPS32_JR(t7),							/* jr start */
+		MIPS32_MFC0(t7, 31, 0)						/* move COP0 DeSave to $15 */
+	};
+
+	struct pracc_queue_info ctx = {.max_code = 26+20};	/* alloc memory for the worst case */
+
+	uint32_t conf;
+	uint32_t bpl;
+
+	pracc_queue_init(&ctx);
+	if (ctx.retval != ERROR_OK) {
+		LOG_ERROR("pracc_queue_init failed");
+		goto exit;
+	}
+
+	/* Read Config1 Register to retrieve cache info */
+	mips32_pracc_cp0_read(ejtag_info, &conf, 16, 1);
+
+	switch (cache) {
+		case INST:
+			/* Extract cache line size */
+			bpl	 = (conf >> CFG1_ILSHIFT) & 7; /* bit 21:19 */
+
+			/* Core configured with Instruction cache */
+			if (bpl == 0) {
+				LOG_USER("no instructure cache configured");
+				ctx.retval = ERROR_OK;
+				goto exit;
+			}
+
+			for (unsigned i = 0; i < ARRAY_SIZE(inv_inst_cache); i++)
+				pracc_add(&ctx, 0, inv_inst_cache[i]);
+
+			break;
+
+		case DATA:
+		case ALLNOWB:
+		case DATANOWB:
+			/* Extract cache line size */
+			bpl	 = (conf >> CFG1_DLSHIFT) & 7; /* bit 12:10 */
+
+			/* Core configured with Instruction cache */
+			if (bpl == 0) {
+				LOG_USER("no data cache configured");
+				ctx.retval = ERROR_OK;
+				goto exit;
+ 			}
+
+			/* Write exit code */
+			for (unsigned i = 0; i < ARRAY_SIZE(inv_data_cache); i++)
+				pracc_add(&ctx, 0, inv_data_cache[i]);
+
+			if (cache == DATA)
+				pracc_add(&ctx, 0, MIPS32_CACHE(Index_Writeback_Inv_D, 0, t0));
+			else {
+				if ((cache == ALLNOWB) || (cache == DATANOWB))
+					pracc_add(&ctx, 0, MIPS32_CACHE(Index_Store_Tag_D, 0, t0));
+			}
+
+			pracc_add(&ctx, 0, MIPS32_ADDI(t1, t1,NEG16(1)));				// Decrement set counter
+			pracc_add(&ctx, 0, MIPS32_BNE(t1, zero, NEG16(3)));
+			pracc_add(&ctx, 0, MIPS32_ADD(t0, t0, t7));
+			break;
+
+		case L2:
+			break;
+
+	}
+
+	/* Write exit code */
+	for (unsigned i = 0; i < ARRAY_SIZE(done); i++)
+		pracc_add(&ctx, 0, done[i]);
+
+	/* Start code execution */
+	ctx.code_count = 0; /* Disable pracc access verification due BNZ instruction */
+	ctx.retval = mips32_pracc_queue_exec(ejtag_info, &ctx, NULL);
+	if (ctx.retval != ERROR_OK)
+		LOG_DEBUG("mips32_pracc_queue_exec failed - ctx.retval: %d", ctx.retval);
+
+exit:
+	pracc_queue_free(&ctx);
+	return ctx.retval;
+}
+
 int mips32_pracc_write_regs(struct mips_ejtag *ejtag_info, uint32_t *regs)
 {
 	static const uint32_t cp0_write_code[] = {
@@ -881,15 +1134,24 @@ int mips32_pracc_write_regs(struct mips_ejtag *ejtag_info, uint32_t *regs)
 		MIPS32_MTC0(1, 8, 0),							/* move $1 to badvaddr */
 		MIPS32_MTC0(1, 13, 0),							/* move $1 to cause*/
 		MIPS32_MTC0(1, 24, 0),							/* move $1 to depc (pc) */
+		MIPS32_MTC0(1, 10, 4),							/* move $1 to guestClt1 (pc) */
 	};
+	const int cp0_write_code_len = ARRAY_SIZE(cp0_write_code);
+	const int GPR_BEGIN = 2;
+	const int GPR_END = 32;
+	const int MAX_INST_GPR_1 = 3;
+	const int MAX_INST_GPR_2_THRU_31 = (GPR_END-GPR_BEGIN) * 2;
+	const int MAX_INST_CP0 = cp0_write_code_len * 3;
+	const int MAX_INST_EPILOGUE = 1;  /* currently just a branch */
+
+	struct pracc_queue_info ctx = {.max_code = MAX_INST_GPR_1 + MAX_INST_GPR_2_THRU_31 + MAX_INST_CP0 + MAX_INST_EPILOGUE};
 
-	struct pracc_queue_info ctx = {.max_code = 37 * 2 + 7 + 1};
 	pracc_queue_init(&ctx);
 	if (ctx.retval != ERROR_OK)
 		goto exit;
 
 	/* load registers 2 to 31 with lui and ori instructions, check if some instructions can be saved */
-	for (int i = 2; i < 32; i++) {
+	for (int i = GPR_BEGIN; i < GPR_END; i++) {
 		if (LOWER16((regs[i])) == 0)					/* if lower half word is 0, lui instruction only */
 			pracc_add(&ctx, 0, MIPS32_LUI(i, UPPER16((regs[i]))));
 		else if (UPPER16((regs[i])) == 0)					/* if upper half word is 0, ori with $0 only*/
@@ -900,11 +1162,12 @@ int mips32_pracc_write_regs(struct mips_ejtag *ejtag_info, uint32_t *regs)
 		}
 	}
 
-	for (int i = 0; i != 6; i++) {
-		pracc_add(&ctx, 0, MIPS32_LUI(1, UPPER16((regs[i + 32]))));		/* load CPO value in $1, with lui and ori */
-		pracc_add(&ctx, 0, MIPS32_ORI(1, 1, LOWER16((regs[i + 32]))));
-		pracc_add(&ctx, 0, cp0_write_code[i]);					/* write value from $1 to CPO register */
+	for (int i = GPR_END; i != GPR_END+cp0_write_code_len; i++) {
+		pracc_add(&ctx, 0, MIPS32_LUI(1, UPPER16((regs[i]))));		/* load CPO value in $1, with lui and ori */
+		pracc_add(&ctx, 0, MIPS32_ORI(1, 1, LOWER16((regs[i]))));
+		pracc_add(&ctx, 0, cp0_write_code[i-GPR_END]);					/* write value from $1 to CPO register */
 	}
+
 	pracc_add(&ctx, 0, MIPS32_MTC0(15, 31, 0));				/* load $15 in DeSave */
 	pracc_add(&ctx, 0, MIPS32_LUI(1, UPPER16((regs[1]))));			/* load upper half word in $1 */
 	pracc_add(&ctx, 0, MIPS32_B(NEG16(ctx.code_count + 1)));					/* jump to start */
@@ -919,6 +1182,64 @@ exit:
 	return ctx.retval;
 }
 
+int mips32_pracc_write_fpu_regs(struct mips_ejtag *ejtag_info, uint32_t *regs)
+{
+
+	struct pracc_queue_info ctx = {.max_code = 110};
+
+	pracc_queue_init(&ctx);
+	if (ctx.retval != ERROR_OK)
+		goto exit;
+
+	/* load f0..f31 */
+	for (int i = MIPS32_F0; i < MIPS32_FCSR; i++) {
+		if (LOWER16((regs[i-MIPS32_F0])) == 0)					/* if lower half word is 0, lui instruction only */
+			pracc_add(&ctx, 0, MIPS32_LUI(8, UPPER16((regs[i-MIPS32_F0]))));
+		else if (UPPER16((regs[i-MIPS32_F0])) == 0)					/* if upper half word is 0, ori with $0 only*/
+			pracc_add(&ctx, 0, MIPS32_ORI(8, 0, LOWER16((regs[i-MIPS32_F0]))));
+		else {									/* default, load with lui and ori instructions */
+			pracc_add(&ctx, 0, MIPS32_LUI(8, UPPER16((regs[i-MIPS32_F0]))));
+			pracc_add(&ctx, 0, MIPS32_ORI(8, 8, LOWER16((regs[i-MIPS32_F0]))));
+		}
+
+		pracc_add(&ctx, 0, MIPS32_MTC1(8, (i)));
+
+	}
+
+	/* fcsr */
+	if (LOWER16((regs[MIPS32_FCSR-MIPS32_F0])) == 0)					/* if lower half word is 0, lui instruction only */
+		pracc_add(&ctx, 0, MIPS32_LUI(8, UPPER16((regs[MIPS32_FCSR-MIPS32_F0]))));
+	else if (UPPER16((regs[MIPS32_FCSR-MIPS32_F0])) == 0)					/* if upper half word is 0, ori with $0 only*/
+		pracc_add(&ctx, 0, MIPS32_ORI(8, 8, LOWER16((regs[MIPS32_FCSR-MIPS32_F0]))));
+	else {									/* default, load with lui and ori instructions */
+		pracc_add(&ctx, 0, MIPS32_LUI(8, UPPER16((regs[MIPS32_FCSR-MIPS32_F0]))));
+		pracc_add(&ctx, 0, MIPS32_ORI(8, 8, LOWER16((regs[MIPS32_FCSR-MIPS32_F0]))));
+	}
+
+	pracc_add(&ctx, 0, MIPS32_CTC1(8, 31));
+
+	/* fir */
+	if (LOWER16((regs[MIPS32_FIR])) == 0)					/* if lower half word is 0, lui instruction only */
+		pracc_add(&ctx, 0, MIPS32_LUI(8, UPPER16((regs[MIPS32_FIR-MIPS32_F0]))));
+	else if (UPPER16((regs[MIPS32_FIR])) == 0)					/* if upper half word is 0, ori with $0 only*/
+		pracc_add(&ctx, 0, MIPS32_ORI(8, 8, LOWER16((regs[MIPS32_FIR-MIPS32_F0]))));
+	else {									/* default, load with lui and ori instructions */
+		pracc_add(&ctx, 0, MIPS32_LUI(8, UPPER16((regs[MIPS32_FIR-MIPS32_F0]))));
+		pracc_add(&ctx, 0, MIPS32_ORI(8, 8, LOWER16((regs[MIPS32_FIR-MIPS32_F0]))));
+	}
+
+	pracc_add(&ctx, 0, MIPS32_CTC1(8, 0));
+
+	pracc_add(&ctx, 0, MIPS32_MTC0(15, 31, 0));				/* load $15 in DeSave */
+	pracc_add(&ctx, 0, MIPS32_LUI(1, UPPER16((regs[1]))));			/* load upper half word in $1 */
+	pracc_add(&ctx, 0, MIPS32_B(NEG16(ctx.code_count + 1)));					/* jump to start */
+	pracc_add(&ctx, 0, MIPS32_ORI(1, 1, LOWER16((regs[1]))));		/* load lower half word in $1 */
+
+exit:
+	pracc_queue_free(&ctx);
+	return ctx.retval;
+}
+
 int mips32_pracc_read_regs(struct mips_ejtag *ejtag_info, uint32_t *regs)
 {
 	static int cp0_read_code[] = {
@@ -928,9 +1249,11 @@ int mips32_pracc_read_regs(struct mips_ejtag *ejtag_info, uint32_t *regs)
 		MIPS32_MFC0(8, 8, 0),							/* move badvaddr to $8 */
 		MIPS32_MFC0(8, 13, 0),							/* move cause to $8 */
 		MIPS32_MFC0(8, 24, 0),							/* move depc (pc) to $8 */
+		MIPS32_MFC0(8, 10, 4),							/* move guestClt1  to $8 */
 	};
 
-	struct pracc_queue_info ctx = {.max_code = 49};
+	struct pracc_queue_info ctx = {.max_code = 52};
+
 	pracc_queue_init(&ctx);
 	if (ctx.retval != ERROR_OK)
 		goto exit;
@@ -942,7 +1265,7 @@ int mips32_pracc_read_regs(struct mips_ejtag *ejtag_info, uint32_t *regs)
 		pracc_add(&ctx, MIPS32_PRACC_PARAM_OUT + (i * 4),
 				  MIPS32_SW(i, PRACC_OUT_OFFSET + (i * 4), 1));
 
-	for (int i = 0; i != 6; i++) {
+	for (int i = 0; i != ARRAY_SIZE(cp0_read_code); i++) {
 		pracc_add(&ctx, 0, cp0_read_code[i]);				/* load COP0 needed registers to $8 */
 		pracc_add(&ctx, MIPS32_PRACC_PARAM_OUT + (i + 32) * 4,			/* store $8 at PARAM OUT */
 				  MIPS32_SW(8, PRACC_OUT_OFFSET + (i + 32) * 4, 1));
@@ -952,6 +1275,7 @@ int mips32_pracc_read_regs(struct mips_ejtag *ejtag_info, uint32_t *regs)
 			  MIPS32_SW(8, PRACC_OUT_OFFSET + 4, 1));
 
 	pracc_add(&ctx, 0, MIPS32_MFC0(1, 31, 0));					/* move COP0 DeSave to $1, restore reg1 */
+	pracc_add(&ctx, 0, MIPS32_SYNC);
 	pracc_add(&ctx, 0, MIPS32_B(NEG16(ctx.code_count + 1)));					/* jump to start */
 	pracc_add(&ctx, 0, MIPS32_MTC0(15, 31, 0));					/* load $15 in DeSave */
 
@@ -967,6 +1291,204 @@ exit:
 	return ctx.retval;
 }
 
+int mips32_pracc_read_tlb_entry(struct mips_ejtag *ejtag_info, uint32_t *data, uint32_t index)
+{
+	struct pracc_queue_info ctx = {.max_code = 49};
+
+	pracc_queue_init(&ctx);
+	if (ctx.retval != ERROR_OK)
+		goto exit;
+
+	static int tlb_read_code[] = {
+		MIPS32_MFC0(8, 2, 0),			/* Read C0_ENTRYLO0 */
+		MIPS32_MFC0(8, 3, 0),			/* Read C0_ENTRYLO1 */
+		MIPS32_MFC0(8, 10, 0),			/* Read C0_ENTRYHI */
+		MIPS32_MFC0(8, 5, 0)			/* Read C0_PAGEMASK */
+	};
+
+	pracc_add(&ctx, 0, MIPS32_LUI(15, PRACC_UPPER_BASE_ADDR)); /* $15 = MIP32_PRACC_BASE_ADDR */
+	pracc_add(&ctx, 0, MIPS32_LUI(8, UPPER16(index)));		   /* Load TLB Index to $8 */
+	pracc_add(&ctx, 0, MIPS32_ORI(8, 8, LOWER16(index)));
+
+	pracc_add(&ctx, 0, MIPS32_MTC0(8, 0, 0));				 /* write C0_Index */
+	pracc_add(&ctx, 0, MIPS32_TLBR());						 /* Read TLB entry specified by Index */
+
+
+	for (uint32_t i = 0; i <ARRAY_SIZE(tlb_read_code); i++) {
+		pracc_add(&ctx, 0, tlb_read_code[i]);
+		pracc_add(&ctx, MIPS32_PRACC_PARAM_OUT + (i * 4),
+				  MIPS32_SW(8, PRACC_OUT_OFFSET + (i * 4), 15));
+	}
+
+	pracc_add(&ctx, 0, MIPS32_LUI(8, UPPER16(ejtag_info->reg8)));		/* restore upper 16 of $8 */
+	pracc_add(&ctx, 0, MIPS32_ORI(8, 8, LOWER16(ejtag_info->reg8)));	/* restore lower 16 of $8 */
+
+	pracc_add(&ctx, 0, MIPS32_SYNC);
+	pracc_add(&ctx, 0, MIPS32_B(NEG16(ctx.code_count + 1)));	/* jump to start */
+	pracc_add(&ctx, 0, MIPS32_MTC0(15, 31, 0));					/* load $15 in DeSave */
+
+	ctx.retval = mips32_pracc_queue_exec(ejtag_info, &ctx, data);
+exit:
+	pracc_queue_free(&ctx);
+	return ctx.retval;
+}
+
+int mips32_pracc_read_fpu_regs(struct mips_ejtag *ejtag_info, uint32_t *regs)
+{
+	int i;
+	struct pracc_queue_info ctx = {.max_code = 80};
+
+	pracc_queue_init(&ctx);
+	if (ctx.retval != ERROR_OK)
+		goto exit;
+
+	pracc_add(&ctx, 0, MIPS32_MTC0(1, 31, 0));						/* move $1 to COP0 DeSave */
+	pracc_add(&ctx, 0, MIPS32_LUI(1, PRACC_UPPER_BASE_ADDR));		/* $1 = MIP32_PRACC_BASE_ADDR */
+
+	for (i = 38; i != 70; i++) {
+		pracc_add(&ctx, 0, MIPS32_MFC1(8, (i-38)));						/* load FP registers to $8 */
+		pracc_add(&ctx, MIPS32_PRACC_PARAM_OUT + ((i-38) * 4),		/* store $8 at PARAM OUT */
+				  MIPS32_SW(8, PRACC_OUT_OFFSET + ((i-38) * 4), 1));
+	}
+
+	pracc_add(&ctx, 0, MIPS32_CFC1(8, 31));						/* load FCSR registers to $8 */
+	pracc_add(&ctx, MIPS32_PRACC_PARAM_OUT + ((i-38) * 4),		/* store $8 at PARAM OUT */
+			  MIPS32_SW(8, PRACC_OUT_OFFSET + ((i-38) * 4), 1));
+
+	pracc_add(&ctx, 0, MIPS32_CFC1(8, 0));						/* load FIR registers to $8 */
+	pracc_add(&ctx, MIPS32_PRACC_PARAM_OUT + ((i-38) + 1) * 4,		/* store $8 at PARAM OUT */
+			  MIPS32_SW(8, PRACC_OUT_OFFSET + ((i-38) + 1) * 4, 1));
+
+	pracc_add(&ctx, 0, MIPS32_MFC0(1, 31, 0));					/* move COP0 DeSave to $1, restore reg1 */
+	pracc_add(&ctx, 0, MIPS32_LUI(8, UPPER16(ejtag_info->reg8)));		/* restore upper 16 of $8 */
+	pracc_add(&ctx, 0, MIPS32_ORI(8, 8, LOWER16(ejtag_info->reg8)));	/* restore lower 16 of $8 */
+
+	pracc_add(&ctx, 0, MIPS32_SYNC);
+	pracc_add(&ctx, 0, MIPS32_B(NEG16(ctx.code_count + 1)));	/* jump to start */
+ 
+	pracc_add(&ctx, 0, MIPS32_MTC0(15, 31, 0));					/* load $15 in DeSave */
+
+	if (ejtag_info->mode == 0)
+		ctx.store_count++;	/* Needed by legacy code, due to offset from reg0 */
+
+	ctx.retval = mips32_pracc_queue_exec(ejtag_info, &ctx, regs);
+exit:
+	pracc_queue_free(&ctx);
+	return ctx.retval;
+}
+
+int mips32_pracc_read_dsp_regs(struct mips_ejtag *ejtag_info, uint32_t *val, uint32_t regs)
+{
+	struct pracc_queue_info ctx = {.max_code = 48};
+	static uint32_t dsp_read_code[] = {
+		MIPS32_MFHI (t0),		/* mfhi t0 ($ac0) OPCODE - 0x00004010 */
+		MIPS32_DSP_MFHI (t0, 1),	/* mfhi	t0,$ac1 - OPCODE - 0x00204010 */
+		MIPS32_DSP_MFHI (t0,2), /* mfhi	t0,$ac2 - OPCODE - 0x00404010 */
+		MIPS32_DSP_MFHI (t0,3), /* mfhi	t0,$ac3 - OPCODE - 0x00604010*/
+		MIPS32_MFLO (t0),		/* mflo t0 ($ac0) OPCODE - 0x00004012 */
+		MIPS32_DSP_MFLO (t0,1), /* mflo	t0,$ac1 - OPCODE - 0x00204012 */
+		MIPS32_DSP_MFLO (t0,2), /* mflo	t0,$ac2 - OPCODE - 0x00404012 */
+		MIPS32_DSP_MFLO (t0,3),	/* mflo	t0,$ac3 - OPCODE - 0x00604012 */
+		MIPS32_DSP_RDDSP (t0,0x3F), /* OPCODE - 0x7c3f44b8 */
+	};
+
+	/* check status register to determine if dsp register access is enabled */
+	/* Get status register so it can be restored later */
+
+	/* Init context queue */
+	pracc_queue_init(&ctx);
+	if (ctx.retval != ERROR_OK)
+		goto exit;
+
+	/* Save Status Register */
+	pracc_add(&ctx, 0, MIPS32_MFC0(9, 12, 0));					/* move status to $9 (t1) 2*/
+
+	/* Read it again in order to modify it */
+	pracc_add(&ctx, 0, MIPS32_MFC0(8, 12, 0));					/* move status to $0 (t0) 3*/
+
+	/* Enable access to DSP registers by setting MX bit in status register */
+	pracc_add(&ctx, 0, MIPS32_LUI(15, UPPER16(MIPS32_DSP_ENABLE)));		/* $15 = MIPS32_PRACC_STACK 4/5/6*/
+	pracc_add(&ctx, 0, MIPS32_ORI(15, 15, LOWER16(MIPS32_DSP_ENABLE)));
+	pracc_add(&ctx, 0, MIPS32_OR(8, 8, 15));
+	pracc_add(&ctx, 0, MIPS32_MTC0(8, 12, 0));					/* Enable DSP - update status registers 7*/
+
+	pracc_add(&ctx, 0, dsp_read_code[regs]);					/* move AC or Control to $8 (t0) 8*/
+	pracc_add(&ctx, 0, MIPS32_MTC0(9, 12, 0));					/* Restore status registers to previous setting 9*/
+
+	pracc_add(&ctx, 0, MIPS32_LUI(15, PRACC_UPPER_BASE_ADDR));	/* $15 = MIPS32_PRACC_BASE_ADDR 1*/
+	pracc_add(&ctx, MIPS32_PRACC_PARAM_OUT, MIPS32_SW(8, PRACC_OUT_OFFSET, 15));	/* store $8 to pracc_out 10*/
+
+	pracc_add(&ctx, 0, MIPS32_MFC0(15, 31, 0));							/* move COP0 DeSave to $15 11*/
+	pracc_add(&ctx, 0, MIPS32_LUI(8, UPPER16(ejtag_info->reg8)));		/* restore upper 16 of $8 12*/
+	pracc_add(&ctx, 0, MIPS32_ORI(8, 8, LOWER16(ejtag_info->reg8)));	/* restore lower 16 of $8 13*/
+
+	pracc_add(&ctx, 0, MIPS32_LUI(9, UPPER16(ejtag_info->reg9)));		/* restore upper 16 of $9 14*/
+	pracc_add(&ctx, 0, MIPS32_SYNC);
+	pracc_add(&ctx, 0, MIPS32_B(NEG16(ctx.code_count + 1)));		/* jump to start 18*/
+	pracc_add(&ctx, 0, MIPS32_ORI(9, 9, LOWER16(ejtag_info->reg9)));	/* restore lower 16 of $9 15*/
+
+	ctx.retval = mips32_pracc_queue_exec(ejtag_info, &ctx, val);
+exit:
+	pracc_queue_free(&ctx);
+	return ctx.retval;
+}
+
+int mips32_pracc_write_dsp_regs(struct mips_ejtag *ejtag_info, uint32_t val, uint32_t regs)
+{
+	struct pracc_queue_info ctx = {.max_code = 48};
+	static uint32_t dsp_write_code[] = {
+		MIPS32_MTHI (t0),		/* OPCODE - 0x01000011 */
+		MIPS32_DSP_MTHI (t0,1),	/* OPCODE - 0x01000811 */
+		MIPS32_DSP_MTHI (t0,2),	/* OPCODE - 0x01001011 */
+		MIPS32_DSP_MTHI (t0,3),	/* OPCODE - 0x01001811 */
+		MIPS32_MTLO (t0),		/* OPCODE - 0x01000013 */
+		MIPS32_DSP_MTLO (t0,1), /* OPCODE - 0x01000813 */
+		MIPS32_DSP_MTLO (t0,2),	/* OPCODE - 0x01001013 */
+		MIPS32_DSP_MTLO (t0,3),	/* OPCODE - 0x01001813 */
+		MIPS32_DSP_WRDSP (t0,0x1F),
+	};
+
+	/* Init context queue */
+	pracc_queue_init(&ctx);
+	if (ctx.retval != ERROR_OK)
+		goto exit;
+
+	/* Save Status Register */
+	pracc_add(&ctx, 0, MIPS32_MFC0(9, 12, 0));					/* move status to $9 (t1) */
+
+	/* Read it again in order to modify it */
+	pracc_add(&ctx, 0, MIPS32_MFC0(8, 12, 0));					/* move status to $0 (t0) */
+
+	/* Enable access to DSP registers by setting MX bit in status register */
+	pracc_add(&ctx, 0, MIPS32_LUI(15, UPPER16(MIPS32_DSP_ENABLE)));		/* $15 = MIPS32_PRACC_STACK */
+	pracc_add(&ctx, 0, MIPS32_ORI(15, 15, LOWER16(MIPS32_DSP_ENABLE)));
+	pracc_add(&ctx, 0, MIPS32_OR(8, 8, 15));
+	pracc_add(&ctx, 0, MIPS32_MTC0(8, 12, 0));					/* Enable DSP - update status registers */
+
+	pracc_add(&ctx, 0, MIPS32_LUI(8, UPPER16(val)));			/* Load val to $8 (t0) */
+	pracc_add(&ctx, 0, MIPS32_ORI(8, 8, LOWER16(val)));
+
+	pracc_add(&ctx, 0, dsp_write_code[regs]);					 /* move AC or Control to $8 (t0) */
+
+	pracc_add(&ctx, 0, MIPS32_NOP);								/* nop */
+	pracc_add(&ctx, 0, MIPS32_MTC0(9, 12, 0));					/* Restore status registers to previous setting */
+	pracc_add(&ctx, 0, MIPS32_NOP);								/* nop */
+
+	pracc_add(&ctx, 0, MIPS32_MFC0(15, 31, 0));							/* move COP0 DeSave to $15 */
+	pracc_add(&ctx, 0, MIPS32_LUI(8, UPPER16(ejtag_info->reg8)));		/* restore upper 16 of $8 */
+	pracc_add(&ctx, 0, MIPS32_ORI(8, 8, LOWER16(ejtag_info->reg8)));	/* restore lower 16 of $8 */
+
+	pracc_add(&ctx, 0, MIPS32_LUI(9, UPPER16(ejtag_info->reg9)));		/* restore upper 16 of $9 */
+
+	pracc_add(&ctx, 0, MIPS32_B(NEG16(ctx.code_count + 1)));		/* jump to start */
+	pracc_add(&ctx, 0, MIPS32_ORI(9, 9, LOWER16(ejtag_info->reg9)));	/* restore lower 16 of $9 */
+
+	ctx.retval = mips32_pracc_queue_exec(ejtag_info, &ctx, NULL);
+exit:
+	pracc_queue_free(&ctx);
+	return ctx.retval;
+}
+
 /* fastdata upload/download requires an initialized working area
  * to load the download code; it should not be called otherwise
  * fetch order from the fastdata area
@@ -1016,8 +1538,10 @@ int mips32_pracc_fastdata_xfer(struct mips_ejtag *ejtag_info, struct working_are
 	int retval, i;
 	uint32_t val, ejtag_ctrl, address;
 
-	if (source->size < MIPS32_FASTDATA_HANDLER_SIZE)
+	if (source->size < MIPS32_FASTDATA_HANDLER_SIZE) {
+		LOG_DEBUG("source->size (%x) < MIPS32_FASTDATA_HANDLER_SIZE", source->size);
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	}
 
 	if (write_t) {
 		handler_code[8] = MIPS32_LW(11, 0, 8);	/* load data from probe at fastdata area */
@@ -1030,6 +1554,7 @@ int mips32_pracc_fastdata_xfer(struct mips_ejtag *ejtag_info, struct working_are
 	/* write program into RAM */
 	if (write_t != ejtag_info->fast_access_save) {
 		mips32_pracc_write_mem(ejtag_info, source->address, 4, ARRAY_SIZE(handler_code), handler_code);
+
 		/* save previous operation to speed to any consecutive read/writes */
 		ejtag_info->fast_access_save = write_t;
 	}
@@ -1041,8 +1566,10 @@ int mips32_pracc_fastdata_xfer(struct mips_ejtag *ejtag_info, struct working_are
 
 	for (i = 0; i < (int) ARRAY_SIZE(jmp_code); i++) {
 		retval = wait_for_pracc_rw(ejtag_info, &ejtag_ctrl);
-		if (retval != ERROR_OK)
+		if (retval != ERROR_OK) {
+			LOG_DEBUG("wait_for_pracc_rw failed - retval = %d", retval);
 			return retval;
+		}
 
 		mips_ejtag_set_instr(ejtag_info, EJTAG_INST_DATA);
 		mips_ejtag_drscan_32_out(ejtag_info, jmp_code[i]);
@@ -1055,18 +1582,24 @@ int mips32_pracc_fastdata_xfer(struct mips_ejtag *ejtag_info, struct working_are
 
 	/* wait PrAcc pending bit for FASTDATA write */
 	retval = wait_for_pracc_rw(ejtag_info, &ejtag_ctrl);
-	if (retval != ERROR_OK)
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("wait_for_pracc_rw failed - retval: %d", retval);
 		return retval;
+	}
 
 	/* next fetch to dmseg should be in FASTDATA_AREA, check */
 	address = 0;
 	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_ADDRESS);
 	retval = mips_ejtag_drscan_32(ejtag_info, &address);
-	if (retval != ERROR_OK)
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("mips_ejtag_drscan_32 failed - retval: %d", retval);
 		return retval;
+	}
 
-	if (address != MIPS32_PRACC_FASTDATA_AREA)
+	if (address != MIPS32_PRACC_FASTDATA_AREA) {
+		LOG_DEBUG("address != MIPS32_PRACC_FASTDATA_AREA (0x%8.8x) - 0x%8.8x", MIPS32_PRACC_FASTDATA_AREA, address);
 		return ERROR_FAIL;
+	}
 
 	/* Send the load start address */
 	val = addr;
diff --git b/src/target/mips32_pracc.h a/src/target/mips32_pracc.h
index eab5f73ec..b9785be4f 100644
--- b/src/target/mips32_pracc.h
+++ a/src/target/mips32_pracc.h
@@ -51,23 +51,53 @@ struct pracc_queue_info {
 	int store_count;
 	uint32_t *pracc_list;	/* Code and store addresses */
 };
+int mips32_pracc_invalidate_cache(struct target *, struct mips_ejtag *, int cache);
 void pracc_queue_init(struct pracc_queue_info *ctx);
 void pracc_add(struct pracc_queue_info *ctx, uint32_t addr, uint32_t instr);
 void pracc_queue_free(struct pracc_queue_info *ctx);
 int mips32_pracc_queue_exec(struct mips_ejtag *ejtag_info,
-			    struct pracc_queue_info *ctx, uint32_t *buf);
+							struct pracc_queue_info *ctx, uint32_t *buf);
 
 int mips32_pracc_read_mem(struct mips_ejtag *ejtag_info,
-		uint32_t addr, int size, int count, void *buf);
+						  uint32_t addr, int size, int count, void *buf, int cputype);
 int mips32_pracc_write_mem(struct mips_ejtag *ejtag_info,
 		uint32_t addr, int size, int count, const void *buf);
 int mips32_pracc_fastdata_xfer(struct mips_ejtag *ejtag_info, struct working_area *source,
 		int write_t, uint32_t addr, int count, uint32_t *buf);
 
+int mips32_pracc_exec(struct mips_ejtag *ejtag_info, struct pracc_queue_info *ctx, uint32_t *param_out);
+
 int mips32_pracc_read_regs(struct mips_ejtag *ejtag_info, uint32_t *regs);
+
+int mips32_pracc_read_tlb_entry(struct mips_ejtag *ejtag_info, uint32_t *data, uint32_t index);
+
+/**
+ * \b mips32_read_fpu_regs
+ *
+ * Simulates mfc1 ASM instruction (Move From COP1),
+ * i.e. implements copro C1 Register read.
+ *
+ * @param[in] ejtag_info
+ * @param[in] val Storage to hold read fpu value
+ *
+ * @return ERROR_OK on Sucess, ERROR_FAIL otherwise
+ */
+int mips32_pracc_read_fpu_regs(struct mips_ejtag *ejtag_info, uint32_t *regs);
+
 int mips32_pracc_write_regs(struct mips_ejtag *ejtag_info, uint32_t *regs);
 
-int mips32_pracc_exec(struct mips_ejtag *ejtag_info, struct pracc_queue_info *ctx, uint32_t *param_out);
+/**
+ * \b mips32_write_fpu_regs
+ *
+ * Simulates mfc1 ASM instruction (Move to COP1),
+ * i.e. implements copro C1 Register write.
+ *
+ * @param[in] ejtag_info
+ * @param[in] pointers to Stored fpu registers values
+ *
+ * @return ERROR_OK on Sucess, ERROR_FAIL otherwise
+ */
+int mips32_pracc_write_fpu_regs(struct mips_ejtag *ejtag_info, uint32_t *regs);
 
 /**
  * \b mips32_cp0_read
@@ -82,7 +112,7 @@ int mips32_pracc_exec(struct mips_ejtag *ejtag_info, struct pracc_queue_info *ct
  *
  * @return ERROR_OK on Sucess, ERROR_FAIL otherwise
  */
-int mips32_cp0_read(struct mips_ejtag *ejtag_info,
+int mips32_pracc_cp0_read(struct mips_ejtag *ejtag_info,
 		uint32_t *val, uint32_t cp0_reg, uint32_t cp0_sel);
 
 /**
@@ -98,7 +128,38 @@ int mips32_cp0_read(struct mips_ejtag *ejtag_info,
  *
  * @return ERROR_OK on Sucess, ERROR_FAIL otherwise
  */
-int mips32_cp0_write(struct mips_ejtag *ejtag_info,
-		uint32_t val, uint32_t cp0_reg, uint32_t cp0_sel);
+int mips32_pracc_cp0_write(struct mips_ejtag *ejtag_info,
+					 uint32_t val, uint32_t cp0_reg, uint32_t cp0_sel);
+
+/**
+ * \b mips32_dsp_read
+ *
+ * Simulates mfc0 ASM instruction (Move From C0),
+ * i.e. implements copro C0 Register read.
+ *
+ * @param[in] ejtag_info
+ * @param[in] val Storage to hold read value
+ * @param[in] cp0_reg Number of copro C0 register we want to read
+ * @param[in] cp0_sel Select for the given C0 register
+ *
+ * @return ERROR_OK on Sucess, ERROR_FAIL otherwise
+ */
+int mips32_pracc_read_dsp_regs(struct mips_ejtag *ejtag_info,
+							   uint32_t *val, uint32_t regs);
 
+/**
+ * \b mips32_dsp_write
+ *
+ * Simulates mtc0 ASM instruction (Move To C0),
+ * i.e. implements copro C0 Register write.
+ *
+ * @param[in] ejtag_info
+ * @param[in] val Value to be written
+ * @param[in] cp0_reg Number of copro C0 register we want to write to
+ * @param[in] cp0_sel Select for the given C0 register
+ *
+ * @return ERROR_OK on Sucess, ERROR_FAIL otherwise
+ */
+int mips32_pracc_write_dsp_regs(struct mips_ejtag *ejtag_info,
+								uint32_t val, uint32_t regs);
 #endif
diff --git b/src/target/mips_common.c a/src/target/mips_common.c
new file mode 100644
index 000000000..a9428b526
--- /dev/null
+++ a/src/target/mips_common.c
@@ -0,0 +1,1429 @@
+/***************************************************************************
+ *	 Copyright (C) 2008 by Spencer Oliver								   *
+ *	 spen@spen-soft.co.uk												   *
+ *																		   *
+ *	 Copyright (C) 2008 by David T.L. Wong								   *
+ *																		   *
+ *	 Copyright (C) 2009 by David N. Claffey <dnclaffey@gmail.com>		   *
+ *																		   *
+ *	 Copyright (C) 2011 by Drasko DRASKOVIC								   *
+ *	 drasko.draskovic@gmail.com											   *
+ *																		   *
+ *	 Copyright (C) 2014 by Kent Brinkley								   *
+ *	 jkbrinkley_imgtec@gmail.com										   *
+ *																		   *
+ *	 This program is free software; you can redistribute it and/or modify  *
+ *	 it under the terms of the GNU General Public License as published by  *
+ *	 the Free Software Foundation; either version 2 of the License, or	   *
+ *	 (at your option) any later version.								   *
+ *																		   *
+ *	 This program is distributed in the hope that it will be useful,	   *
+ *	 but WITHOUT ANY WARRANTY; without even the implied warranty of		   *
+ *	 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the		   *
+ *	 GNU General Public License for more details.						   *
+ *																		   *
+ *	 You should have received a copy of the GNU General Public License	   *
+ *	 along with this program; if not, write to the						   *
+ *	 Free Software Foundation, Inc.,									   *
+ *																		   *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "breakpoints.h"
+#include "mips32.h"
+#include "mips_common.h"
+#include "mips32_dmaacc.h"
+#include "target_type.h"
+#include "register.h"
+
+void mips_common_enable_breakpoints(struct target *target);
+void mips_common_enable_watchpoints(struct target *target);
+int mips_common_set_breakpoint(struct target *target,
+						struct breakpoint *breakpoint);
+int mips_common_unset_breakpoint(struct target *target,
+						  struct breakpoint *breakpoint);
+int mips_common_internal_restore(struct target *target, int current,
+						  uint32_t address, int handle_breakpoints,
+						  int debug_execution);
+int mips_common_bulk_write_memory(struct target *target, uint32_t address,
+						   uint32_t count, const uint8_t *buffer);
+
+
+struct mips_common *target_to_mips_common(struct target *target)
+{
+	return container_of(target->arch_info,
+			struct mips_common, mips32);
+}
+
+
+/**
+ * Handles requests to an MIPs FDC interface.  If semi-hosting messaging is enabled,
+ * the target is running, EJTAG DCR FDC implemented (bit 18) and Config3 CDMM (Common
+ * Device Memory Map Feature is implemented (bit 3), this will execute the request 
+ * from the target.
+ *
+ * @param priv Void pointer expected to be a struct target pointer
+ * @return ERROR_OK unless there are issues with the JTAG queue or when reading
+ * from the Embedded ICE unit
+ */
+int mips_common_handle_target_request(void *priv)
+{
+	int retval = ERROR_OK;
+	struct scan_field fields;
+	tap_state_t endstate;
+	struct target *target = priv;
+	void *t = malloc(5);
+	void *r = malloc(5);
+
+	if (!target_was_examined(target)) {
+		LOG_DEBUG("Target not examined yet");
+		return ERROR_OK;
+	}
+
+	struct mips32_common *mips32 = target_to_mips32(target);
+	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
+	unsigned long long fdc_data = 0;
+
+	if (target->state == TARGET_RUNNING) {
+
+		if (mips32->semihosting == ENABLE_SEMIHOSTING) {
+			// currently mips32->semihosting implies mips32->fdc also
+			// (mips32->fdc is prerequisite for mips32->semihosting from becoming true
+			int i=0;
+			do {
+				const char *str = "0x2000000000";
+				mips_ejtag_set_instr(ejtag_info, EJTAG_INST_FDC);
+
+				endstate = TAP_IDLE;
+				fields.num_bits = 38;
+				fields.out_value = t;
+
+				str_to_buf(str, 12, t, 38, 0);
+
+				fields.in_value = r;
+				jtag_add_dr_scan(target->tap, 1, &fields, endstate);
+
+				retval = jtag_execute_queue();
+				if (retval != ERROR_OK)
+					return retval;
+
+				fdc_data = buf_get_u38(fields.in_value, 0, 38);
+				fdc_data &= 0x3FFFFFFFFF;
+
+				if ((((fdc_data >> 36) & 1) == 1)) {
+					uint8_t *fdc_char = (void *) &fdc_data;
+					printf ("%.4s", fdc_char);
+					fflush(stdout);
+				}
+
+				/* Break after processing 16 32-bit word */
+				if (i >= 16)
+					break;
+				else i++;
+
+			} while (((fdc_data >> 36) & 1) == 1);
+		}
+	}
+
+	return ERROR_OK;
+}
+
+int mips_common_examine_debug_reason(struct target *target)
+{
+	struct mips32_common *mips32 = target_to_mips32(target);
+	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
+	uint32_t break_status;
+	int retval;
+
+	if ((target->debug_reason != DBG_REASON_DBGRQ)
+			&& (target->debug_reason != DBG_REASON_SINGLESTEP)) {
+		if (ejtag_info->debug_caps & EJTAG_DCR_IB) {
+			/* get info about inst breakpoint support */
+			retval = target_read_u32(target, ejtag_info->ejtag_ibs_addr, &break_status);
+			if (retval != ERROR_OK) {
+				LOG_DEBUG("target_read_u32 failed");
+				return retval;
+			}
+
+			if (break_status & 0x1f) {
+				/* we have halted on a	breakpoint */
+				retval = target_write_u32(target, ejtag_info->ejtag_ibs_addr, 0);
+				if (retval != ERROR_OK) {
+					LOG_DEBUG("target_write_u32 failed");
+					return retval;
+				}
+
+				target->debug_reason = DBG_REASON_BREAKPOINT;
+			}
+		}
+
+		if (ejtag_info->debug_caps & EJTAG_DCR_DB) {
+			/* get info about data breakpoint support */
+			retval = target_read_u32(target, ejtag_info->ejtag_dbs_addr, &break_status);
+			if (retval != ERROR_OK) {
+				LOG_DEBUG("target_read_u32 failed");
+				return retval;
+			}
+
+			if (break_status & 0x1f) {
+				/* we have halted on a	breakpoint */
+				retval = target_write_u32(target, ejtag_info->ejtag_dbs_addr, 0);
+				if (retval != ERROR_OK) {
+					LOG_DEBUG("target_write_u32 failed");
+					return retval;
+				}
+
+				target->debug_reason = DBG_REASON_WATCHPOINT;
+			}
+		}
+	}
+
+	return ERROR_OK;
+}
+
+int mips_common_debug_entry(struct target *target, int echo)
+{
+	struct mips32_common *mips32 = target_to_mips32(target);
+	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
+
+	int retval = mips32_save_context(target);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("mips32_save_context failed");
+		return retval;
+	}
+
+	/* make sure stepping disabled, SSt bit in CP0 debug register cleared */
+	retval = mips_ejtag_config_step(ejtag_info, 0);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("mips_ejtag_config_step failed");
+		return retval;
+	}
+
+	/* make sure break unit configured */
+	retval = mips32_configure_break_unit(target);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("mips32_configure_break_unit failed");
+		return retval;
+	}
+
+	/* attempt to find halt reason */
+	retval = mips_common_examine_debug_reason(target);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* default to mips32 isa, it will be changed below if required */
+	mips32->isa_mode = buf_get_u32(mips32->core_cache->reg_list[MIPS32_PC].value, 0, 1);
+
+	/* Echo message during single step ? */
+	if (echo == 1) {
+		LOG_DEBUG("entered debug state at PC 0x%" PRIx32 ", target->state: %s",
+				  buf_get_u32(mips32->core_cache->reg_list[MIPS32_PC].value, 0, 32),
+				  target_state_name(target));
+	}
+	return ERROR_OK;
+}
+
+struct target *get_mips_common_core(struct target *target, int32_t coreid)
+{
+	struct target_list *head;
+	struct target *curr;
+
+	head = target->head;
+	while (head != (struct target_list *)NULL) {
+		curr = head->target;
+		if ((curr->coreid == coreid) && (curr->state == TARGET_HALTED))
+			return curr;
+		head = head->next;
+	}
+	return target;
+}
+
+int mips_common_halt_smp(struct target *target)
+{
+	int retval = ERROR_OK;
+	struct target_list *head;
+	struct target *curr;
+	head = target->head;
+	while (head != (struct target_list *)NULL) {
+		int ret = ERROR_OK;
+		curr = head->target;
+		if ((curr != target) && (curr->state != TARGET_HALTED))
+			ret = mips_common_halt(curr);
+
+		if (ret != ERROR_OK) {
+			LOG_ERROR("halt failed target->coreid: %" PRId32, curr->coreid);
+			retval = ret;
+		}
+		head = head->next;
+	}
+	return retval;
+}
+
+int update_halt_gdb(struct target *target)
+{
+	int retval = ERROR_OK;
+	if (target->gdb_service->core[0] == -1) {
+		target->gdb_service->target = target;
+		target->gdb_service->core[0] = target->coreid;
+		retval = mips_common_halt_smp(target);
+	}
+	return retval;
+}
+
+int mips_common_poll(struct target *target)
+{
+	int retval = ERROR_OK;
+	struct mips32_common *mips32 = target_to_mips32(target);
+	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
+	uint32_t ejtag_ctrl = ejtag_info->ejtag_ctrl;
+	enum target_state prev_target_state = target->state;
+
+	/*	toggle to another core is done by gdb as follow */
+	/*	maint packet J core_id */
+	/*	continue */
+	/*	the next polling trigger an halt event sent to gdb */
+	if ((target->state == TARGET_HALTED) && (target->smp) &&
+		(target->gdb_service) &&
+		(target->gdb_service->target == NULL)) {
+		target->gdb_service->target =
+			get_mips_common_core(target, target->gdb_service->core[1]);
+		target_call_event_callbacks(target, TARGET_EVENT_HALTED);
+		return retval;
+	}
+
+	/* read ejtag control reg */
+	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL);
+	retval = mips_ejtag_drscan_32(ejtag_info, &ejtag_ctrl);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("mips_ejtag_drscan_32 failed: ejtag_ctrl = 0x%8.8x", ejtag_ctrl);
+		return retval;
+	}
+
+	/* clear this bit before handling polling
+	 * as after reset registers will read zero */
+	if (ejtag_ctrl & EJTAG_CTRL_ROCC) {
+		/* we have detected a reset, clear flag
+		 * otherwise ejtag will not work */
+		ejtag_ctrl = ejtag_info->ejtag_ctrl & ~EJTAG_CTRL_ROCC;
+
+		mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL);
+		retval = mips_ejtag_drscan_32(ejtag_info, &ejtag_ctrl);
+		if (retval != ERROR_OK) {
+			LOG_DEBUG("mips_ejtag_drscan_32 failed: ejtag_ctrl");
+			return retval;
+		}
+
+		LOG_DEBUG("Reset Detected");
+
+		/* Marked register cache invalid if reset detected */
+		register_cache_invalidate(mips32->core_cache);
+
+		target->state = TARGET_RESET;
+		target->debug_reason = DBG_REASON_DBGRQ;
+
+		target_call_event_callbacks(target, TARGET_EVENT_HALTED);
+	}
+
+	/* check for processor halted */
+	if (ejtag_ctrl & EJTAG_CTRL_BRKST) {
+		if ((target->state != TARGET_HALTED)
+			&& (target->state != TARGET_DEBUG_RUNNING)) {
+			LOG_DEBUG("target->state != TARGET_HALTED && target->state != TARGET_DEBUG_RUNNING");
+			LOG_DEBUG("target->state: 0x%x", target->state);
+			if (target->state == TARGET_UNKNOWN)
+				LOG_DEBUG("EJTAG_CTRL_BRKST already set during server startup.");
+
+			/* OpenOCD was was probably started on the board with EJTAG_CTRL_BRKST already set
+			 * (maybe put on by HALT-ing the board in the previous session).
+			 *
+			 * Force enable debug entry for this session.
+			 */
+			mips_ejtag_set_instr(ejtag_info, EJTAG_INST_NORMALBOOT);
+			target->state = TARGET_HALTED;
+
+			retval = mips_common_debug_entry(target, 1);
+			if (retval != ERROR_OK) {
+				LOG_DEBUG("mips_common_debug_entry failed");
+				return retval;
+			}
+
+			/* Get cpu config info */
+			mips32_read_cpu_config_info (target);
+
+			if (target->smp && ((prev_target_state == TARGET_RUNNING)
+								|| (prev_target_state == TARGET_RESET))) {
+				retval = update_halt_gdb(target);
+				if (retval != ERROR_OK) {
+					LOG_DEBUG("update_halt_gdb failed");
+					return retval;
+				}
+			}
+
+			target_call_event_callbacks(target, TARGET_EVENT_HALTED);
+		} else if (target->state == TARGET_DEBUG_RUNNING) {
+			target->state = TARGET_HALTED;
+
+			retval = mips_common_debug_entry(target, 1);
+			if (retval != ERROR_OK) {
+				LOG_DEBUG("mips_debug_entry failed");
+				return retval;
+			}
+
+			if (target->smp) {
+				retval = update_halt_gdb(target);
+				if (retval != ERROR_OK) {
+					LOG_DEBUG("update_halt_gdb failed");
+					return retval;
+				}
+			}
+
+			target_call_event_callbacks(target, TARGET_EVENT_DEBUG_HALTED);
+		}
+	} else
+		target->state = TARGET_RUNNING;
+
+	return ERROR_OK;
+}
+
+int mips_common_halt(struct target *target)
+{
+	struct mips32_common *mips32 = target_to_mips32(target);
+	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
+
+	LOG_DEBUG("target->state: %s", target_state_name(target));
+
+	if (target->state == TARGET_HALTED) {
+		LOG_USER("target was already halted");
+		return ERROR_OK;
+	}
+
+	if (target->state == TARGET_UNKNOWN)
+		LOG_WARNING("target was in unknown state when halt was requested");
+
+	if (target->state == TARGET_RESET) {
+		if ((jtag_get_reset_config() & RESET_SRST_PULLS_TRST) && jtag_get_srst()) {
+			LOG_ERROR("can't request a halt while in reset if nSRST pulls nTRST");
+			return ERROR_TARGET_FAILURE;
+		} else {
+			/* we came here in a reset_halt or reset_init sequence
+			 * debug entry was already prepared in mips_assert_reset()
+			 */
+			target->debug_reason = DBG_REASON_DBGRQ;
+
+			return ERROR_OK;
+		}
+	}
+
+	/* break processor */
+	mips_ejtag_enter_debug(ejtag_info);
+
+	target->debug_reason = DBG_REASON_DBGRQ;
+
+	return ERROR_OK;
+}
+
+int mips_common_assert_reset(struct target *target)
+{
+	struct mips_common *mips32 = target_to_mips_common(target);
+	struct mips_ejtag *ejtag_info = &mips32->mips32.ejtag_info;
+
+	LOG_DEBUG("target->state: %s", target_state_name(target));
+	uint32_t ejtag_ctrl = ejtag_info->ejtag_ctrl;
+
+	enum reset_types jtag_reset_config = jtag_get_reset_config();
+
+	/* some cores support connecting while srst is asserted
+	 * use that mode is it has been configured */
+
+	bool srst_asserted = false;
+
+	if (!(jtag_reset_config & RESET_SRST_PULLS_TRST) &&
+			(jtag_reset_config & RESET_SRST_NO_GATING)) {
+		jtag_add_reset(0, 1);
+		srst_asserted = true;
+	}
+
+	/* EJTAG before v2.5/2.6 does not support EJTAGBOOT or NORMALBOOT */
+	if (ejtag_info->ejtag_version != EJTAG_VERSION_20) {
+		if (target->reset_halt) {
+			/* use hardware to catch reset */
+			mips_ejtag_set_instr(ejtag_info, EJTAG_INST_EJTAGBOOT);
+		} else
+			mips_ejtag_set_instr(ejtag_info, EJTAG_INST_NORMALBOOT);
+	}
+
+	if (jtag_reset_config & RESET_HAS_SRST) {
+		/* here we should issue a srst only, but we may have to assert trst as well */
+		if (jtag_reset_config & RESET_SRST_PULLS_TRST)
+			jtag_add_reset(1, 1);
+		else if (!srst_asserted)
+			jtag_add_reset(0, 1);
+	} 
+
+	if (mips32->is_pic32) {
+		LOG_DEBUG("Using MTAP reset to reset processor...");
+
+		/* use microchip specific MTAP reset */
+		mips_ejtag_set_instr(ejtag_info, MTAP_SW_MTAP);
+		mips_ejtag_set_instr(ejtag_info, MTAP_COMMAND);
+
+		mips_ejtag_drscan_8_out(ejtag_info, MCHP_ASERT_RST);
+		mips_ejtag_drscan_8_out(ejtag_info, MCHP_DE_ASSERT_RST);
+		mips_ejtag_set_instr(ejtag_info, MTAP_SW_ETAP);
+		if (target->reset_halt) {
+			mips_ejtag_set_instr(ejtag_info, 0x0c);
+		}
+	} else {
+		/* use ejtag reset - not supported by all cores */
+		ejtag_ctrl = ejtag_info->ejtag_ctrl | EJTAG_CTRL_PRRST | EJTAG_CTRL_PERRST;
+		LOG_DEBUG("Using EJTAG reset (PRRST) to reset processor...");
+		mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL);
+		mips_ejtag_drscan_32_out(ejtag_info, ejtag_ctrl);
+	}
+
+	target->state = TARGET_RESET;
+	jtag_add_sleep(50000);
+
+	register_cache_invalidate(mips32->mips32.core_cache);
+
+	if (target->reset_halt) {
+
+		int retval = target_halt(target);
+		if (retval != ERROR_OK)
+			return retval;
+	}
+
+	return ERROR_OK;
+}
+
+int mips_common_deassert_reset(struct target *target)
+{
+	LOG_DEBUG("target->state: %s", target_state_name(target));
+
+	/* deassert reset lines */
+	jtag_add_reset(0, 0);
+
+	return ERROR_OK;
+}
+
+int mips_common_single_step_core(struct target *target)
+{
+	LOG_DEBUG ("single_step_core");
+	struct mips32_common *mips32 = target_to_mips32(target);
+	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
+
+	/* configure single step mode */
+	int retval = mips_ejtag_config_step(ejtag_info, 1);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("mips_ejtag_config_step failed");
+		return retval;
+	}
+
+	/* disable interrupts while stepping */
+	retval = mips32_enable_interrupts(target, 0);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("mips32_enable_interrupts failed");
+		return retval;
+	}
+
+	/* exit debug mode */
+	retval = mips_ejtag_exit_debug(ejtag_info);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("mips_ejtag_exit_debug failed");
+		return retval;
+	}
+
+	retval = mips_common_debug_entry(target, 0);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("mips_common_debug_entry failed");
+		return retval;
+	}
+
+	return ERROR_OK;
+}
+
+int mips_common_restore_smp(struct target *target, uint32_t address, int handle_breakpoints)
+{
+	int retval = ERROR_OK;
+	struct target_list *head;
+	struct target *curr;
+
+	head = target->head;
+	while (head != (struct target_list *)NULL) {
+		int ret = ERROR_OK;
+		curr = head->target;
+		if ((curr != target) && (curr->state != TARGET_RUNNING)) {
+			/*	resume current address , not in step mode */
+			ret = mips_common_internal_restore(curr, 1, address, handle_breakpoints, 0);
+
+			if (ret != ERROR_OK) {
+				LOG_ERROR("target->coreid :%" PRId32 " failed to resume at address :0x%" PRIx32,
+						  curr->coreid, address);
+				retval = ret;
+			}
+		}
+		head = head->next;
+	}
+	return retval;
+}
+
+int mips_common_internal_restore(struct target *target, int current,
+		uint32_t address, int handle_breakpoints, int debug_execution)
+{
+	struct mips32_common *mips32 = target_to_mips32(target);
+	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
+	struct breakpoint *breakpoint = NULL;
+	uint32_t resume_pc;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_WARNING("target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	if (!debug_execution) {
+		target_free_all_working_areas(target);
+		mips_common_enable_breakpoints(target);
+		mips_common_enable_watchpoints(target);
+	}
+
+	/* current = 1: continue on current pc, otherwise continue at <address> */
+	if (!current) {
+		buf_set_u32(mips32->core_cache->reg_list[MIPS32_PC].value, 0, 32, address);
+		mips32->core_cache->reg_list[MIPS32_PC].dirty = 1;
+		mips32->core_cache->reg_list[MIPS32_PC].valid = 1;
+	}
+
+	if (ejtag_info->impcode & EJTAG_IMP_MIPS16)
+		buf_set_u32(mips32->core_cache->reg_list[MIPS32_PC].value, 0, 1, mips32->isa_mode);
+
+	if (!current)
+		resume_pc = address;
+	else
+		resume_pc = buf_get_u32(mips32->core_cache->reg_list[MIPS32_PC].value, 0, 32);
+
+	mips32_restore_context(target);
+
+	/* the front-end may request us not to handle breakpoints */
+	if (handle_breakpoints) {
+		/* Single step past breakpoint at current address */
+		breakpoint = breakpoint_find(target, resume_pc);
+		if (breakpoint) {
+			LOG_DEBUG("unset breakpoint at 0x%8.8" PRIx32 "", breakpoint->address);
+			mips_common_unset_breakpoint(target, breakpoint);
+			mips_common_single_step_core(target);
+			mips_common_set_breakpoint(target, breakpoint);
+		}
+	}
+
+	/* enable interrupts if we are running */
+	mips32_enable_interrupts(target, !debug_execution);
+
+	/* exit debug mode */
+	mips_ejtag_exit_debug(ejtag_info);
+	target->debug_reason = DBG_REASON_NOTHALTED;
+
+	/* registers are now invalid */
+	register_cache_invalidate(mips32->core_cache);
+
+	if (!debug_execution) {
+		target->state = TARGET_RUNNING;
+		target_call_event_callbacks(target, TARGET_EVENT_RESUMED);
+		LOG_DEBUG("target resumed at 0x%" PRIx32 "", resume_pc);
+	} else {
+		target->state = TARGET_DEBUG_RUNNING;
+		target_call_event_callbacks(target, TARGET_EVENT_DEBUG_RESUMED);
+		LOG_DEBUG("target debug resumed at 0x%" PRIx32 "", resume_pc);
+	}
+
+	return ERROR_OK;
+}
+
+int mips_common_resume(struct target *target, int current,
+		uint32_t address, int handle_breakpoints, int debug_execution)
+{
+	int retval = ERROR_OK;
+
+	/* dummy resume for smp toggle in order to reduce gdb impact  */
+	if ((target->smp) && (target->gdb_service->core[1] != -1)) {
+		/*	 simulate a start and halt of target */
+		target->gdb_service->target = NULL;
+		target->gdb_service->core[0] = target->gdb_service->core[1];
+		/*	fake resume at next poll we play the  target core[1], see poll*/
+		target_call_event_callbacks(target, TARGET_EVENT_RESUMED);
+		return retval;
+	}
+
+	retval = mips_common_internal_restore(target, current, address,
+										  handle_breakpoints,
+										  debug_execution);
+
+	if (retval == ERROR_OK && target->smp) {
+		target->gdb_service->core[0] = -1;
+		retval = mips_common_restore_smp(target, address, handle_breakpoints);
+	}
+
+	return retval;
+}
+
+int mips_common_step(struct target *target, int current,
+					 uint32_t address, int handle_breakpoints)
+{
+	/* get pointers to arch-specific information */
+	struct mips32_common *mips32 = target_to_mips32(target);
+	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
+	struct breakpoint *breakpoint = NULL;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_WARNING("target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	/* current = 1: continue on current pc, otherwise continue at <address> */
+	if (!current) {
+		buf_set_u32(mips32->core_cache->reg_list[MIPS32_PC].value, 0, 32, address);
+		mips32->core_cache->reg_list[MIPS32_PC].dirty = 1;
+		mips32->core_cache->reg_list[MIPS32_PC].valid = 1;
+	}
+
+	/* the front-end may request us not to handle breakpoints */
+	if (handle_breakpoints) {
+		breakpoint = breakpoint_find(target,
+						buf_get_u32(mips32->core_cache->reg_list[MIPS32_PC].value, 0, 32));
+		if (breakpoint)
+			mips_common_unset_breakpoint(target, breakpoint);
+	}
+
+	/* restore context */
+	mips32_restore_context(target);
+
+	/* configure single step mode */
+	mips_ejtag_config_step(ejtag_info, 1);
+
+	target->debug_reason = DBG_REASON_SINGLESTEP;
+
+	target_call_event_callbacks(target, TARGET_EVENT_RESUMED);
+
+	/* disable interrupts while stepping */
+	mips32_enable_interrupts(target, 0);
+
+	/* exit debug mode */
+	mips_ejtag_exit_debug(ejtag_info);
+
+	/* registers are now invalid */
+	register_cache_invalidate(mips32->core_cache);
+
+	LOG_DEBUG("target stepped ");
+	int retval = mips_common_debug_entry(target, 1);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("mips_common_debug_entry failed");
+		return retval;
+	}
+
+	if (breakpoint)
+		mips_common_set_breakpoint(target, breakpoint);
+
+	target_call_event_callbacks(target, TARGET_EVENT_HALTED);
+
+	return ERROR_OK;
+}
+
+void mips_common_enable_breakpoints(struct target *target)
+{
+	struct breakpoint *breakpoint = target->breakpoints;
+
+	/* set any pending breakpoints */
+	while (breakpoint) {
+		if (breakpoint->set == 0)
+			mips_common_set_breakpoint(target, breakpoint);
+		breakpoint = breakpoint->next;
+	}
+}
+
+int mips_common_set_breakpoint(struct target *target,
+							   struct breakpoint *breakpoint)
+{
+	struct mips32_common *mips32 = target_to_mips32(target);
+	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
+	struct mips32_comparator *comparator_list = mips32->inst_break_list;
+	int retval;
+
+	if (breakpoint->set) {
+		LOG_WARNING("breakpoint already set");
+		return ERROR_OK;
+	}
+
+	if (breakpoint->type == BKPT_HARD) {
+
+		int bp_num = 0;
+
+		while (comparator_list[bp_num].used && (bp_num < mips32->num_inst_bpoints))
+			bp_num++;
+
+		if (bp_num >= mips32->num_inst_bpoints) {
+			LOG_ERROR("Can not find free FP Comparator(bpid: %" PRIu32 ")",
+					breakpoint->unique_id);
+			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+		}
+
+		breakpoint->set = bp_num + 1;
+		comparator_list[bp_num].used = 1;
+
+		/* EJTAG 2.0 uses 30bit IBA. First 2 bits are reserved.
+		 * Warning: there is no IB ASID registers in 2.0.
+		 * Do not set it! :) */
+		if (ejtag_info->ejtag_version == EJTAG_VERSION_20)
+			comparator_list[bp_num].bp_value &= 0xFFFFFFFC;
+
+		if (mips32->mmips != MIPS32_ONLY) {
+			if ((breakpoint->length == 3) || (breakpoint->length == 5)) {
+				comparator_list[bp_num].bp_value = breakpoint->address | 1;
+
+				target_write_u32(target, comparator_list[bp_num].reg_address,
+								 comparator_list[bp_num].bp_value);
+			} else {
+				comparator_list[bp_num].bp_value = breakpoint->address;
+				target_write_u32(target, comparator_list[bp_num].reg_address,
+								 comparator_list[bp_num].bp_value);
+			}
+		} else {
+			comparator_list[bp_num].bp_value = breakpoint->address;
+				target_write_u32(target, comparator_list[bp_num].reg_address,
+								 comparator_list[bp_num].bp_value);
+		}
+		comparator_list[bp_num].bp_value = breakpoint->address;
+
+		target_write_u32(target, comparator_list[bp_num].reg_address +
+				 ejtag_info->ejtag_ibm_offs, 0x00000000);
+
+		target_write_u32(target, comparator_list[bp_num].reg_address +
+				 ejtag_info->ejtag_ibc_offs, 1);
+		LOG_DEBUG("bpid: %" PRIu32 ", bp_num %i bp_value 0x%" PRIx32 "",
+				  breakpoint->unique_id,
+				  bp_num, comparator_list[bp_num].bp_value);
+
+	} else if (breakpoint->type == BKPT_SOFT) {
+		LOG_DEBUG("bpid: %" PRIu32, breakpoint->unique_id);
+
+		/* IF GDB sends bp->length 5 for microMips support then change it to 4 */
+		/* Check if kind field, is indicated microMips Break */
+		/* Verify address is aligned 4 byte boundary and replacing a 32-bit instruction */
+		if ((breakpoint->length == 4) || ((breakpoint->length == 5) &&
+										  ((breakpoint->address % 4) == 0))) {
+			uint32_t verify = 0xffffffff;
+			uint32_t breakpt_instr;
+
+			/* Remove isa_mode info from length to adjust to correct instruction size */
+			if (breakpoint->length == 5)
+				breakpt_instr = MICRO_MIPS32_SDBBP;
+			else
+				breakpt_instr = MIPS32_SDBBP;
+
+			retval = target_read_memory(target, breakpoint->address, (breakpoint->length & 0xE),
+										1, breakpoint->orig_instr);
+			if (retval != ERROR_OK) {
+				LOG_DEBUG("target_read_memory failed");
+				return retval;
+			}
+
+			retval = target_write_u32(target, breakpoint->address, breakpt_instr);
+			if (retval != ERROR_OK) {
+				LOG_DEBUG("target_write_u32 failed");
+				return retval;
+			}
+
+			retval = target_read_u32(target, breakpoint->address, &verify);
+			if (retval != ERROR_OK) {
+				LOG_DEBUG("target_read_u32 failed");
+				return retval;
+			}
+
+			if ((breakpt_instr == MIPS32_SDBBP) && (verify != MIPS32_SDBBP)) {
+				LOG_ERROR("Unable to set 32bit breakpoint at address %08" PRIx32
+						  " - check that memory is read/writable", breakpoint->address);
+				return ERROR_OK;
+			} else {
+				if ((breakpt_instr == MICRO_MIPS32_SDBBP) && (verify != MICRO_MIPS32_SDBBP)) {
+						LOG_ERROR("Unable to set microMips32 breakpoint at address %08" PRIx32
+								  " - check that memory is read/writable", breakpoint->address);
+						return ERROR_OK;
+				}
+			}
+		} else {
+			uint16_t verify = 0xffff;
+			uint16_t breakpt_instr;
+
+			if ((breakpoint->length == 3) || ((breakpoint->length == 5) &&
+											  ((breakpoint->address % 4) != 0))) {
+				breakpoint->length = 2;
+				breakpt_instr = MICRO_MIPS_SDBBP;
+			} else {
+				breakpt_instr = MIPS16_SDBBP;
+			}
+
+			retval = target_read_memory(target, breakpoint->address, breakpoint->length, 1,
+										breakpoint->orig_instr);
+			if (retval != ERROR_OK) {
+				LOG_DEBUG("target_read_memory failed");
+				return retval;
+			}
+
+			retval = target_write_u16(target, breakpoint->address, breakpt_instr);
+			if (retval != ERROR_OK) {
+				LOG_DEBUG("target_write_u16 failed");
+				return retval;
+			}
+
+			retval = target_read_u16(target, breakpoint->address, &verify);
+			if (retval != ERROR_OK) {
+				LOG_DEBUG("target_read_u16 failed");
+				return retval;
+			}
+
+			if ((breakpt_instr == MIPS16_SDBBP) && (verify != MIPS16_SDBBP)) {
+				LOG_ERROR("Unable to set 16bit breakpoint at address %08" PRIx32
+						  " - check that memory is read/writable", breakpoint->address);
+				return ERROR_OK;
+			} else {
+				if ((breakpt_instr == MICRO_MIPS_SDBBP) && (verify != MICRO_MIPS_SDBBP)) {
+						LOG_ERROR("Unable to set microMips breakpoint at address %08" PRIx32
+								  " - check that memory is read/writable", breakpoint->address);
+						return ERROR_OK;
+				}
+			}
+		}
+
+		breakpoint->set = 20; /* Any nice value but 0 */
+	}
+
+	return ERROR_OK;
+}
+
+int mips_common_unset_breakpoint(struct target *target,
+								 struct breakpoint *breakpoint)
+{
+	/* get pointers to arch-specific information */
+	struct mips32_common *mips32 = target_to_mips32(target);
+	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
+	struct mips32_comparator *comparator_list = mips32->inst_break_list;
+	int retval;
+
+	if (!breakpoint->set) {
+		LOG_WARNING("breakpoint not set");
+		return ERROR_OK;
+	}
+
+	if (breakpoint->type == BKPT_HARD) {
+		int bp_num = breakpoint->set - 1;
+		if ((bp_num < 0) || (bp_num >= mips32->num_inst_bpoints)) {
+			LOG_DEBUG("Invalid FP Comparator number in breakpoint (bpid: %" PRIu32 ")",
+					  breakpoint->unique_id);
+			return ERROR_OK;
+		}
+
+		LOG_INFO("bpid: %" PRIu32 " - releasing hw: %d",
+				breakpoint->unique_id, bp_num);
+
+		comparator_list[bp_num].used = 0;
+		comparator_list[bp_num].bp_value = 0;
+
+		target_write_u32(target, comparator_list[bp_num].reg_address +
+				 ejtag_info->ejtag_ibc_offs, 0);
+	} else {
+		/* restore original instruction (kept in target endianness) */
+		LOG_DEBUG("bpid: %" PRIu32, breakpoint->unique_id);
+		if ((breakpoint->length == 4) || ((breakpoint->length == 5) && ((breakpoint->address % 4) == 0))) {
+			uint32_t current_instr;
+
+			/* check that user program has not modified breakpoint instruction */
+			/* Remove isa_mode info from length of read */
+			retval = target_read_memory(target, breakpoint->address, (breakpoint->length & 0xE),
+										1, (uint8_t *)&current_instr);
+			if (retval != ERROR_OK) {
+				LOG_DEBUG("target_read_memory failed - addr: %x", breakpoint->address);
+				return retval;
+			}
+
+			/**
+			 * target_read_memory() gets us data in _target_ endianess.
+			 * If we want to use this data on the host for comparisons with some macros
+			 * we must first transform it to _host_ endianess using target_buffer_get_u32().
+			 */
+			current_instr = target_buffer_get_u32(target, (uint8_t *)&current_instr);
+
+			if ((current_instr == MIPS32_SDBBP) || (current_instr == MICRO_MIPS32_SDBBP)) {
+				retval = target_write_memory(target, breakpoint->address, 4, 1, breakpoint->orig_instr);
+				if (retval != ERROR_OK){
+					LOG_DEBUG("target_write_memory failed");
+					return retval;
+				}
+			} else {
+				LOG_WARNING("memory modified: no SDBBP instruction found");
+				LOG_WARNING("orignal instruction not written back to memory");
+			}
+
+		} else {
+			uint16_t current_instr;
+
+			/* check that user program has not modified breakpoint instruction */
+			retval = target_read_memory(target, breakpoint->address, 2, 1, (uint8_t *)&current_instr);
+			if (retval != ERROR_OK) {
+				LOG_DEBUG("target_read_memory failed");
+				return retval;
+			}
+
+			current_instr = target_buffer_get_u16(target, (uint8_t *)&current_instr);
+			if ((current_instr == MIPS16_SDBBP) || (current_instr == MICRO_MIPS_SDBBP)) {
+				retval = target_write_memory(target, breakpoint->address, 2, 1, breakpoint->orig_instr);
+				if (retval != ERROR_OK) {
+					LOG_DEBUG("target_write_memory failed");
+					return retval;
+				}
+			} else {
+				LOG_WARNING("memory modified: no SDBBP instruction found");
+				LOG_WARNING("original instruction not written back to memory");
+			}
+		}
+	}
+	breakpoint->set = 0;
+
+	return ERROR_OK;
+}
+
+int mips_common_set_watchpoint(struct target *target, struct watchpoint *watchpoint)
+{
+	struct mips32_common *mips32 = target_to_mips32(target);
+	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
+	struct mips32_comparator *comparator_list = mips32->data_break_list;
+	int wp_num = 0;
+
+	/*
+	 * watchpoint enabled, ignore all byte lanes in value register
+	 * and exclude both load and store accesses from watchpoint
+	 * condition evaluation
+	*/
+	int enable = EJTAG_DBCn_NOSB | EJTAG_DBCn_NOLB | EJTAG_DBCn_BE |
+			(0xff << EJTAG_DBCn_BLM_SHIFT);
+
+	if (watchpoint->set) {
+		LOG_WARNING("watchpoint already set");
+		return ERROR_OK;
+	}
+
+	while (comparator_list[wp_num].used && (wp_num < mips32->num_data_bpoints))
+		wp_num++;
+	if (wp_num >= mips32->num_data_bpoints) {
+		LOG_ERROR("Can not find free FP Comparator");
+		return ERROR_FAIL;
+	}
+
+	if (watchpoint->length != 4) {
+		LOG_ERROR("Only watchpoints of length 4 are supported");
+		return ERROR_TARGET_UNALIGNED_ACCESS;
+	}
+
+	if (watchpoint->address % 4) {
+		LOG_ERROR("Watchpoints address should be word aligned");
+		return ERROR_TARGET_UNALIGNED_ACCESS;
+	}
+
+	switch (watchpoint->rw) {
+		case WPT_READ:
+			enable &= ~EJTAG_DBCn_NOLB;
+			break;
+		case WPT_WRITE:
+			enable &= ~EJTAG_DBCn_NOSB;
+			break;
+		case WPT_ACCESS:
+			enable &= ~(EJTAG_DBCn_NOLB | EJTAG_DBCn_NOSB);
+			break;
+		default:
+			LOG_ERROR("BUG: watchpoint->rw neither read, write nor access");
+	}
+
+	watchpoint->set = wp_num + 1;
+	comparator_list[wp_num].used = 1;
+	comparator_list[wp_num].bp_value = watchpoint->address;
+
+	/* EJTAG 2.0 uses 29bit DBA. First 3 bits are reserved.
+	 * There is as well no ASID register support. */
+	if (ejtag_info->ejtag_version == EJTAG_VERSION_20)
+		comparator_list[wp_num].bp_value &= 0xFFFFFFF8;
+	else
+		target_write_u32(target, comparator_list[wp_num].reg_address +
+			 ejtag_info->ejtag_dbasid_offs, 0x00000000);
+
+	target_write_u32(target, comparator_list[wp_num].reg_address,
+					 comparator_list[wp_num].bp_value);
+	target_write_u32(target, comparator_list[wp_num].reg_address +
+					 ejtag_info->ejtag_dbm_offs, 0x00000000);
+
+	target_write_u32(target, comparator_list[wp_num].reg_address +
+					 ejtag_info->ejtag_dbc_offs, enable);
+
+	/* TODO: probably this value is ignored on 2.0 */
+	target_write_u32(target, comparator_list[wp_num].reg_address +
+					 ejtag_info->ejtag_dbv_offs, 0);
+	LOG_DEBUG("wp_num %i bp_value 0x%" PRIx32 "", wp_num, comparator_list[wp_num].bp_value);
+
+	return ERROR_OK;
+}
+
+int mips_common_unset_watchpoint(struct target *target, struct watchpoint *watchpoint)
+{
+	/* get pointers to arch-specific information */
+	struct mips32_common *mips32 = target_to_mips32(target);
+	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
+	struct mips32_comparator *comparator_list = mips32->data_break_list;
+
+	if (!watchpoint->set) {
+		LOG_WARNING("watchpoint not set");
+		return ERROR_OK;
+	}
+
+	int wp_num = watchpoint->set - 1;
+	if ((wp_num < 0) || (wp_num >= mips32->num_data_bpoints)) {
+		LOG_DEBUG("Invalid FP Comparator number in watchpoint");
+		return ERROR_OK;
+	}
+	comparator_list[wp_num].used = 0;
+	comparator_list[wp_num].bp_value = 0;
+	target_write_u32(target, comparator_list[wp_num].reg_address +
+					 ejtag_info->ejtag_dbc_offs, 0);
+	watchpoint->set = 0;
+
+	return ERROR_OK;
+}
+
+int mips_common_add_watchpoint(struct target *target, struct watchpoint *watchpoint)
+{
+	struct mips32_common *mips32 = target_to_mips32(target);
+
+	if (mips32->num_data_bpoints_avail < 1) {
+		LOG_INFO("no hardware watchpoints available");
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	}
+
+	mips32->num_data_bpoints_avail--;
+
+	mips_common_set_watchpoint(target, watchpoint);
+	return ERROR_OK;
+}
+
+int mips_common_remove_watchpoint(struct target *target, struct watchpoint *watchpoint)
+{
+	/* get pointers to arch-specific information */
+	struct mips32_common *mips32 = target_to_mips32(target);
+
+	if (target->state != TARGET_HALTED) {
+		LOG_WARNING("target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	if (watchpoint->set)
+		mips_common_unset_watchpoint(target, watchpoint);
+
+	mips32->num_data_bpoints_avail++;
+
+	return ERROR_OK;
+}
+
+void mips_common_enable_watchpoints(struct target *target)
+{
+	struct watchpoint *watchpoint = target->watchpoints;
+
+	/* set any pending watchpoints */
+	while (watchpoint) {
+		if (watchpoint->set == 0)
+			mips_common_set_watchpoint(target, watchpoint);
+		watchpoint = watchpoint->next;
+	}
+}
+
+int mips_common_read_memory(struct target *target, uint32_t address,
+							uint32_t size, uint32_t count, uint8_t *buffer)
+{
+	struct mips32_common *mips32 = target_to_mips32(target);
+	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
+
+	LOG_DEBUG("address: 0x%8.8" PRIx32 ", size: 0x%8.8" PRIx32 ", count: 0x%8.8" PRIx32 "",
+			address, size, count);
+
+	if (target->state != TARGET_HALTED) {
+		LOG_WARNING("target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	/* sanitize arguments */
+	if (((size != 4) && (size != 2) && (size != 1)) || (count == 0) || !(buffer))
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	if (((size == 4) && (address & 0x3u)) || ((size == 2) && (address & 0x1u)))
+		return ERROR_TARGET_UNALIGNED_ACCESS;
+
+	/* since we don't know if buffer is aligned, we allocate new mem that is always aligned */
+	void *t = NULL;
+
+	if (size > 1) {
+		t = malloc(count * size * sizeof(uint8_t));
+		if (t == NULL) {
+			LOG_ERROR("Out of memory");
+			return ERROR_FAIL;
+		}
+	} else
+		t = buffer;
+
+	/* if noDMA off, use DMAACC mode for memory read */
+	/* Note: Currently no core implement this feature */
+	int retval;
+	if (ejtag_info->impcode & EJTAG_IMP_NODMA) {
+		retval = mips32_pracc_read_mem(ejtag_info, address, size, count, t, mips32->cp0_mask);
+	}
+	else
+		retval = mips32_dmaacc_read_mem(ejtag_info, address, size, count, t);
+
+	/* mips32_..._read_mem with size 4/2 returns uint32_t/uint16_t in host */
+	/* endianness, but byte array should represent target endianness	   */
+	if (ERROR_OK == retval) {
+		switch (size) {
+		case 4:
+			target_buffer_set_u32_array(target, buffer, count, t);
+			break;
+		case 2:
+			target_buffer_set_u16_array(target, buffer, count, t);
+			break;
+		}
+	}
+
+	if ((size > 1) && (t != NULL))
+		free(t);
+
+	return retval;
+}
+
+int mips_common_write_memory(struct target *target, uint32_t address,
+							 uint32_t size, uint32_t count, const uint8_t *buffer)
+{
+	struct mips32_common *mips32 = target_to_mips32(target);
+	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
+
+	LOG_DEBUG("address: 0x%8.8" PRIx32 ", size: 0x%8.8" PRIx32 ", count: 0x%8.8" PRIx32 "",
+			address, size, count);
+
+	if (target->state != TARGET_HALTED) {
+		LOG_WARNING("target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	if (size == 4 && count > 32) {
+		int retval = mips_common_bulk_write_memory(target, address, count, buffer);
+		if (retval == ERROR_OK)
+			return ERROR_OK;
+		LOG_WARNING("Falling back to non-bulk write");
+	}
+
+	/* sanitize arguments */
+	if (((size != 4) && (size != 2) && (size != 1)) || (count == 0) || !(buffer))
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	if (((size == 4) && (address & 0x3u)) || ((size == 2) && (address & 0x1u)))
+		return ERROR_TARGET_UNALIGNED_ACCESS;
+
+	/** correct endianess if we have word or hword access */
+	void *t = NULL;
+	if (size > 1) {
+		/* mips32_..._write_mem with size 4/2 requires uint32_t/uint16_t in host */
+		/* endianness, but byte array represents target endianness				 */
+		t = malloc(count * size * sizeof(uint8_t));
+		if (t == NULL) {
+			LOG_ERROR("Out of memory");
+			return ERROR_FAIL;
+		}
+
+		switch (size) {
+		case 4:
+			target_buffer_get_u32_array(target, buffer, count, (uint32_t *)t);
+			break;
+		case 2:
+			target_buffer_get_u16_array(target, buffer, count, (uint16_t *)t);
+			break;
+		}
+		buffer = t;
+	}
+
+	/* if noDMA off, use DMAACC mode for memory write */
+	/* Note: Currently no core implement this feature */
+	int retval;
+	if (ejtag_info->impcode & EJTAG_IMP_NODMA)
+		retval = mips32_pracc_write_mem(ejtag_info, address, size, count, buffer);
+	else
+		retval = mips32_dmaacc_write_mem(ejtag_info, address, size, count, buffer);
+
+	if (t != NULL)
+		free(t);
+
+	if (ERROR_OK != retval)
+		return retval;
+
+	return ERROR_OK;
+}
+
+int mips_common_init_target(struct command_context *cmd_ctx,
+							struct target *target)
+{
+	mips32_build_reg_cache(target);
+
+	return ERROR_OK;
+}
+
+int mips_common_examine(struct target *target)
+{
+	int retval;
+	struct mips_common *mips32 = target_to_mips_common(target);
+	struct mips_ejtag *ejtag_info = &mips32->mips32.ejtag_info;
+	uint32_t idcode = 0;
+
+	// Need to re-examine target
+	if (mips32->is_pic32 == true)
+		target_reset_examined(target);
+
+	if (!target_was_examined(target)) {
+		retval = mips_ejtag_get_idcode(ejtag_info, &idcode);
+		if (retval != ERROR_OK)
+			return retval;
+		ejtag_info->idcode = idcode;
+
+		if (((idcode >> 1) & 0x7FF) == 0x29) {
+			/* we are using a pic32 so select ejtag port
+			 * as it is not selected by default */
+			mips_ejtag_set_instr(ejtag_info, MTAP_SW_ETAP);
+			LOG_DEBUG("PIC32MX/MZ Detected - using EJTAG Interface");
+			mips32->is_pic32 = true;
+		}
+	}
+
+	/* init rest of ejtag interface */
+	retval = mips_ejtag_init(ejtag_info);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("mips_ejtag_init failed");
+		return retval;
+	}
+
+	retval = mips32_examine(target);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("mips32_examine failed");
+		return retval;
+	}
+
+	return ERROR_OK;
+}
+
+
+int mips_common_bulk_write_memory(struct target *target, uint32_t address,
+								  uint32_t count, const uint8_t *buffer)
+{
+	struct mips32_common *mips32 = target_to_mips32(target);
+	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
+	struct working_area *fast_data_area;
+	int retval;
+	int write_t = 1;
+
+	LOG_DEBUG("address: 0x%8.8" PRIx32 ", count: 0x%8.8" PRIx32 "", address, count);
+
+	/* check alignment */
+	if (address & 0x3u)
+		return ERROR_TARGET_UNALIGNED_ACCESS;
+
+	if (mips32->fast_data_area == NULL) {
+		/* Get memory for block write handler
+		 * we preserve this area between calls and gain a speed increase
+		 * of about 3kb/sec when writing flash
+		 * this will be released/nulled by the system when the target is resumed or reset */
+		retval = target_alloc_working_area(target,
+										   MIPS32_FASTDATA_HANDLER_SIZE,
+										   &mips32->fast_data_area);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("No working area available");
+			return retval;
+		}
+
+		/* reset fastadata state so the algo get reloaded */
+		ejtag_info->fast_access_save = -1;
+	}
+
+	fast_data_area = mips32->fast_data_area;
+
+	LOG_DEBUG("fast_data_area->address: 0x%8.8x fast_data_area->size: %x",
+			  fast_data_area->address, fast_data_area->size);
+	if (address <= fast_data_area->address + fast_data_area->size &&
+			fast_data_area->address <= address + count) {
+		LOG_ERROR("fast_data (0x%8.8" PRIx32 ") is within write area "
+			  "(0x%8.8" PRIx32 "-0x%8.8" PRIx32 ").",
+			  fast_data_area->address, address, address + count);
+		LOG_ERROR("Change work-area-phys or load_image address!");
+		return ERROR_FAIL;
+	}
+
+	/* mips32_pracc_fastdata_xfer requires uint32_t in host endianness, */
+	/* but byte array represents target endianness						*/
+	uint32_t *t = NULL;
+	t = malloc(count * sizeof(uint32_t));
+	if (t == NULL) {
+		LOG_ERROR("Out of memory");
+		return ERROR_FAIL;
+	}
+
+	target_buffer_get_u32_array(target, buffer, count, t);
+
+	retval = mips32_pracc_fastdata_xfer(ejtag_info, mips32->fast_data_area, write_t, address,
+			count, t);
+
+	if (t != NULL)
+		free(t);
+
+	if (retval != ERROR_OK)
+		LOG_ERROR("Fastdata access Failed");
+
+	return retval;
+}
+
+int mips_common_add_breakpoint(struct target *target,
+							   struct breakpoint *breakpoint)
+{
+	struct mips32_common *mips32 = target_to_mips32(target);
+
+	if (breakpoint->type == BKPT_HARD) {
+		if (mips32->num_inst_bpoints_avail < 1) {
+			LOG_INFO("no hardware breakpoint available");
+			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+		}
+
+		mips32->num_inst_bpoints_avail--;
+	}
+
+	return mips_common_set_breakpoint(target, breakpoint);
+}
+
+
+int mips_common_remove_breakpoint(struct target *target,
+								  struct breakpoint *breakpoint)
+{
+	/* get pointers to arch-specific information */
+	struct mips32_common *mips32 = target_to_mips32(target);
+
+	if (target->state != TARGET_HALTED) {
+		LOG_WARNING("target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	if (breakpoint->set)
+		mips_common_unset_breakpoint(target, breakpoint);
+
+	if (breakpoint->type == BKPT_HARD)
+		mips32->num_inst_bpoints_avail++;
+
+	return ERROR_OK;
+}
+
diff --git b/src/target/mips_common.h a/src/target/mips_common.h
new file mode 100644
index 000000000..e30542587
--- /dev/null
+++ a/src/target/mips_common.h
@@ -0,0 +1,67 @@
+/***************************************************************************
+ *   Copyright (C) 2008 by Spencer Oliver                                  *
+ *   spen@spen-soft.co.uk                                                  *
+ *                                                                         *
+ *   Copyright (C) 2008 by David T.L. Wong                                 *
+ *                                                                         *
+ *   Copyright (C) 2011 by Drasko DRASKOVIC                                *
+ *   drasko.draskovic@gmail.com                                            *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef MIPS_COMMON_H
+#define MIPS_COMMON_H
+
+struct target;
+
+#define MIPS_COMMON_MAGIC	0xB321B321
+
+struct mips_common {
+	uint32_t common_magic;
+	bool is_pic32;
+	struct mips32_common mips32;
+};
+
+struct mips_common *target_to_mips_common(struct target *target);
+
+int mips_common_add_breakpoint(struct target *target, struct breakpoint *breakpoint);
+int mips_common_add_watchpoint(struct target *target, struct watchpoint *watchpoint);
+int mips_common_assert_reset(struct target *target);
+int mips_common_deassert_reset(struct target *target);
+int mips_common_examine(struct target *target);
+int mips_common_examine_debug_reason(struct target *target);
+int mips_common_halt(struct target *target);
+int mips_common_init_target(struct command_context *cmd_ctx,
+							struct target *target);
+int mips_common_poll(struct target *target);
+int mips_common_resume(struct target *target, int current,
+					   uint32_t address, int handle_breakpoints, int debug_execution);
+int mips_common_read_memory(struct target *target, uint32_t address,
+							uint32_t size, uint32_t count, uint8_t *buffer);
+int mips_common_step(struct target *target, int current,
+					 uint32_t address, int handle_breakpoints);
+int mips_common_write_memory(struct target *target, uint32_t address,
+							 uint32_t size, uint32_t count, const uint8_t *buffer);
+int mips_common_remove_breakpoint(struct target *target, struct breakpoint *breakpoint);
+int mips_common_remove_watchpoint(struct target *target, struct watchpoint *watchpoint);
+
+/* Common commands define in both m4k and mips32 targets */
+int mips_common_scan_delay(struct command_invocation *cmd);
+int mips_common_cp0_command(struct command_invocation *cmd);
+int mips_common_target_request_data(struct target *target, uint32_t size, uint8_t *buffer);
+
+#endif	/*MIPS_COMMON_H*/
diff --git b/src/target/mips_ejtag.c a/src/target/mips_ejtag.c
index f6cd4510e..9f550c9bd 100644
--- b/src/target/mips_ejtag.c
+++ a/src/target/mips_ejtag.c
@@ -38,6 +38,7 @@ void mips_ejtag_set_instr(struct mips_ejtag *ejtag_info, int new_instr)
 	assert(tap != NULL);
 
 	if (buf_get_u32(tap->cur_instr, 0, tap->ir_length) != (uint32_t)new_instr) {
+
 		struct scan_field field;
 		uint8_t t[4];
 
@@ -75,7 +76,8 @@ int mips_ejtag_get_idcode(struct mips_ejtag *ejtag_info, uint32_t *idcode)
 	return ERROR_OK;
 }
 
-static int mips_ejtag_get_impcode(struct mips_ejtag *ejtag_info, uint32_t *impcode)
+//static int mips_ejtag_get_impcode(struct mips_ejtag *ejtag_info, uint32_t *impcode)
+int mips_ejtag_get_impcode(struct mips_ejtag *ejtag_info, uint32_t *impcode)
 {
 	struct scan_field field;
 	uint8_t r[4];
@@ -102,6 +104,7 @@ static int mips_ejtag_get_impcode(struct mips_ejtag *ejtag_info, uint32_t *impco
 
 void mips_ejtag_add_scan_96(struct mips_ejtag *ejtag_info, uint32_t ctrl, uint32_t data, uint8_t *in_scan_buf)
 {
+	//LOG_DEBUG("mips_ejtag_drscan_96");
 	assert(ejtag_info->tap != NULL);
 	struct jtag_tap *tap = ejtag_info->tap;
 
@@ -125,6 +128,7 @@ void mips_ejtag_add_scan_96(struct mips_ejtag *ejtag_info, uint32_t ctrl, uint32
 
 int mips_ejtag_drscan_32(struct mips_ejtag *ejtag_info, uint32_t *data)
 {
+	//LOG_DEBUG("mips_ejtag_drscan_32");
 	struct jtag_tap *tap;
 	tap  = ejtag_info->tap;
 	assert(tap != NULL);
@@ -153,8 +157,45 @@ int mips_ejtag_drscan_32(struct mips_ejtag *ejtag_info, uint32_t *data)
 	return ERROR_OK;
 }
 
+#if 0
+int mips_ejtag_drscan_38(struct mips_ejtag *ejtag_info, uint64_t *data)
+{
+	struct jtag_tap *tap;
+	tap  = ejtag_info->tap;
+
+	if (tap == NULL)
+		return ERROR_FAIL;
+
+	mips_ejtag_set_instr(ejtag_info, EJTAG_DCR_FDC);
+
+	struct scan_field field;
+
+	uint8_t t[5], r[5];
+	int retval;
+
+	field.num_bits = 38;
+	field.out_value = &t;
+	buf_set_u64(t, 0, field.num_bits, *data);
+	field.in_value = r;
+
+	jtag_add_dr_scan(tap, 1, &field, TAP_IDLE);
+	retval = jtag_execute_queue();
+	if (retval != ERROR_OK) {
+		LOG_ERROR("register read failed");
+		return retval;
+	}
+
+	*data = buf_get_u64(field.in_value, 0, 64);
+
+	keep_alive();
+
+	return ERROR_OK;
+}
+#endif
+
 void mips_ejtag_drscan_32_out(struct mips_ejtag *ejtag_info, uint32_t data)
 {
+//	LOG_DEBUG("mips_ejtag_drscan_32_out");
 	uint8_t t[4];
 	struct jtag_tap *tap;
 	tap  = ejtag_info->tap;
@@ -173,6 +214,7 @@ void mips_ejtag_drscan_32_out(struct mips_ejtag *ejtag_info, uint32_t data)
 
 int mips_ejtag_drscan_8(struct mips_ejtag *ejtag_info, uint32_t *data)
 {
+//	LOG_DEBUG("mips_ejtag_drscan_8");
 	struct jtag_tap *tap;
 	tap  = ejtag_info->tap;
 	assert(tap != NULL);
@@ -201,6 +243,7 @@ int mips_ejtag_drscan_8(struct mips_ejtag *ejtag_info, uint32_t *data)
 
 void mips_ejtag_drscan_8_out(struct mips_ejtag *ejtag_info, uint8_t data)
 {
+//	LOG_DEBUG("mips_ejtag_drscan_8_out");
 	struct jtag_tap *tap;
 	tap  = ejtag_info->tap;
 	assert(tap != NULL);
@@ -269,12 +312,14 @@ int mips_ejtag_enter_debug(struct mips_ejtag *ejtag_info)
 	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL);
 
 	if (ejtag_info->ejtag_version == EJTAG_VERSION_20) {
+		LOG_INFO ("VERSION_20");
 		if (disable_dcr_mp(ejtag_info) != ERROR_OK)
 			goto error;
 	}
 
 	/* set debug break bit */
 	ejtag_ctrl = ejtag_info->ejtag_ctrl | EJTAG_CTRL_JTAGBRK;
+	LOG_DEBUG("Set Debug Break: ejtag_ctrl: 0x%8.8" PRIx32 "", ejtag_ctrl);
 	mips_ejtag_drscan_32(ejtag_info, &ejtag_ctrl);
 
 	/* break bit will be cleared by hardware */
@@ -298,7 +343,7 @@ int mips_ejtag_exit_debug(struct mips_ejtag *ejtag_info)
 	/* execute our dret instruction */
 	ctx.retval = mips32_pracc_queue_exec(ejtag_info, &ctx, NULL);
 
-	/* pic32mx workaround, false pending at low core clock */
+	/* pic32mx/mz workaround, false pending at low core clock */
 	jtag_add_sleep(1000);
 	return ctx.retval;
 }
@@ -364,7 +409,7 @@ static void ejtag_v26_print_imp(struct mips_ejtag *ejtag_info)
 		EJTAG_IMP_HAS(EJTAG_V26_IMP_DINT) ? " DINT" : "");
 }
 
-static void ejtag_main_print_imp(struct mips_ejtag *ejtag_info)
+void ejtag_main_print_imp(struct mips_ejtag *ejtag_info)
 {
 	LOG_DEBUG("EJTAG main: features:%s%s%s%s%s",
 		EJTAG_IMP_HAS(EJTAG_IMP_ASID8) ? " ASID_8" : "",
@@ -396,6 +441,7 @@ int mips_ejtag_init(struct mips_ejtag *ejtag_info)
 	retval = mips_ejtag_get_impcode(ejtag_info, &ejtag_info->impcode);
 	if (retval != ERROR_OK)
 		return retval;
+
 	LOG_DEBUG("impcode: 0x%8.8" PRIx32 "", ejtag_info->impcode);
 
 	/* get ejtag version */
@@ -424,6 +470,7 @@ int mips_ejtag_init(struct mips_ejtag *ejtag_info)
 			LOG_DEBUG("EJTAG: Unknown Version Detected");
 			break;
 	}
+
 	ejtag_main_print_imp(ejtag_info);
 
 	if ((ejtag_info->impcode & EJTAG_IMP_NODMA) == 0) {
@@ -434,8 +481,9 @@ int mips_ejtag_init(struct mips_ejtag *ejtag_info)
 
 	ejtag_info->ejtag_ctrl = EJTAG_CTRL_PRACC | EJTAG_CTRL_PROBEN;
 
-	if (ejtag_info->ejtag_version != EJTAG_VERSION_20)
+	if (ejtag_info->ejtag_version != EJTAG_VERSION_20) {
 		ejtag_info->ejtag_ctrl |= EJTAG_CTRL_ROCC | EJTAG_CTRL_SETDEV;
+	}
 
 	ejtag_info->fast_access_save = -1;
 
diff --git b/src/target/mips_ejtag.h a/src/target/mips_ejtag.h
index 3e0d83101..a135ca47d 100644
--- b/src/target/mips_ejtag.h
+++ a/src/target/mips_ejtag.h
@@ -38,6 +38,7 @@
 #define EJTAG_INST_TCBCONTROLA	0x10
 #define EJTAG_INST_TCBCONTROLB	0x11
 #define EJTAG_INST_TCBDATA		0x12
+#define EJTAG_INST_FDC			0x17
 #define EJTAG_INST_BYPASS		0xFF
 
 /* microchip PIC32MX specific instructions */
@@ -135,6 +136,7 @@
 #define EJTAG_DCR_IB			(1 << 16)
 #define EJTAG_DCR_INTE			(1 << 4)
 #define EJTAG_DCR_MP			(1 << 2)
+#define EJTAG_DCR_FDC			(1 << 18)
 
 /* breakpoint support */
 /* EJTAG_V20_* was tested on Broadcom BCM7401
@@ -144,7 +146,7 @@
 #define EJTAG_V20_IBC_OFFS		0x4	/* IBC Offset */
 #define EJTAG_V20_IBM_OFFS		0x8
 #define EJTAG_V20_IBAn_STEP		0x10	/* Offset for next channel */
-#define EJTAG_V20_DBS			0xFF30008
+#define EJTAG_V20_DBS			0xFF300008
 #define EJTAG_V20_DBA0			0xFF300200
 #define EJTAG_V20_DBC_OFFS		0x4
 #define EJTAG_V20_DBM_OFFS		0x8
diff --git b/src/target/mips_iAptiv.c a/src/target/mips_iAptiv.c
new file mode 100644
index 000000000..340f27d60
--- /dev/null
+++ a/src/target/mips_iAptiv.c
@@ -0,0 +1,1148 @@
+/***************************************************************************
+ *   Copyright (C) 2008 by Spencer Oliver                                  *
+ *   spen@spen-soft.co.uk                                                  *
+ *                                                                         *
+ *   Copyright (C) 2008 by David T.L. Wong                                 *
+ *                                                                         *
+ *   Copyright (C) 2009 by David N. Claffey <dnclaffey@gmail.com>          *
+ *                                                                         *
+ *   Copyright (C) 2011 by Drasko DRASKOVIC                                *
+ *   drasko.draskovic@gmail.com                                            *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "breakpoints.h"
+#include "mips32.h"
+#include "mips_common.h"
+#include "mips_iAptiv.h"
+#include "mips32_dmaacc.h"
+#include "target_type.h"
+#include "register.h"
+
+
+#define CMDALL_HALT 0
+static const struct {
+	unsigned option;
+	const char *arg;
+} cmdall_cmd_list[1] = {
+	{ CMDALL_HALT, "halt"},
+};
+
+uint32_t save_cpc_enable;
+uint32_t save_gic_enable;
+
+int mips_restore_cpc_enable_state (struct target *);
+int mips_restore_gic_enable_state (struct target *);
+
+static int mips_iAptiv_init_arch_info(struct target *target,
+		struct mips_iAptiv_common *mips_iAptiv, struct jtag_tap *tap)
+{
+	struct mips32_common *mips32 = &mips_iAptiv->mips32;
+
+	mips_iAptiv->common_magic = MIPS_IAPTIV_COMMON_MAGIC;
+
+	/* initialize mips4k specific info */
+	mips32_init_arch_info(target, mips32, tap);
+	mips32->arch_info = mips_iAptiv;
+	mips32->cp0_mask = MIPS_CP0_iAPTIV;
+
+	return ERROR_OK;
+}
+
+static int mips_iAptiv_target_create(struct target *target, Jim_Interp *interp)
+{
+	struct mips_iAptiv_common *mips_iAptiv = calloc(1, sizeof(struct mips_iAptiv_common));
+
+	mips_iAptiv_init_arch_info(target, mips_iAptiv, target->tap);
+
+	return ERROR_OK;
+}
+
+static int mips_iAptiv_halt_all(struct target *target)
+{
+	struct mips32_common *mips32 = target_to_mips32(target);
+	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
+
+	int retval = ERROR_OK;
+	struct target *curr;
+
+	do {
+		int ret = ERROR_OK;
+		curr = target;
+		if (curr->state != TARGET_HALTED) {
+			LOG_INFO("halt core");
+			mips32 = target_to_mips32(curr);
+			ejtag_info = &mips32->ejtag_info;
+			ret = mips_ejtag_enter_debug(ejtag_info);
+			if (ret != ERROR_OK) {
+				LOG_ERROR("halt failed target: %s", curr->cmd_name);
+				retval = ret;
+			}
+		}
+		target = target->next;
+	} while (curr->next != (struct target *)NULL);
+
+	return retval;
+}
+
+uint32_t mips_get_gic (struct target *target, int *retval)
+{
+	struct mips32_common *mips32 = target_to_mips32(target);
+	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
+	
+	uint32_t gcr_base;
+	uint32_t gic_base;
+	uint32_t config3; /*	cp0 config - 16, 3 */
+	uint32_t cmgcrbase; /*	cp0 config - 15, 3 */
+
+	if ((*retval = mips32_pracc_cp0_read(ejtag_info, &config3, 16, 3))!= ERROR_OK)
+		return 0;
+
+	/* Read Config3 to determine if CMGCRBASE register is implemented */
+	if ((config3 & 0x8) == 0){
+		LOG_USER("CMGCRBASE not configured");
+		return 0;
+	}
+
+	/* Read cmgcrbase config register */
+	if ((*retval = mips32_pracc_cp0_read(ejtag_info, &cmgcrbase, 15, 3)) != ERROR_OK){
+		LOG_DEBUG("target_read_u32 failed");
+		return 0;
+	}
+
+	gcr_base = ((cmgcrbase << 4) + 0xa0000000);
+
+	*retval = target_read_u32(target, gcr_base + 0x80, &gic_base);
+	if (*retval != ERROR_OK) {
+		LOG_DEBUG("target_read_u32 failed");
+		return 0;
+	}
+
+	if ((gic_base >> 24) != 0x1b){
+		*retval = target_write_u32(target, gcr_base + 0x80, 0x1BDC0000);
+		if (*retval != ERROR_OK) {
+			LOG_DEBUG("target_write_u32 failed");
+			return 0;
+		}
+
+		*retval = target_read_u32(target, gcr_base + 0x80, &gic_base);
+		if (*retval != ERROR_OK) {
+			LOG_DEBUG("target_read_u32 failed");
+			return 0;
+		}
+	}
+
+	/* Set CPC enable bit (0) */
+	save_gic_enable = gic_base & 1;
+	gic_base = (gic_base | 0x1);
+	*retval = target_write_u32(target, gcr_base + 0x80, gic_base);
+	if (*retval != ERROR_OK) {
+		LOG_DEBUG("target_write_u32 failed");
+		return 0;
+	}
+
+	return ((gic_base + 0xa0000000) & 0xffff0000);
+}
+
+int mips_restore_gic_enable_state (struct target *target)
+{
+	struct mips32_common *mips32 = target_to_mips32(target);
+	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
+	
+	uint32_t gcr_base;
+	uint32_t temp;
+
+	uint32_t config3; /*	cp0 config - 16, 3 */
+	uint32_t cmgcrbase; /*	cp0 config - 15, 3 */
+
+	int retval = -1;
+
+	if ((retval = mips32_pracc_cp0_read(ejtag_info, &config3, 16, 3))!= ERROR_OK)
+		return retval;
+
+	/* Read Config3 to determine if CMGCRBASE register is implemented */
+	if ((config3 & 0x8) == 0){
+		LOG_USER("CMGCRBASE not configured");
+		return ERROR_OK;
+	}
+
+	/* Read cmgcrbase config register */
+	if ((retval = mips32_pracc_cp0_read(ejtag_info, &cmgcrbase, 15, 3)) != ERROR_OK)
+		return retval;
+
+	gcr_base = ((cmgcrbase << 4) + 0xa0000000);
+
+	retval = target_read_u32(target, gcr_base + 0x80, &temp);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("target_read_u32 failed");
+		return retval;
+	}
+
+	/* Was CPC enable bit (0) set */
+	if (save_gic_enable == 0)
+		temp = temp & 0xfffffffe; 
+	
+	retval = target_write_u32(target, gcr_base +0x80, temp);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("target_write_u32 failed");
+		return retval;
+	}
+
+	return ERROR_OK;
+}
+
+uint32_t mips_get_cpc (struct target *target, int *retval)
+{
+	struct mips32_common *mips32 = target_to_mips32(target);
+	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
+	
+	uint32_t gcr_base;
+	uint32_t cpc_base;
+	uint32_t config3; /*	cp0 config - 16, 3 */
+	uint32_t cmgcrbase; /*	cp0 config - 15, 3 */
+
+	if ((*retval = mips32_pracc_cp0_read(ejtag_info, &config3, 16, 3))!= ERROR_OK) {
+		LOG_DEBUG("target_read_u32 failed");
+		return 0;
+	}
+
+	/* Read Config3 to determine if CMGCRBASE register is implemented */
+	if ((config3 & 0x8) == 0){
+		LOG_USER("CMGCRBASE not configured");
+		return 0;
+	}
+
+	/* Read cmgcrbase config register */
+	if ((*retval = mips32_pracc_cp0_read(ejtag_info, &cmgcrbase, 15, 3)) != ERROR_OK){
+		LOG_DEBUG("target_read_u32 failed");
+		return 0;
+	}
+
+	gcr_base = ((cmgcrbase << 4) + 0xa0000000);
+
+	/* get CPC base */
+	*retval = target_read_u32(target, gcr_base + 0x88, &cpc_base);
+	if (*retval != ERROR_OK) {
+		LOG_DEBUG("target_read_u32 failed");
+		return 0;
+	}
+
+	/* Has CPC address been initialized */
+	if ((cpc_base >> 24) != 0x1b){ 
+		*retval = target_write_u32(target, gcr_base + 0x88, 0x1BDE0000);
+		if (*retval != ERROR_OK) {
+			LOG_DEBUG("target_write_u32 failed");
+			return 0;
+		}
+
+		*retval = target_read_u32(target, gcr_base + 0x88, &cpc_base);
+		if (*retval != ERROR_OK) {
+			LOG_DEBUG("target_read_u32 failed");
+			return 0;
+		}
+	}
+
+	/* Set CPC enable bit (0) */
+	save_cpc_enable = cpc_base & 1;
+	cpc_base = (cpc_base | 0x1);
+	*retval = target_write_u32(target, gcr_base + 0x88, cpc_base);
+	if (*retval != ERROR_OK) {
+		LOG_DEBUG("target_write_u32 failed");
+		return 0;
+	}
+
+	return ((cpc_base + 0xa0000000) & 0xffff0000);
+}
+
+
+int mips_restore_cpc_enable_state (struct target *target)
+{
+	struct mips32_common *mips32 = target_to_mips32(target);
+	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
+	
+	uint32_t gcr_base;
+	uint32_t temp;
+
+	uint32_t config3; /*	cp0 config - 16, 3 */
+	uint32_t cmgcrbase; /*	cp0 config - 15, 3 */
+
+	int retval = -1;
+
+	if ((retval = mips32_pracc_cp0_read(ejtag_info, &config3, 16, 3))!= ERROR_OK)
+		return retval;
+
+	/* Read Config3 to determine if CMGCRBASE register is implemented */
+	if ((config3 & 0x8) == 0){
+		LOG_USER("CMGCRBASE not configured");
+		return ERROR_OK;
+	}
+
+	/* Read cmgcrbase config register */
+	if ((retval = mips32_pracc_cp0_read(ejtag_info, &cmgcrbase, 15, 3)) != ERROR_OK)
+		return retval;
+
+	gcr_base = ((cmgcrbase << 4) + 0xa0000000);
+
+	retval = target_read_u32(target, gcr_base + 0x88, &temp);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("target_read_u32 failed");
+		return retval;
+	}
+
+	/* Was CPC enable bit (0) set */
+	if (save_cpc_enable == 0)
+		temp = temp & 0xfffffffe; 
+	
+	retval = target_write_u32(target, gcr_base + 0x88, temp);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("target_write_u32 failed");
+		return retval;
+	}
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(mips_ia_handle_cmdall_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+#if 0
+	struct mips32_common *mips32 = target_to_mips32(target);
+	struct mips_ejtag *ejtag_info = &mips_iAptiv->mips32.ejtag_info;
+#endif
+	int retval = -1;
+	int i = 0;
+
+	if ((CMD_ARGC >= 2) || (CMD_ARGC == 0)){
+		LOG_DEBUG("ERROR_COMMAND_SYNTAX_ERROR");
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	if (CMD_ARGC == 1) {
+		for (i = 0; i < 1 ; i++) {
+			if (strcmp(CMD_ARGV[0], cmdall_cmd_list[i].arg) == 0) {
+				switch (i) {
+					case CMDALL_HALT:
+						LOG_INFO ("cmdall halt");
+						retval = mips_iAptiv_halt_all(target);
+						return retval;
+						break;
+					default:
+						LOG_ERROR("Invalid cmdall command '%s' not found", CMD_ARGV[0]);
+						return ERROR_COMMAND_SYNTAX_ERROR;
+				}
+			} else {
+					LOG_ERROR("Invalid cmdall command '%s' not found", CMD_ARGV[0]);
+					return ERROR_COMMAND_SYNTAX_ERROR;
+			}
+		}
+	}
+	
+	return ERROR_OK;
+}
+
+/*                                                                                     */
+/* Command is used to dump the Coherency Manager Global Configuration Registers.       */
+/* The Global Configuration Registers (GCR) are a set of memory-mapped registers that  */
+/* are used to configure and control various aspects of the Coherence Manager and the  */
+/* coherence scheme.                                                                   */
+/* See section 8.3.1 of Mips32 interAptiv Multiprocessing System Programmer's Guide    */
+/* Document available at: http://wiki.prplfoundation.org/wiki/MIPS_documentation       */
+/*                                                                                     */
+COMMAND_HANDLER(mips_dump_gcr_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	struct mips32_common *mips32 = target_to_mips32(target);
+	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
+	
+	uint32_t gcr_base;
+	uint32_t gic_base;
+	uint32_t cpc_base;
+	uint32_t temp;
+
+	uint32_t config3; /*	cp0 config - 16, 3 */
+	uint32_t cmgcrbase; /*	cp0 config - 15, 3 */
+
+	int retval = -1;
+
+	if (CMD_ARGC >= 1){
+		LOG_DEBUG("ERROR_COMMAND_SYNTAX_ERROR");
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	if (target->state != TARGET_HALTED) {
+		command_print(CMD_CTX, "target must be stopped for \"%s\" command", CMD_NAME);
+		return ERROR_OK;
+	}
+
+	if ((retval = mips32_pracc_cp0_read(ejtag_info, &config3, 16, 3))!= ERROR_OK)
+		return retval;
+
+	/* May need to read Config3 to determine if CMGCRBASE register is implemented */
+	if ((config3 & 0x8) == 0){
+		LOG_USER("CMGCRBASE not configured");
+		return ERROR_OK;
+	}
+
+	/* Read cmgcrbase config register */
+	if ((retval = mips32_pracc_cp0_read(ejtag_info, &cmgcrbase, 15, 3)) != ERROR_OK)
+		return retval;
+
+	gcr_base = ((cmgcrbase << 4) + 0xa0000000);
+
+	retval = target_read_u32(target, gcr_base, &temp);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("target_read_u32 failed");
+		return retval;
+	}
+
+	LOG_USER ("gcr_config  = 0x%8.8x", temp);
+
+	retval = target_read_u32(target, gcr_base + 0x8, &temp);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("target_read_u32 failed");
+		return retval;
+	}
+
+	LOG_USER ("gcr_base    = 0x%8.8x", temp);
+
+	retval = target_read_u32(target, gcr_base + 0x10, &temp);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("target_read_u32 failed");
+		return retval;
+	}
+
+	LOG_USER ("gcr_control = 0x%8.8x", temp);
+
+	retval = target_read_u32(target, gcr_base + 0x20, &temp);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("target_read_u32 failed");
+		return retval;
+	}
+
+	LOG_USER ("gcr_access  = 0x%8.8x", temp);
+
+	retval = target_read_u32(target, gcr_base + 0x30, &temp);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("target_read_u32 failed");
+		return retval;
+	}
+
+	LOG_USER ("gcr_rev     = 0x%8.8x", temp);
+
+	gic_base = mips_get_gic (target, &retval);
+	if (retval != ERROR_OK)
+		return retval;
+
+	cpc_base = mips_get_cpc (target, &retval);
+	if (retval != ERROR_OK)
+		return retval;
+
+	LOG_USER ("gic_base    = 0x%8.8x", gic_base);
+	mips_restore_gic_enable_state(target);
+	LOG_USER ("cpc_base    = 0x%8.8x", cpc_base);
+	mips_restore_cpc_enable_state(target);
+	return ERROR_OK;
+}
+
+/*                                                                                     */
+/* Command is used to dump the Coherency Manager Global Configuration Registers.       */
+/* The Global Configuration Registers (GCR) are a set of memory-mapped registers that  */
+/* are used to configure and control various aspects of the Coherence Manager and the  */
+/* coherence scheme.                                                                   */
+/* See section 8.3.1 of Mips32 interAptiv Multiprocessing System Programmer's Guide    */
+/* Document available at: http://wiki.prplfoundation.org/wiki/MIPS_documentation       */
+/*                                                                                     */
+COMMAND_HANDLER(mips_dump_lcr_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	struct mips32_common *mips32 = target_to_mips32(target);
+	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
+	
+	if (CMD_ARGC > 1){
+		LOG_DEBUG("ERROR_COMMAND_SYNTAX_ERROR");
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	if (target->state != TARGET_HALTED) {
+		command_print(CMD_CTX, "target must be stopped for \"%s\" command", CMD_NAME);
+		return ERROR_OK;
+	}
+
+	uint32_t core = 0;
+	uint32_t offset = 0x2000;
+
+	if (CMD_ARGC != 0){
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], core);
+		offset = 0x4000;
+	}
+		
+	uint32_t config3; /*	cp0 config - 16, 3 */
+
+	int retval = -1;
+
+	/* Read Config3 */
+	if ((retval = mips32_pracc_cp0_read(ejtag_info, &config3, 16, 3))!= ERROR_OK)
+		return retval;
+
+	/* Determine if CMGCRBASE register is implemented */
+	if ((config3 & 0x8) == 0){
+		LOG_USER("CMGCRBASE not configured");
+		return ERROR_OK;
+	}
+
+	uint32_t cmgcrbase; /*	cp0 config - 15, 3 */
+
+	/* Read cmgcrbase config register */
+	if ((retval = mips32_pracc_cp0_read(ejtag_info, &cmgcrbase, 15, 3)) != ERROR_OK)
+		return retval;
+
+	uint32_t gcr_base;
+	uint32_t temp;
+
+	gcr_base = ((cmgcrbase << 4) + 0xa0000000) ;
+
+	/* GCR CL (gcr_base+0) Base address */
+	if (core != 0){
+		retval = target_write_u32(target, gcr_base + 0x2018, (core << 16));
+		if (retval != ERROR_OK) {
+			LOG_DEBUG("target_read_u32 failed");
+			return retval;
+		}
+
+		LOG_USER ("GCR CL Other = 0x%8.8x", gcr_base + offset);
+	}
+	else
+		LOG_USER ("GCR CL       = 0x%8.8x", gcr_base + offset);
+
+	/* cl_coherence (gcr_base+0x2000/0x4000 + 0x8 - Core-Local Coherence Control. */
+	retval = target_read_u32(target, gcr_base + offset + 0x08, &temp);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("target_read_u32 failed");
+		return retval;
+	}
+
+	LOG_USER ("cl_coherence = 0x%8.8x", temp);
+
+	/* cl_config (gcr_base+0x2000/0x4000 + 0x10) - Core-Local Configuration */
+	retval = target_read_u32(target, gcr_base + offset + 0x10, &temp);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("target_read_u32 failed");
+		return retval;
+	}
+
+	LOG_USER ("cl_config    = 0x%8.8x", temp);
+
+	/* cl_other (gcr_base+0x2000/0x4000 + 0x18) - Core-Other Addressing */
+	retval = target_read_u32(target, gcr_base + offset + 0x18, &temp);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("target_read_u32 failed");
+		return retval;
+	}
+
+	LOG_USER ("cl_other     = 0x%8.8x", temp);
+
+	/* cl_resetbase (gcr_base+0x2000/0x4000 + 0x20) - Reset Exception Base for the local core. */
+	retval = target_read_u32(target, gcr_base + offset + 0x20, &temp);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("target_read_u32 failed");
+		return retval;
+	}
+
+	LOG_USER ("cl_resetbase = 0x%8.8x", temp);
+
+	/* cl_id (gcr_base+0x2000/0x4000 + 0x28) - Indicates the ID number of the local core. */
+	retval = target_read_u32(target, gcr_base + offset + 0x28, &temp);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("target_read_u32 failed");
+		return retval;
+	}
+
+	LOG_USER ("cl_id        = 0x%8.8x", temp);
+
+	return ERROR_OK;
+}
+
+/*                                                                                     */
+/* Command is used to dump the Cluster Power Controller Global Control Block Registers */
+/* See section 7.3.2 of Mips32 interAptiv Multiprocessing System Programmer's Guide    */
+/* Document available at: http://wiki.prplfoundation.org/wiki/MIPS_documentation       */
+/*                                                                                     */
+COMMAND_HANDLER(mips_dump_cpc_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	struct mips32_common *mips32 = target_to_mips32(target);
+	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
+	
+	if (CMD_ARGC >= 1){
+		LOG_DEBUG("ERROR_COMMAND_SYNTAX_ERROR");
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	if (target->state != TARGET_HALTED) {
+		command_print(CMD_CTX, "target must be stopped for \"%s\" command", CMD_NAME);
+		return ERROR_OK;
+	}
+
+	uint32_t cpc_base = 0;
+	uint32_t temp;
+
+	uint32_t config3; /*	cp0 config - 16, 3 */
+	uint32_t cmgcrbase; /*	cp0 config - 15, 3 */
+
+	int retval = -1;
+
+	if ((retval = mips32_pracc_cp0_read(ejtag_info, &config3, 16, 3))!= ERROR_OK)
+		return retval;
+
+	/* Read Config3 to determine if CMGCRBASE register is implemented */
+	if ((config3 & 0x8) == 0){
+		LOG_USER("CMGCRBASE not configured");
+		return ERROR_OK;
+	}
+
+	/* Read cmgcrbase config register */
+	if ((retval = mips32_pracc_cp0_read(ejtag_info, &cmgcrbase, 15, 3)) != ERROR_OK)
+		return retval;
+
+	/* get CPC base */
+	cpc_base = mips_get_cpc (target, &retval);
+	if (retval != ERROR_OK)
+		return retval;
+
+	LOG_USER ("CPC_BASE         = 0x%8.8x", cpc_base);
+
+	/* CPC_ACCESS_REG (cpc_base + 0) - Controls which cores can modify the CPC Registers.*/
+	retval = target_read_u32(target, cpc_base, &temp);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("target_read_u32 failed");
+		goto exit;
+	}
+
+	LOG_USER ("CPC_ACCESS_REG   = 0x%x", temp);
+
+	/* CPC_SEQDEL_REG (cpc_base + 8) - Time between microsteps of a CPC domain */
+	/*                                 sequencer in CPC clock cycles.          */
+	retval = target_read_u32(target, cpc_base + 0x8, &temp);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("target_read_u32 failed");
+		goto exit;
+	}
+
+	LOG_USER ("CPC_SEQDEL_REG   = 0x%x", temp);
+
+	/* CPC_RAIL_REG (cpc_base + 0x10) - Rail power-up timer to delay CPS            */
+    /*                                  sequencer progress until the gated rail has */
+    /*                                  stabilized.                                 */
+	retval = target_read_u32(target, cpc_base + 0x10, &temp);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("target_read_u32 failed");
+		goto exit;
+	}
+
+	LOG_USER ("CPC_RAIL_REG     = 0x%x", temp);
+
+	/* CPC_RESETLEN_REG (cpc_base + 0x18) - Duration of any domain reset sequence. */
+	retval = target_read_u32(target, cpc_base + 0x18, &temp);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("target_read_u32 failed");
+		goto exit;
+	}
+
+	LOG_USER ("CPC_RESETLEN_REG = 0x%x", temp);
+
+	/* CPC_REVISION_REG (cpc_base + 0x20) - RTL Revision of CPC */
+	retval = target_read_u32(target, cpc_base + 0x20, &temp);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("target_read_u32 failed");
+		goto exit;
+	}
+
+	LOG_USER ("CPC_REVISION_REG = 0x%x", temp);
+
+exit:
+	mips_restore_cpc_enable_state(target);
+	return ERROR_OK;
+}
+
+/*                                                                                      */
+/* Command is used to dump the Cluster Power Controller Local and Core-Other Control    */
+/* Block. See section 7.3.4 of Mips32 interAptiv Multiprocessing System Programmer's    */
+/* Guide. Document available at: http://wiki.prplfoundation.org/wiki/MIPS_documentation */
+/*                                                                                      */
+COMMAND_HANDLER(mips_dump_cpc_lcr_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	struct mips32_common *mips32 = target_to_mips32(target);
+	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
+	uint32_t cpc_stat_conf;
+
+	if (CMD_ARGC > 1){
+		LOG_DEBUG("ERROR_COMMAND_SYNTAX_ERROR");
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	if (target->state != TARGET_HALTED) {
+		command_print(CMD_CTX, "target must be stopped for \"%s\" command", CMD_NAME);
+		return ERROR_OK;
+	}
+
+	uint32_t core = 0;
+	uint32_t offset = 0x2000;
+
+	if (CMD_ARGC != 0){
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], core);
+		offset = 0x4000;
+	}
+
+	uint32_t config3; /*	cp0 config - 16, 3 */
+	uint32_t cmgcrbase; /*	cp0 config - 15, 3 */
+
+	int retval = -1;
+
+	if ((retval = mips32_pracc_cp0_read(ejtag_info, &config3, 16, 3))!= ERROR_OK)
+		return retval;
+
+	/* May need to read Config3 to determine if CMGCRBASE register is implemented */
+	if ((config3 & 0x8) == 0){
+		LOG_USER("CMGCRBASE not configured");
+		return ERROR_OK;
+	}
+
+	/* Read cmgcrbase config register */
+	if ((retval = mips32_pracc_cp0_read(ejtag_info, &cmgcrbase, 15, 3)) != ERROR_OK)
+		return retval;
+
+	uint32_t cpc_base;
+	uint32_t temp;
+
+	/* get CPC base */
+	cpc_base = mips_get_cpc (target, &retval);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (core != 0){
+		LOG_USER ("CPC CL Other         = 0x%8.8x", cpc_base + offset);
+		retval = target_write_u32(target, cpc_base + 0x2010, (core << 16));
+		if (retval != ERROR_OK) {
+			LOG_DEBUG("target_read_u32 failed");
+			return retval;
+		}
+	}
+	else
+		LOG_USER ("CPC CL               = 0x%8.8x", cpc_base + offset);
+
+	/* CPC_CL_CMD_REG (cpc_base+0x2000/0x4000) - Places a new CPC domain state command */
+	/* into this individual domain sequencer. This register is not available    */
+	/* within the CM sequencer. Writes to the CM CMD register are ignored while */
+	/* reads will return zero.                                                  */
+	retval = target_read_u32(target, cpc_base + offset, &temp);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("target_read_u32 failed");
+		goto exit;
+	}
+
+	LOG_USER ("CPC_CL_CMD_REG       = 0x%x", temp);
+
+	retval = target_read_u32(target, cpc_base + offset + 0x10, &temp);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("target_read_u32 failed");
+		goto exit;
+	}
+
+	LOG_USER ("CPC_CL_OTHER_REG     = 0x%x", temp);
+	
+	retval = target_read_u32(target, cpc_base + offset + 0x8, &cpc_stat_conf);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("target_read_u32 failed");
+		goto exit;
+	}
+
+    LOG_USER ("\nCPC_CL_STAT_CONF_REG = 0x%8.8x", cpc_stat_conf);
+
+	LOG_USER(" Decode of CPC_CL_STAT_CONF_REG");
+	LOG_USER(" ------------------------------");
+
+	/* Decode Seq State */
+	// int seq_state;
+	char text[20]={0};
+	
+	LOG_USER("      PWRUP_EVENT (23) = 0x%x", (cpc_stat_conf >> 23) & 1);
+
+	switch ((cpc_stat_conf >> 19) & 0xf) {
+		case 0:
+			strcpy (text,"D0 - PwrDwn");
+			break;
+		case 1:
+			strcpy (text,"U0 - VddOK");
+			break;
+		case 2:
+			strcpy (text,"U1 - UpDelay");
+			break;
+		case 3:
+			strcpy (text,"U2 - UClkOff");
+			break;
+		case 4:
+			strcpy (text,"U3 - Reset");
+			break;
+		case 5:
+			strcpy (text,"U4 - ResetDly");
+			break;
+		case 6:
+			strcpy (text,"U5 - nonCoherent");
+			break;
+		case 7:
+			strcpy (text,"U6 - Coherent");
+			break;
+		case 8:
+			strcpy (text,"D1 - Isolate");
+			break;
+		case 9:
+			strcpy (text,"D3 - ClrBus");
+			break;
+		case 10:
+			strcpy (text,"D2 - DClkOff");
+			break;
+		default:
+		{
+			strcpy (text,"Invalid");
+		}
+	}
+
+	LOG_USER("     SEQ_STATE (22:19) = 0x%x (%s)", ((cpc_stat_conf >> 19) & 0xf), text);
+	LOG_USER("      CLKGAT_IMPL (17) = 0x%x",((cpc_stat_conf >> 17) & 0x1));
+	LOG_USER("       PWRDN_IMPL (16) = 0x%x", ((cpc_stat_conf >> 16) & 0x1));
+	LOG_USER("      EJTAG_PROBE (15) = 0x%x", ((cpc_stat_conf >> 15) & 0x1));
+	LOG_USER("     PWUP_POLICY (9:8) = 0x%x", ((cpc_stat_conf >> 8) & 0x3));
+	LOG_USER("       IO_TRFFC_EN (4) = 0x%x", ((cpc_stat_conf >> 4) & 0x1));
+
+	switch (cpc_stat_conf & 0xf) {
+		case 0:
+			strcpy (text,"none");
+			break;
+		case 1:
+			strcpy (text,"ClockOff");
+			break;
+		case 2:
+			strcpy (text,"PwrDown");
+			break;
+		case 3:
+			strcpy (text,"PwrUp");
+			break;
+		case 4:
+			strcpy (text,"Reset");
+			break;
+		default:
+		{
+			strcpy (text,"reserved");
+		}
+    }
+
+	LOG_USER("             CMD (3:0) = 0x%x (%s)", (cpc_stat_conf & 0xf), text);
+
+exit:	
+	mips_restore_cpc_enable_state(target);
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(mips_dump_gic_shared_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	struct mips32_common *mips32 = target_to_mips32(target);
+	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
+	
+	if (CMD_ARGC >= 1){
+		LOG_DEBUG("ERROR_COMMAND_SYNTAX_ERROR");
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	if (target->state != TARGET_HALTED) {
+		command_print(CMD_CTX, "target must be stopped for \"%s\" command", CMD_NAME);
+		return ERROR_OK;
+	}
+
+	uint32_t gic_base;
+	uint32_t temp;
+
+	uint32_t config3; /*	cp0 config - 16, 3 */
+	uint32_t cmgcrbase; /*	cp0 config - 15, 3 */
+
+	int retval = ERROR_OK;
+
+	/* Read Config3 register */
+	if ((retval = mips32_pracc_cp0_read(ejtag_info, &config3, 16, 3))!= ERROR_OK)
+		return retval;
+
+	/* Examine Config3 to determine if CMGCRBASE register is implemented */
+	if ((config3 & 0x8) == 0){
+		LOG_USER("CMGCRBASE not configured");
+		return ERROR_OK;
+	}
+
+	/* Read cmgcrbase config register */
+	if ((retval = mips32_pracc_cp0_read(ejtag_info, &cmgcrbase, 15, 3)) != ERROR_OK)
+		return retval;
+
+	gic_base = mips_get_gic (target, &retval);
+	if (retval != ERROR_OK) {
+		return retval;
+	}
+
+	LOG_USER ("GIC BASE = 0x%8.8x", gic_base);
+
+	retval = target_read_u32(target, gic_base, &temp);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("target_read_u32 failed");
+		goto exit;
+	}
+
+	LOG_USER ("GIC_SH_CONFIG_REG    = 0x%8.8x", temp);
+
+	retval = target_read_u32(target, gic_base + 0x10, &temp);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("target_read_u32 failed");
+		goto exit;
+	}
+
+	LOG_USER ("GIC_SH_CounterLo_REG = 0x%8.8x", temp);
+
+	retval = target_read_u32(target, gic_base + 0x14, &temp);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("target_read_u32 failed");
+		goto exit;
+	}
+
+	LOG_USER ("GIC_SH_CounterHi_REG = 0x%8.8x", temp);
+
+	retval = target_read_u32(target, gic_base + 0x20, &temp);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("target_read_u32 failed");
+		goto exit;
+	}
+
+	LOG_USER ("GIC_RevisionID_REG   = 0x%8.8x", temp);
+
+exit:
+	mips_restore_gic_enable_state(target);
+	return retval;;
+}
+
+COMMAND_HANDLER(mips_dump_gic_local_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	struct mips32_common *mips32 = target_to_mips32(target);
+	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
+	
+	if (CMD_ARGC >= 1){
+		LOG_DEBUG("ERROR_COMMAND_SYNTAX_ERROR");
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	if (target->state != TARGET_HALTED) {
+		command_print(CMD_CTX, "target must be stopped for \"%s\" command", CMD_NAME);
+		return ERROR_OK;
+	}
+
+	uint32_t gic_base;
+	uint32_t gic_vpe_local_base;
+	uint32_t temp;
+
+	uint32_t config3; /*	cp0 config - 16, 3 */
+	uint32_t cmgcrbase; /*	cp0 config - 15, 3 */
+
+	int retval = ERROR_OK;
+
+	if ((retval = mips32_pracc_cp0_read(ejtag_info, &config3, 16, 3))!= ERROR_OK)
+		return retval;
+
+	/* May need to read Config3 to determine if CMGCRBASE register is implemented */
+	if ((config3 & 0x8) == 0){
+		LOG_USER("CMGCRBASE not configured");
+		return ERROR_OK;
+	}
+
+	/* Read cmgcrbase config register */
+	if ((retval = mips32_pracc_cp0_read(ejtag_info, &cmgcrbase, 15, 3)) != ERROR_OK)
+		return retval;
+
+	gic_base = mips_get_gic (target, &retval);
+	if (retval != ERROR_OK)
+		return retval;
+
+	gic_vpe_local_base = gic_base + 0x8000;
+	LOG_USER ("GIC_VPE_LOCAL_BASE      = 0x%8.8x", gic_vpe_local_base);
+
+	retval = target_read_u32(target, gic_vpe_local_base + 0x80, &temp);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("target_read_u32 failed");
+		goto exit;
+	}
+
+	LOG_USER ("GIC_VPEi_OTHER_ADDR     = 0x%8.8x", temp);
+
+	retval = target_read_u32(target, gic_vpe_local_base + 0x88, &temp);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("target_read_u32 failed");
+		goto exit;
+	}
+
+	LOG_USER ("GIC_VPEi_IDENT          = 0x%8.8x", temp);
+
+	retval = target_read_u32(target, gic_vpe_local_base + 0x90, &temp);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("target_read_u32 failed");
+		goto exit;
+	}
+
+	LOG_USER ("GIC_VPEi_WD_CONFIG0     = 0x%8.8x", temp);
+
+	retval = target_read_u32(target, gic_vpe_local_base + 0x94, &temp);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("target_read_u32 failed");
+		goto exit;
+	}
+
+	LOG_USER ("GIC_VPEi_WD_COUNT0      = 0x%8.8x", temp);
+
+	retval = target_read_u32(target, gic_vpe_local_base + 0x3000, &temp);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("target_read_u32 failed");
+		goto exit;
+	}
+
+	LOG_USER ("GIC_VPEi_DINT           = 0x%x", temp);
+
+	retval = target_read_u32(target, gic_vpe_local_base + 0x3080, &temp);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("target_read_u32 failed");
+		goto exit;
+	}
+
+	LOG_USER ("GIC_VPEi_LOCAL_DEBUG_GR = 0x%8.8x", temp);
+
+	retval = target_read_u32(target, gic_vpe_local_base + 0x88, &temp);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("target_read_u32 failed");
+	}
+
+exit:
+	mips_restore_gic_enable_state(target);
+	return retval;
+}
+
+static const struct command_registration mips_iAptiv_exec_command_handlers[] = {
+	{
+		.name = "cmdall",
+		.handler = mips_ia_handle_cmdall_command,
+		.mode = COMMAND_EXEC,
+		.usage = "halt",
+		.help = "cmdall halt command will halt all cores",
+	},
+	{
+		.name = "dump_gcr",
+		.handler = mips_dump_gcr_command,
+		.mode = COMMAND_EXEC,
+		.usage = "dump_gcr",
+		.help = "dump GCR registers",
+	},
+	{
+		.name = "dump_lcr",
+		.handler = mips_dump_lcr_command,
+		.mode = COMMAND_EXEC,
+		.usage = "dump_lcr [core]",
+		.help = "dump GCR local registers",
+	},
+	{
+		.name = "dump_gic_shared",
+		.handler = mips_dump_gic_shared_command,
+		.mode = COMMAND_EXEC,
+		.usage = "dump_gic_shared",
+		.help = "dump Global Interrupt Controller Shared",
+	},
+	{
+		.name = "dump_gic_local",
+		.handler = mips_dump_gic_local_command,
+		.mode = COMMAND_EXEC,
+		.usage = "dump_gic_local",
+		.help = "dump Global Interrupt Controller Local Registers",
+	},
+	{
+		.name = "dump_cpc",
+		.handler = mips_dump_cpc_command,
+		.mode = COMMAND_EXEC,
+		.usage = "dump_cpc",
+		.help = "Dump Cluster Power Controller",
+	},
+	{
+		.name = "dump_cpc_lcr",
+		.handler = mips_dump_cpc_lcr_command,
+		.mode = COMMAND_ANY,
+		.usage = "dump_cpc_lcr [core]",
+		.help = "Dump Cluster Power Controller Local/Other Command Registers",
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+const struct command_registration mips_iAptiv_command_handlers[] = {
+	{
+		.chain = mips32_command_handlers,
+	},
+	{
+		.name = "mips_iA",
+		.mode = COMMAND_ANY,
+		.help = "mips_iA command group",
+		.usage = "",
+		.chain = mips_iAptiv_exec_command_handlers,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+struct target_type mips_iAptiv_target = {
+	.name = "mips_iAptiv",
+
+	.poll = mips_common_poll,
+	.arch_state = mips32_arch_state,
+
+	.halt = mips_common_halt,
+	.resume = mips_common_resume,
+	.step = mips_common_step,
+
+	.assert_reset = mips_common_assert_reset,
+	.deassert_reset = mips_common_deassert_reset,
+
+	.get_gdb_reg_list = mips32_get_gdb_reg_list,
+
+	.read_memory = mips_common_read_memory,
+	.write_memory = mips_common_write_memory,
+	.checksum_memory = mips32_checksum_memory,
+	.blank_check_memory = mips32_blank_check_memory,
+
+	.run_algorithm = mips32_run_algorithm,
+
+	.add_breakpoint = mips_common_add_breakpoint,
+	.remove_breakpoint = mips_common_remove_breakpoint,
+	.add_watchpoint = mips_common_add_watchpoint,
+	.remove_watchpoint = mips_common_remove_watchpoint,
+
+	.commands = mips_iAptiv_command_handlers,
+	.target_create = mips_iAptiv_target_create,
+	.init_target = mips_common_init_target,
+	.examine = mips_common_examine,
+};
diff --git b/src/target/mips_iAptiv.h a/src/target/mips_iAptiv.h
new file mode 100644
index 000000000..a10054451
--- /dev/null
+++ a/src/target/mips_iAptiv.h
@@ -0,0 +1,150 @@
+/***************************************************************************
+ *   Copyright (C) 2008 by Spencer Oliver                                  *
+ *   spen@spen-soft.co.uk                                                  *
+ *                                                                         *
+ *   Copyright (C) 2008 by David T.L. Wong                                 *
+ *                                                                         *
+ *   Copyright (C) 2011 by Drasko DRASKOVIC                                *
+ *   drasko.draskovic@gmail.com                                            *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef MIPS_IAPTIV_H
+#define MIPS_IAPTIV_H
+
+struct target;
+
+#define MIPS_IAPTIV_COMMON_MAGIC	0xB321B321
+
+#define MIPS_IA_NUMCP0REGS 95
+
+static const struct {
+	unsigned reg;
+	unsigned sel;
+	const char *name;
+} mips32_iA_cp0_regs[MIPS_IA_NUMCP0REGS] = {
+  { 0, 0, "index"},
+  { 0, 1, "mvpcontrol"},
+  { 0, 2, "mvpconf0"},
+  { 0, 3, "mvpconf1"},
+  { 1, 0, "Random"},
+  { 1, 1, "VPEControl"},
+  { 1, 2, "VPEConf0"},
+  { 1, 3, "VPEConf1"},
+  { 1, 4, "YQMask"},
+  { 1, 5, "VPESchedule"},
+  { 1, 6, "VPEScheFBack"},
+  { 1, 7, "VPEOpt"},
+  { 2, 0, "EntryLo0"},
+  { 2, 1, "TCStatus"},
+  { 2, 2, "TCBind"},
+  { 2, 3, "TCRestart"},
+  { 2, 4, "TCHalt"},
+  { 2, 5, "TCContext"},
+  { 2, 6, "TCSchedule"},
+  { 2, 7, "TCScheFBack"},
+  { 3, 0, "EntryLo1"},
+  { 3, 7, "TCOpt"},
+  { 4, 0, "Context"},
+  { 4, 2, "userlocal"},
+  { 5, 0, "PageMask"},
+  { 5, 2, "SegCtl0"},
+  { 5, 3, "SegCtl1"},
+  { 5, 4, "SegCtl2"},
+  { 6, 0, "Wired"},
+  { 6, 1, "SRSConf0"},
+  { 6, 2, "SRSConf1"},
+  { 6, 3, "SRSConf2"},
+  { 6, 4, "SRSConf3"},
+  { 6, 5, "SRSConf4"},
+  { 7, 0, "hwrena"},
+  { 8, 0, "badvaddr"},
+  { 9, 0, "Count"},
+  { 10, 0, "EntryHi"},
+  { 11, 0, "compare"},
+  { 11, 4, "GuestCtl0Ext"},
+  { 12, 0, "status"},
+  { 12, 1, "intctl"},
+  { 12, 2, "srsctl"},
+  { 12, 3, "SRSMap2"},
+  { 13, 0, "cause"},
+  { 14, 0, "epc"},
+  { 14, 2, "nestedepc"},
+  { 15, 0, "prid"},
+  { 15, 1, "ebase"},
+  { 15, 2, "cdmmbase"},
+  { 15, 3, "CMGCRBase"},
+  { 16, 0, "config"},
+  { 16, 1, "config1"},
+  { 16, 2, "config2"},
+  { 16, 3, "config3"},
+  { 16, 4, "config4"},
+  { 16, 5, "config5"},
+  { 16, 7, "config7"},
+  { 17, 0, "lladdr"},
+  { 18, 0, "WatchLo0"},
+  { 18, 1, "WatchLo1"},
+  { 18, 2, "WatchLo2"},
+  { 18, 3, "WatchLo3"},
+  { 19, 0, "WatchHi0"},
+  { 19, 1, "WatchHi1"},
+  { 19, 2, "WatchHi2"},
+  { 19, 3, "WatchHi3"},
+  { 23, 0, "debug"},
+  { 23, 6, "Debug2"},
+  { 23, 1, "tracecontrol"},
+  { 23, 2, "tracecontrol2"},
+  { 23, 3, "usertracedata1"},
+  { 23, 4, "TraceIBPC"},
+  { 23, 5, "TraceDBPC"},
+  { 24, 0, "depc"},
+  { 24, 2, "TraceControl3"},
+  { 24, 3, "usertracedata2"},
+  { 25, 0, "perfctl0"},
+  { 25, 1, "perfcnt0"},
+  { 25, 2, "perfctl1"},
+  { 25, 3, "perfcnt1"},
+  { 26, 0, "errctl"},
+  { 27, 0, "CacheErr"},
+  { 28, 0, "ITagLo"},
+  { 28, 1, "IDataLo"},
+  { 28, 2, "DTagLo"},
+  { 28, 3, "DDataLo"},
+  { 28, 4, "L23TagLo"},
+  { 28, 5, "L23DataLo"},
+  { 29, 1, "IDataHi"},
+  { 29, 2, "DTagHi"},
+  { 29, 5, "L23DataHi"},
+  { 30, 0, "errorepc"},
+  { 31, 0, "desave"},
+};
+
+struct mips_iAptiv_common {
+	uint32_t common_magic;
+	bool is_pic32;
+	struct mips32_common mips32;
+};
+
+inline struct mips_iAptiv_common *target_to_iAptiv(struct target *target)
+{
+	return container_of(target->arch_info,
+			struct mips_iAptiv_common, mips32);
+}
+
+extern const struct command_registration mips_iAptiv_command_handlers[];
+
+#endif	/*MIPS_IAPTIV_H*/
diff --git b/src/target/mips_m4k.c a/src/target/mips_m4k.c
index 5b740cc45..d9fdd9461 100644
--- b/src/target/mips_m4k.c
+++ a/src/target/mips_m4k.c
@@ -1,28 +1,31 @@
 /***************************************************************************
- *   Copyright (C) 2008 by Spencer Oliver                                  *
- *   spen@spen-soft.co.uk                                                  *
- *                                                                         *
- *   Copyright (C) 2008 by David T.L. Wong                                 *
- *                                                                         *
- *   Copyright (C) 2009 by David N. Claffey <dnclaffey@gmail.com>          *
- *                                                                         *
- *   Copyright (C) 2011 by Drasko DRASKOVIC                                *
- *   drasko.draskovic@gmail.com                                            *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *	 Copyright (C) 2008 by Spencer Oliver								   *
+ *	 spen@spen-soft.co.uk												   *
+ *																		   *
+ *	 Copyright (C) 2008 by David T.L. Wong								   *
+ *																		   *
+ *	 Copyright (C) 2009 by David N. Claffey <dnclaffey@gmail.com>		   *
+ *																		   *
+ *	 Copyright (C) 2011 by Drasko DRASKOVIC								   *
+ *	 drasko.draskovic@gmail.com											   *
+ *																		   *
+ *	 Copyright (C) 2014 by Kent Brinkley								   *
+ *	 jkbrinkley_imgtec@gmail.com										   *
+ *																		   *
+ *	 This program is free software; you can redistribute it and/or modify  *
+ *	 it under the terms of the GNU General Public License as published by  *
+ *	 the Free Software Foundation; either version 2 of the License, or	   *
+ *	 (at your option) any later version.								   *
+ *																		   *
+ *	 This program is distributed in the hope that it will be useful,	   *
+ *	 but WITHOUT ANY WARRANTY; without even the implied warranty of		   *
+ *	 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the		   *
+ *	 GNU General Public License for more details.						   *
+ *																		   *
+ *	 You should have received a copy of the GNU General Public License	   *
+ *	 along with this program; if not, write to the						   *
+ *	 Free Software Foundation, Inc.,									   *
+ *	 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.		   *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -32,1061 +35,21 @@
 #include "breakpoints.h"
 #include "mips32.h"
 #include "mips_m4k.h"
+#include "mips_common.h"
 #include "mips32_dmaacc.h"
 #include "target_type.h"
 #include "register.h"
 
-static void mips_m4k_enable_breakpoints(struct target *target);
-static void mips_m4k_enable_watchpoints(struct target *target);
-static int mips_m4k_set_breakpoint(struct target *target,
-		struct breakpoint *breakpoint);
-static int mips_m4k_unset_breakpoint(struct target *target,
-		struct breakpoint *breakpoint);
-static int mips_m4k_internal_restore(struct target *target, int current,
-		uint32_t address, int handle_breakpoints,
-		int debug_execution);
-static int mips_m4k_halt(struct target *target);
-static int mips_m4k_bulk_write_memory(struct target *target, uint32_t address,
-		uint32_t count, const uint8_t *buffer);
-
-static int mips_m4k_examine_debug_reason(struct target *target)
-{
-	struct mips32_common *mips32 = target_to_mips32(target);
-	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
-	uint32_t break_status;
-	int retval;
-
-	if ((target->debug_reason != DBG_REASON_DBGRQ)
-			&& (target->debug_reason != DBG_REASON_SINGLESTEP)) {
-		if (ejtag_info->debug_caps & EJTAG_DCR_IB) {
-			/* get info about inst breakpoint support */
-			retval = target_read_u32(target,
-				ejtag_info->ejtag_ibs_addr, &break_status);
-			if (retval != ERROR_OK)
-				return retval;
-			if (break_status & 0x1f) {
-				/* we have halted on a  breakpoint */
-				retval = target_write_u32(target,
-					ejtag_info->ejtag_ibs_addr, 0);
-				if (retval != ERROR_OK)
-					return retval;
-				target->debug_reason = DBG_REASON_BREAKPOINT;
-			}
-		}
-
-		if (ejtag_info->debug_caps & EJTAG_DCR_DB) {
-			/* get info about data breakpoint support */
-			retval = target_read_u32(target,
-				ejtag_info->ejtag_dbs_addr, &break_status);
-			if (retval != ERROR_OK)
-				return retval;
-			if (break_status & 0x1f) {
-				/* we have halted on a  breakpoint */
-				retval = target_write_u32(target,
-					ejtag_info->ejtag_dbs_addr, 0);
-				if (retval != ERROR_OK)
-					return retval;
-				target->debug_reason = DBG_REASON_WATCHPOINT;
-			}
-		}
-	}
-
-	return ERROR_OK;
-}
-
-static int mips_m4k_debug_entry(struct target *target)
-{
-	struct mips32_common *mips32 = target_to_mips32(target);
-	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
-
-	mips32_save_context(target);
-
-	/* make sure stepping disabled, SSt bit in CP0 debug register cleared */
-	mips_ejtag_config_step(ejtag_info, 0);
-
-	/* make sure break unit configured */
-	mips32_configure_break_unit(target);
-
-	/* attempt to find halt reason */
-	mips_m4k_examine_debug_reason(target);
-
-	/* default to mips32 isa, it will be changed below if required */
-	mips32->isa_mode = MIPS32_ISA_MIPS32;
-
-	if (ejtag_info->impcode & EJTAG_IMP_MIPS16)
-		mips32->isa_mode = buf_get_u32(mips32->core_cache->reg_list[MIPS32_PC].value, 0, 1);
-
-	LOG_DEBUG("entered debug state at PC 0x%" PRIx32 ", target->state: %s",
-			buf_get_u32(mips32->core_cache->reg_list[MIPS32_PC].value, 0, 32),
-			target_state_name(target));
-
-	return ERROR_OK;
-}
-
-static struct target *get_mips_m4k(struct target *target, int32_t coreid)
-{
-	struct target_list *head;
-	struct target *curr;
-
-	head = target->head;
-	while (head != (struct target_list *)NULL) {
-		curr = head->target;
-		if ((curr->coreid == coreid) && (curr->state == TARGET_HALTED))
-			return curr;
-		head = head->next;
-	}
-	return target;
-}
-
-static int mips_m4k_halt_smp(struct target *target)
-{
-	int retval = ERROR_OK;
-	struct target_list *head;
-	struct target *curr;
-	head = target->head;
-	while (head != (struct target_list *)NULL) {
-		int ret = ERROR_OK;
-		curr = head->target;
-		if ((curr != target) && (curr->state != TARGET_HALTED))
-			ret = mips_m4k_halt(curr);
-
-		if (ret != ERROR_OK) {
-			LOG_ERROR("halt failed target->coreid: %" PRId32, curr->coreid);
-			retval = ret;
-		}
-		head = head->next;
-	}
-	return retval;
-}
-
-static int update_halt_gdb(struct target *target)
-{
-	int retval = ERROR_OK;
-	if (target->gdb_service->core[0] == -1) {
-		target->gdb_service->target = target;
-		target->gdb_service->core[0] = target->coreid;
-		retval = mips_m4k_halt_smp(target);
-	}
-	return retval;
-}
-
-static int mips_m4k_poll(struct target *target)
-{
-	int retval = ERROR_OK;
-	struct mips32_common *mips32 = target_to_mips32(target);
-	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
-	uint32_t ejtag_ctrl = ejtag_info->ejtag_ctrl;
-	enum target_state prev_target_state = target->state;
-
-	/*  toggle to another core is done by gdb as follow */
-	/*  maint packet J core_id */
-	/*  continue */
-	/*  the next polling trigger an halt event sent to gdb */
-	if ((target->state == TARGET_HALTED) && (target->smp) &&
-		(target->gdb_service) &&
-		(target->gdb_service->target == NULL)) {
-		target->gdb_service->target =
-			get_mips_m4k(target, target->gdb_service->core[1]);
-		target_call_event_callbacks(target, TARGET_EVENT_HALTED);
-		return retval;
-	}
-
-	/* read ejtag control reg */
-	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL);
-	retval = mips_ejtag_drscan_32(ejtag_info, &ejtag_ctrl);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* clear this bit before handling polling
-	 * as after reset registers will read zero */
-	if (ejtag_ctrl & EJTAG_CTRL_ROCC) {
-		/* we have detected a reset, clear flag
-		 * otherwise ejtag will not work */
-		ejtag_ctrl = ejtag_info->ejtag_ctrl & ~EJTAG_CTRL_ROCC;
-
-		mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL);
-		retval = mips_ejtag_drscan_32(ejtag_info, &ejtag_ctrl);
-		if (retval != ERROR_OK)
-			return retval;
-		LOG_DEBUG("Reset Detected");
-	}
-
-	/* check for processor halted */
-	if (ejtag_ctrl & EJTAG_CTRL_BRKST) {
-		if ((target->state != TARGET_HALTED)
-		    && (target->state != TARGET_DEBUG_RUNNING)) {
-			if (target->state == TARGET_UNKNOWN)
-				LOG_DEBUG("EJTAG_CTRL_BRKST already set during server startup.");
-
-			/* OpenOCD was was probably started on the board with EJTAG_CTRL_BRKST already set
-			 * (maybe put on by HALT-ing the board in the previous session).
-			 *
-			 * Force enable debug entry for this session.
-			 */
-			mips_ejtag_set_instr(ejtag_info, EJTAG_INST_NORMALBOOT);
-			target->state = TARGET_HALTED;
-			retval = mips_m4k_debug_entry(target);
-			if (retval != ERROR_OK)
-				return retval;
-
-			if (target->smp &&
-				((prev_target_state == TARGET_RUNNING)
-			     || (prev_target_state == TARGET_RESET))) {
-				retval = update_halt_gdb(target);
-				if (retval != ERROR_OK)
-					return retval;
-			}
-			target_call_event_callbacks(target, TARGET_EVENT_HALTED);
-		} else if (target->state == TARGET_DEBUG_RUNNING) {
-			target->state = TARGET_HALTED;
-
-			retval = mips_m4k_debug_entry(target);
-			if (retval != ERROR_OK)
-				return retval;
-
-			if (target->smp) {
-				retval = update_halt_gdb(target);
-				if (retval != ERROR_OK)
-					return retval;
-			}
-
-			target_call_event_callbacks(target, TARGET_EVENT_DEBUG_HALTED);
-		}
-	} else
-		target->state = TARGET_RUNNING;
-
-/*	LOG_DEBUG("ctrl = 0x%08X", ejtag_ctrl); */
-
-	return ERROR_OK;
-}
-
-static int mips_m4k_halt(struct target *target)
-{
-	struct mips32_common *mips32 = target_to_mips32(target);
-	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
-
-	LOG_DEBUG("target->state: %s", target_state_name(target));
-
-	if (target->state == TARGET_HALTED) {
-		LOG_DEBUG("target was already halted");
-		return ERROR_OK;
-	}
-
-	if (target->state == TARGET_UNKNOWN)
-		LOG_WARNING("target was in unknown state when halt was requested");
-
-	if (target->state == TARGET_RESET) {
-		if ((jtag_get_reset_config() & RESET_SRST_PULLS_TRST) && jtag_get_srst()) {
-			LOG_ERROR("can't request a halt while in reset if nSRST pulls nTRST");
-			return ERROR_TARGET_FAILURE;
-		} else {
-			/* we came here in a reset_halt or reset_init sequence
-			 * debug entry was already prepared in mips_m4k_assert_reset()
-			 */
-			target->debug_reason = DBG_REASON_DBGRQ;
-
-			return ERROR_OK;
-		}
-	}
-
-	/* break processor */
-	mips_ejtag_enter_debug(ejtag_info);
-
-	target->debug_reason = DBG_REASON_DBGRQ;
-
-	return ERROR_OK;
-}
-
-static int mips_m4k_assert_reset(struct target *target)
-{
-	struct mips_m4k_common *mips_m4k = target_to_m4k(target);
-	struct mips_ejtag *ejtag_info = &mips_m4k->mips32.ejtag_info;
-
-	LOG_DEBUG("target->state: %s",
-		target_state_name(target));
-
-	enum reset_types jtag_reset_config = jtag_get_reset_config();
-
-	/* some cores support connecting while srst is asserted
-	 * use that mode is it has been configured */
-
-	bool srst_asserted = false;
-
-	if (!(jtag_reset_config & RESET_SRST_PULLS_TRST) &&
-			(jtag_reset_config & RESET_SRST_NO_GATING)) {
-		jtag_add_reset(0, 1);
-		srst_asserted = true;
-	}
-
-
-	/* EJTAG before v2.5/2.6 does not support EJTAGBOOT or NORMALBOOT */
-	if (ejtag_info->ejtag_version != EJTAG_VERSION_20) {
-		if (target->reset_halt) {
-			/* use hardware to catch reset */
-			mips_ejtag_set_instr(ejtag_info, EJTAG_INST_EJTAGBOOT);
-		} else
-			mips_ejtag_set_instr(ejtag_info, EJTAG_INST_NORMALBOOT);
-	}
-
-	if (jtag_reset_config & RESET_HAS_SRST) {
-		/* here we should issue a srst only, but we may have to assert trst as well */
-		if (jtag_reset_config & RESET_SRST_PULLS_TRST)
-			jtag_add_reset(1, 1);
-		else if (!srst_asserted)
-			jtag_add_reset(0, 1);
-	} else {
-		if (mips_m4k->is_pic32mx) {
-			LOG_DEBUG("Using MTAP reset to reset processor...");
-
-			/* use microchip specific MTAP reset */
-			mips_ejtag_set_instr(ejtag_info, MTAP_SW_MTAP);
-			mips_ejtag_set_instr(ejtag_info, MTAP_COMMAND);
-
-			mips_ejtag_drscan_8_out(ejtag_info, MCHP_ASERT_RST);
-			mips_ejtag_drscan_8_out(ejtag_info, MCHP_DE_ASSERT_RST);
-			mips_ejtag_set_instr(ejtag_info, MTAP_SW_ETAP);
-		} else {
-			/* use ejtag reset - not supported by all cores */
-			uint32_t ejtag_ctrl = ejtag_info->ejtag_ctrl | EJTAG_CTRL_PRRST | EJTAG_CTRL_PERRST;
-			LOG_DEBUG("Using EJTAG reset (PRRST) to reset processor...");
-			mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL);
-			mips_ejtag_drscan_32_out(ejtag_info, ejtag_ctrl);
-		}
-	}
-
-	target->state = TARGET_RESET;
-	jtag_add_sleep(50000);
-
-	register_cache_invalidate(mips_m4k->mips32.core_cache);
-
-	if (target->reset_halt) {
-		int retval = target_halt(target);
-		if (retval != ERROR_OK)
-			return retval;
-	}
-
-	return ERROR_OK;
-}
-
-static int mips_m4k_deassert_reset(struct target *target)
-{
-	LOG_DEBUG("target->state: %s", target_state_name(target));
-
-	/* deassert reset lines */
-	jtag_add_reset(0, 0);
-
-	return ERROR_OK;
-}
-
-static int mips_m4k_single_step_core(struct target *target)
-{
-	struct mips32_common *mips32 = target_to_mips32(target);
-	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
-
-	/* configure single step mode */
-	mips_ejtag_config_step(ejtag_info, 1);
-
-	/* disable interrupts while stepping */
-	mips32_enable_interrupts(target, 0);
-
-	/* exit debug mode */
-	mips_ejtag_exit_debug(ejtag_info);
-
-	mips_m4k_debug_entry(target);
-
-	return ERROR_OK;
-}
-
-static int mips_m4k_restore_smp(struct target *target, uint32_t address, int handle_breakpoints)
-{
-	int retval = ERROR_OK;
-	struct target_list *head;
-	struct target *curr;
-
-	head = target->head;
-	while (head != (struct target_list *)NULL) {
-		int ret = ERROR_OK;
-		curr = head->target;
-		if ((curr != target) && (curr->state != TARGET_RUNNING)) {
-			/*  resume current address , not in step mode */
-			ret = mips_m4k_internal_restore(curr, 1, address,
-						   handle_breakpoints, 0);
-
-			if (ret != ERROR_OK) {
-				LOG_ERROR("target->coreid :%" PRId32 " failed to resume at address :0x%" PRIx32,
-						  curr->coreid, address);
-				retval = ret;
-			}
-		}
-		head = head->next;
-	}
-	return retval;
-}
-
-static int mips_m4k_internal_restore(struct target *target, int current,
-		uint32_t address, int handle_breakpoints, int debug_execution)
-{
-	struct mips32_common *mips32 = target_to_mips32(target);
-	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
-	struct breakpoint *breakpoint = NULL;
-	uint32_t resume_pc;
-
-	if (target->state != TARGET_HALTED) {
-		LOG_WARNING("target not halted");
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	if (!debug_execution) {
-		target_free_all_working_areas(target);
-		mips_m4k_enable_breakpoints(target);
-		mips_m4k_enable_watchpoints(target);
-	}
-
-	/* current = 1: continue on current pc, otherwise continue at <address> */
-	if (!current) {
-		buf_set_u32(mips32->core_cache->reg_list[MIPS32_PC].value, 0, 32, address);
-		mips32->core_cache->reg_list[MIPS32_PC].dirty = 1;
-		mips32->core_cache->reg_list[MIPS32_PC].valid = 1;
-	}
-
-	if (ejtag_info->impcode & EJTAG_IMP_MIPS16)
-		buf_set_u32(mips32->core_cache->reg_list[MIPS32_PC].value, 0, 1, mips32->isa_mode);
-
-	if (!current)
-		resume_pc = address;
-	else
-		resume_pc = buf_get_u32(mips32->core_cache->reg_list[MIPS32_PC].value, 0, 32);
-
-	mips32_restore_context(target);
-
-	/* the front-end may request us not to handle breakpoints */
-	if (handle_breakpoints) {
-		/* Single step past breakpoint at current address */
-		breakpoint = breakpoint_find(target, resume_pc);
-		if (breakpoint) {
-			LOG_DEBUG("unset breakpoint at 0x%8.8" PRIx32 "", breakpoint->address);
-			mips_m4k_unset_breakpoint(target, breakpoint);
-			mips_m4k_single_step_core(target);
-			mips_m4k_set_breakpoint(target, breakpoint);
-		}
-	}
-
-	/* enable interrupts if we are running */
-	mips32_enable_interrupts(target, !debug_execution);
-
-	/* exit debug mode */
-	mips_ejtag_exit_debug(ejtag_info);
-	target->debug_reason = DBG_REASON_NOTHALTED;
-
-	/* registers are now invalid */
-	register_cache_invalidate(mips32->core_cache);
-
-	if (!debug_execution) {
-		target->state = TARGET_RUNNING;
-		target_call_event_callbacks(target, TARGET_EVENT_RESUMED);
-		LOG_DEBUG("target resumed at 0x%" PRIx32 "", resume_pc);
-	} else {
-		target->state = TARGET_DEBUG_RUNNING;
-		target_call_event_callbacks(target, TARGET_EVENT_DEBUG_RESUMED);
-		LOG_DEBUG("target debug resumed at 0x%" PRIx32 "", resume_pc);
-	}
-
-	return ERROR_OK;
-}
-
-static int mips_m4k_resume(struct target *target, int current,
-		uint32_t address, int handle_breakpoints, int debug_execution)
-{
-	int retval = ERROR_OK;
-
-	/* dummy resume for smp toggle in order to reduce gdb impact  */
-	if ((target->smp) && (target->gdb_service->core[1] != -1)) {
-		/*   simulate a start and halt of target */
-		target->gdb_service->target = NULL;
-		target->gdb_service->core[0] = target->gdb_service->core[1];
-		/*  fake resume at next poll we play the  target core[1], see poll*/
-		target_call_event_callbacks(target, TARGET_EVENT_RESUMED);
-		return retval;
-	}
-
-	retval = mips_m4k_internal_restore(target, current, address,
-				handle_breakpoints,
-				debug_execution);
-
-	if (retval == ERROR_OK && target->smp) {
-		target->gdb_service->core[0] = -1;
-		retval = mips_m4k_restore_smp(target, address, handle_breakpoints);
-	}
-
-	return retval;
-}
-
-static int mips_m4k_step(struct target *target, int current,
-		uint32_t address, int handle_breakpoints)
-{
-	/* get pointers to arch-specific information */
-	struct mips32_common *mips32 = target_to_mips32(target);
-	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
-	struct breakpoint *breakpoint = NULL;
-
-	if (target->state != TARGET_HALTED) {
-		LOG_WARNING("target not halted");
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	/* current = 1: continue on current pc, otherwise continue at <address> */
-	if (!current) {
-		buf_set_u32(mips32->core_cache->reg_list[MIPS32_PC].value, 0, 32, address);
-		mips32->core_cache->reg_list[MIPS32_PC].dirty = 1;
-		mips32->core_cache->reg_list[MIPS32_PC].valid = 1;
-	}
-
-	/* the front-end may request us not to handle breakpoints */
-	if (handle_breakpoints) {
-		breakpoint = breakpoint_find(target,
-				buf_get_u32(mips32->core_cache->reg_list[MIPS32_PC].value, 0, 32));
-		if (breakpoint)
-			mips_m4k_unset_breakpoint(target, breakpoint);
-	}
-
-	/* restore context */
-	mips32_restore_context(target);
-
-	/* configure single step mode */
-	mips_ejtag_config_step(ejtag_info, 1);
-
-	target->debug_reason = DBG_REASON_SINGLESTEP;
-
-	target_call_event_callbacks(target, TARGET_EVENT_RESUMED);
-
-	/* disable interrupts while stepping */
-	mips32_enable_interrupts(target, 0);
-
-	/* exit debug mode */
-	mips_ejtag_exit_debug(ejtag_info);
-
-	/* registers are now invalid */
-	register_cache_invalidate(mips32->core_cache);
-
-	LOG_DEBUG("target stepped ");
-	mips_m4k_debug_entry(target);
-
-	if (breakpoint)
-		mips_m4k_set_breakpoint(target, breakpoint);
-
-	target_call_event_callbacks(target, TARGET_EVENT_HALTED);
-
-	return ERROR_OK;
-}
-
-static void mips_m4k_enable_breakpoints(struct target *target)
-{
-	struct breakpoint *breakpoint = target->breakpoints;
-
-	/* set any pending breakpoints */
-	while (breakpoint) {
-		if (breakpoint->set == 0)
-			mips_m4k_set_breakpoint(target, breakpoint);
-		breakpoint = breakpoint->next;
-	}
-}
-
-static int mips_m4k_set_breakpoint(struct target *target,
-		struct breakpoint *breakpoint)
-{
-	struct mips32_common *mips32 = target_to_mips32(target);
-	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
-	struct mips32_comparator *comparator_list = mips32->inst_break_list;
-	int retval;
-
-	if (breakpoint->set) {
-		LOG_WARNING("breakpoint already set");
-		return ERROR_OK;
-	}
-
-	if (breakpoint->type == BKPT_HARD) {
-		int bp_num = 0;
-
-		while (comparator_list[bp_num].used && (bp_num < mips32->num_inst_bpoints))
-			bp_num++;
-		if (bp_num >= mips32->num_inst_bpoints) {
-			LOG_ERROR("Can not find free FP Comparator(bpid: %" PRIu32 ")",
-					breakpoint->unique_id);
-			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-		}
-		breakpoint->set = bp_num + 1;
-		comparator_list[bp_num].used = 1;
-		comparator_list[bp_num].bp_value = breakpoint->address;
-
-		/* EJTAG 2.0 uses 30bit IBA. First 2 bits are reserved.
-		 * Warning: there is no IB ASID registers in 2.0.
-		 * Do not set it! :) */
-		if (ejtag_info->ejtag_version == EJTAG_VERSION_20)
-			comparator_list[bp_num].bp_value &= 0xFFFFFFFC;
-
-		target_write_u32(target, comparator_list[bp_num].reg_address,
-				comparator_list[bp_num].bp_value);
-		target_write_u32(target, comparator_list[bp_num].reg_address +
-				 ejtag_info->ejtag_ibm_offs, 0x00000000);
-		target_write_u32(target, comparator_list[bp_num].reg_address +
-				 ejtag_info->ejtag_ibc_offs, 1);
-		LOG_DEBUG("bpid: %" PRIu32 ", bp_num %i bp_value 0x%" PRIx32 "",
-				  breakpoint->unique_id,
-				  bp_num, comparator_list[bp_num].bp_value);
-	} else if (breakpoint->type == BKPT_SOFT) {
-		LOG_DEBUG("bpid: %" PRIu32, breakpoint->unique_id);
-		if (breakpoint->length == 4) {
-			uint32_t verify = 0xffffffff;
-
-			retval = target_read_memory(target, breakpoint->address, breakpoint->length, 1,
-					breakpoint->orig_instr);
-			if (retval != ERROR_OK)
-				return retval;
-			retval = target_write_u32(target, breakpoint->address, MIPS32_SDBBP);
-			if (retval != ERROR_OK)
-				return retval;
-
-			retval = target_read_u32(target, breakpoint->address, &verify);
-			if (retval != ERROR_OK)
-				return retval;
-			if (verify != MIPS32_SDBBP) {
-				LOG_ERROR("Unable to set 32bit breakpoint at address %08" PRIx32
-						" - check that memory is read/writable", breakpoint->address);
-				return ERROR_OK;
-			}
-		} else {
-			uint16_t verify = 0xffff;
-
-			retval = target_read_memory(target, breakpoint->address, breakpoint->length, 1,
-					breakpoint->orig_instr);
-			if (retval != ERROR_OK)
-				return retval;
-			retval = target_write_u16(target, breakpoint->address, MIPS16_SDBBP);
-			if (retval != ERROR_OK)
-				return retval;
-
-			retval = target_read_u16(target, breakpoint->address, &verify);
-			if (retval != ERROR_OK)
-				return retval;
-			if (verify != MIPS16_SDBBP) {
-				LOG_ERROR("Unable to set 16bit breakpoint at address %08" PRIx32
-						" - check that memory is read/writable", breakpoint->address);
-				return ERROR_OK;
-			}
-		}
-
-		breakpoint->set = 20; /* Any nice value but 0 */
-	}
-
-	return ERROR_OK;
-}
-
-static int mips_m4k_unset_breakpoint(struct target *target,
-		struct breakpoint *breakpoint)
-{
-	/* get pointers to arch-specific information */
-	struct mips32_common *mips32 = target_to_mips32(target);
-	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
-	struct mips32_comparator *comparator_list = mips32->inst_break_list;
-	int retval;
-
-	if (!breakpoint->set) {
-		LOG_WARNING("breakpoint not set");
-		return ERROR_OK;
-	}
-
-	if (breakpoint->type == BKPT_HARD) {
-		int bp_num = breakpoint->set - 1;
-		if ((bp_num < 0) || (bp_num >= mips32->num_inst_bpoints)) {
-			LOG_DEBUG("Invalid FP Comparator number in breakpoint (bpid: %" PRIu32 ")",
-					  breakpoint->unique_id);
-			return ERROR_OK;
-		}
-		LOG_DEBUG("bpid: %" PRIu32 " - releasing hw: %d",
-				breakpoint->unique_id,
-				bp_num);
-		comparator_list[bp_num].used = 0;
-		comparator_list[bp_num].bp_value = 0;
-		target_write_u32(target, comparator_list[bp_num].reg_address +
-				 ejtag_info->ejtag_ibc_offs, 0);
-
-	} else {
-		/* restore original instruction (kept in target endianness) */
-		LOG_DEBUG("bpid: %" PRIu32, breakpoint->unique_id);
-		if (breakpoint->length == 4) {
-			uint32_t current_instr;
-
-			/* check that user program has not modified breakpoint instruction */
-			retval = target_read_memory(target, breakpoint->address, 4, 1,
-					(uint8_t *)&current_instr);
-			if (retval != ERROR_OK)
-				return retval;
-
-			/**
-			 * target_read_memory() gets us data in _target_ endianess.
-			 * If we want to use this data on the host for comparisons with some macros
-			 * we must first transform it to _host_ endianess using target_buffer_get_u32().
-			 */
-			current_instr = target_buffer_get_u32(target, (uint8_t *)&current_instr);
-
-			if (current_instr == MIPS32_SDBBP) {
-				retval = target_write_memory(target, breakpoint->address, 4, 1,
-						breakpoint->orig_instr);
-				if (retval != ERROR_OK)
-					return retval;
-			}
-		} else {
-			uint16_t current_instr;
-
-			/* check that user program has not modified breakpoint instruction */
-			retval = target_read_memory(target, breakpoint->address, 2, 1,
-					(uint8_t *)&current_instr);
-			if (retval != ERROR_OK)
-				return retval;
-			current_instr = target_buffer_get_u16(target, (uint8_t *)&current_instr);
-			if (current_instr == MIPS16_SDBBP) {
-				retval = target_write_memory(target, breakpoint->address, 2, 1,
-						breakpoint->orig_instr);
-				if (retval != ERROR_OK)
-					return retval;
-			}
-		}
-	}
-	breakpoint->set = 0;
-
-	return ERROR_OK;
-}
-
-static int mips_m4k_add_breakpoint(struct target *target, struct breakpoint *breakpoint)
-{
-	struct mips32_common *mips32 = target_to_mips32(target);
-
-	if (breakpoint->type == BKPT_HARD) {
-		if (mips32->num_inst_bpoints_avail < 1) {
-			LOG_INFO("no hardware breakpoint available");
-			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-		}
-
-		mips32->num_inst_bpoints_avail--;
-	}
-
-	return mips_m4k_set_breakpoint(target, breakpoint);
-}
-
-static int mips_m4k_remove_breakpoint(struct target *target,
-		struct breakpoint *breakpoint)
-{
-	/* get pointers to arch-specific information */
-	struct mips32_common *mips32 = target_to_mips32(target);
-
-	if (target->state != TARGET_HALTED) {
-		LOG_WARNING("target not halted");
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	if (breakpoint->set)
-		mips_m4k_unset_breakpoint(target, breakpoint);
-
-	if (breakpoint->type == BKPT_HARD)
-		mips32->num_inst_bpoints_avail++;
-
-	return ERROR_OK;
-}
-
-static int mips_m4k_set_watchpoint(struct target *target,
-		struct watchpoint *watchpoint)
-{
-	struct mips32_common *mips32 = target_to_mips32(target);
-	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
-	struct mips32_comparator *comparator_list = mips32->data_break_list;
-	int wp_num = 0;
-	/*
-	 * watchpoint enabled, ignore all byte lanes in value register
-	 * and exclude both load and store accesses from  watchpoint
-	 * condition evaluation
-	*/
-	int enable = EJTAG_DBCn_NOSB | EJTAG_DBCn_NOLB | EJTAG_DBCn_BE |
-			(0xff << EJTAG_DBCn_BLM_SHIFT);
-
-	if (watchpoint->set) {
-		LOG_WARNING("watchpoint already set");
-		return ERROR_OK;
-	}
-
-	while (comparator_list[wp_num].used && (wp_num < mips32->num_data_bpoints))
-		wp_num++;
-	if (wp_num >= mips32->num_data_bpoints) {
-		LOG_ERROR("Can not find free FP Comparator");
-		return ERROR_FAIL;
-	}
-
-	if (watchpoint->length != 4) {
-		LOG_ERROR("Only watchpoints of length 4 are supported");
-		return ERROR_TARGET_UNALIGNED_ACCESS;
-	}
-
-	if (watchpoint->address % 4) {
-		LOG_ERROR("Watchpoints address should be word aligned");
-		return ERROR_TARGET_UNALIGNED_ACCESS;
-	}
-
-	switch (watchpoint->rw) {
-		case WPT_READ:
-			enable &= ~EJTAG_DBCn_NOLB;
-			break;
-		case WPT_WRITE:
-			enable &= ~EJTAG_DBCn_NOSB;
-			break;
-		case WPT_ACCESS:
-			enable &= ~(EJTAG_DBCn_NOLB | EJTAG_DBCn_NOSB);
-			break;
-		default:
-			LOG_ERROR("BUG: watchpoint->rw neither read, write nor access");
-	}
-
-	watchpoint->set = wp_num + 1;
-	comparator_list[wp_num].used = 1;
-	comparator_list[wp_num].bp_value = watchpoint->address;
-
-	/* EJTAG 2.0 uses 29bit DBA. First 3 bits are reserved.
-	 * There is as well no ASID register support. */
-	if (ejtag_info->ejtag_version == EJTAG_VERSION_20)
-		comparator_list[wp_num].bp_value &= 0xFFFFFFF8;
-	else
-		target_write_u32(target, comparator_list[wp_num].reg_address +
-			 ejtag_info->ejtag_dbasid_offs, 0x00000000);
-
-	target_write_u32(target, comparator_list[wp_num].reg_address,
-			 comparator_list[wp_num].bp_value);
-	target_write_u32(target, comparator_list[wp_num].reg_address +
-			 ejtag_info->ejtag_dbm_offs, 0x00000000);
-
-	target_write_u32(target, comparator_list[wp_num].reg_address +
-			 ejtag_info->ejtag_dbc_offs, enable);
-	/* TODO: probably this value is ignored on 2.0 */
-	target_write_u32(target, comparator_list[wp_num].reg_address +
-			 ejtag_info->ejtag_dbv_offs, 0);
-	LOG_DEBUG("wp_num %i bp_value 0x%" PRIx32 "", wp_num, comparator_list[wp_num].bp_value);
-
-	return ERROR_OK;
-}
-
-static int mips_m4k_unset_watchpoint(struct target *target,
-		struct watchpoint *watchpoint)
-{
-	/* get pointers to arch-specific information */
-	struct mips32_common *mips32 = target_to_mips32(target);
-	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
-	struct mips32_comparator *comparator_list = mips32->data_break_list;
-
-	if (!watchpoint->set) {
-		LOG_WARNING("watchpoint not set");
-		return ERROR_OK;
-	}
-
-	int wp_num = watchpoint->set - 1;
-	if ((wp_num < 0) || (wp_num >= mips32->num_data_bpoints)) {
-		LOG_DEBUG("Invalid FP Comparator number in watchpoint");
-		return ERROR_OK;
-	}
-	comparator_list[wp_num].used = 0;
-	comparator_list[wp_num].bp_value = 0;
-	target_write_u32(target, comparator_list[wp_num].reg_address +
-			 ejtag_info->ejtag_dbc_offs, 0);
-	watchpoint->set = 0;
-
-	return ERROR_OK;
-}
-
-static int mips_m4k_add_watchpoint(struct target *target, struct watchpoint *watchpoint)
-{
-	struct mips32_common *mips32 = target_to_mips32(target);
-
-	if (mips32->num_data_bpoints_avail < 1) {
-		LOG_INFO("no hardware watchpoints available");
-		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-	}
-
-	mips32->num_data_bpoints_avail--;
-
-	mips_m4k_set_watchpoint(target, watchpoint);
-	return ERROR_OK;
-}
-
-static int mips_m4k_remove_watchpoint(struct target *target,
-		struct watchpoint *watchpoint)
-{
-	/* get pointers to arch-specific information */
-	struct mips32_common *mips32 = target_to_mips32(target);
-
-	if (target->state != TARGET_HALTED) {
-		LOG_WARNING("target not halted");
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	if (watchpoint->set)
-		mips_m4k_unset_watchpoint(target, watchpoint);
-
-	mips32->num_data_bpoints_avail++;
-
-	return ERROR_OK;
-}
-
-static void mips_m4k_enable_watchpoints(struct target *target)
-{
-	struct watchpoint *watchpoint = target->watchpoints;
-
-	/* set any pending watchpoints */
-	while (watchpoint) {
-		if (watchpoint->set == 0)
-			mips_m4k_set_watchpoint(target, watchpoint);
-		watchpoint = watchpoint->next;
-	}
-}
-
-static int mips_m4k_read_memory(struct target *target, uint32_t address,
-		uint32_t size, uint32_t count, uint8_t *buffer)
-{
-	struct mips32_common *mips32 = target_to_mips32(target);
-	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
-
-	LOG_DEBUG("address: 0x%8.8" PRIx32 ", size: 0x%8.8" PRIx32 ", count: 0x%8.8" PRIx32 "",
-			address, size, count);
-
-	if (target->state != TARGET_HALTED) {
-		LOG_WARNING("target not halted");
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	/* sanitize arguments */
-	if (((size != 4) && (size != 2) && (size != 1)) || (count == 0) || !(buffer))
-		return ERROR_COMMAND_SYNTAX_ERROR;
-
-	if (((size == 4) && (address & 0x3u)) || ((size == 2) && (address & 0x1u)))
-		return ERROR_TARGET_UNALIGNED_ACCESS;
-
-	/* since we don't know if buffer is aligned, we allocate new mem that is always aligned */
-	void *t = NULL;
-
-	if (size > 1) {
-		t = malloc(count * size * sizeof(uint8_t));
-		if (t == NULL) {
-			LOG_ERROR("Out of memory");
-			return ERROR_FAIL;
-		}
-	} else
-		t = buffer;
-
-	/* if noDMA off, use DMAACC mode for memory read */
-	int retval;
-	if (ejtag_info->impcode & EJTAG_IMP_NODMA)
-		retval = mips32_pracc_read_mem(ejtag_info, address, size, count, t);
-	else
-		retval = mips32_dmaacc_read_mem(ejtag_info, address, size, count, t);
-
-	/* mips32_..._read_mem with size 4/2 returns uint32_t/uint16_t in host */
-	/* endianness, but byte array should represent target endianness       */
-	if (ERROR_OK == retval) {
-		switch (size) {
-		case 4:
-			target_buffer_set_u32_array(target, buffer, count, t);
-			break;
-		case 2:
-			target_buffer_set_u16_array(target, buffer, count, t);
-			break;
-		}
-	}
-
-	if ((size > 1) && (t != NULL))
-		free(t);
-
-	return retval;
-}
-
-static int mips_m4k_write_memory(struct target *target, uint32_t address,
-		uint32_t size, uint32_t count, const uint8_t *buffer)
-{
-	struct mips32_common *mips32 = target_to_mips32(target);
-	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
-
-	LOG_DEBUG("address: 0x%8.8" PRIx32 ", size: 0x%8.8" PRIx32 ", count: 0x%8.8" PRIx32 "",
-			address, size, count);
-
-	if (target->state != TARGET_HALTED) {
-		LOG_WARNING("target not halted");
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	if (size == 4 && count > 32) {
-		int retval = mips_m4k_bulk_write_memory(target, address, count, buffer);
-		if (retval == ERROR_OK)
-			return ERROR_OK;
-		LOG_WARNING("Falling back to non-bulk write");
-	}
-
-	/* sanitize arguments */
-	if (((size != 4) && (size != 2) && (size != 1)) || (count == 0) || !(buffer))
-		return ERROR_COMMAND_SYNTAX_ERROR;
-
-	if (((size == 4) && (address & 0x3u)) || ((size == 2) && (address & 0x1u)))
-		return ERROR_TARGET_UNALIGNED_ACCESS;
-
-	/** correct endianess if we have word or hword access */
-	void *t = NULL;
-	if (size > 1) {
-		/* mips32_..._write_mem with size 4/2 requires uint32_t/uint16_t in host */
-		/* endianness, but byte array represents target endianness               */
-		t = malloc(count * size * sizeof(uint8_t));
-		if (t == NULL) {
-			LOG_ERROR("Out of memory");
-			return ERROR_FAIL;
-		}
-
-		switch (size) {
-		case 4:
-			target_buffer_get_u32_array(target, buffer, count, (uint32_t *)t);
-			break;
-		case 2:
-			target_buffer_get_u16_array(target, buffer, count, (uint16_t *)t);
-			break;
-		}
-		buffer = t;
-	}
-
-	/* if noDMA off, use DMAACC mode for memory write */
-	int retval;
-	if (ejtag_info->impcode & EJTAG_IMP_NODMA)
-		retval = mips32_pracc_write_mem(ejtag_info, address, size, count, buffer);
-	else
-		retval = mips32_dmaacc_write_mem(ejtag_info, address, size, count, buffer);
-
-	if (t != NULL)
-		free(t);
-
-	if (ERROR_OK != retval)
-		return retval;
-
-	return ERROR_OK;
-}
-
-static int mips_m4k_init_target(struct command_context *cmd_ctx,
-		struct target *target)
-{
-	mips32_build_reg_cache(target);
-
-	return ERROR_OK;
-}
-
 static int mips_m4k_init_arch_info(struct target *target,
 		struct mips_m4k_common *mips_m4k, struct jtag_tap *tap)
 {
 	struct mips32_common *mips32 = &mips_m4k->mips32;
-
 	mips_m4k->common_magic = MIPSM4K_COMMON_MAGIC;
 
 	/* initialize mips4k specific info */
 	mips32_init_arch_info(target, mips32, tap);
 	mips32->arch_info = mips_m4k;
+	mips32->cp0_mask = MIPS_CP0_MK4;
 
 	return ERROR_OK;
 }
@@ -1100,168 +63,11 @@ static int mips_m4k_target_create(struct target *target, Jim_Interp *interp)
 	return ERROR_OK;
 }
 
-static int mips_m4k_examine(struct target *target)
-{
-	int retval;
-	struct mips_m4k_common *mips_m4k = target_to_m4k(target);
-	struct mips_ejtag *ejtag_info = &mips_m4k->mips32.ejtag_info;
-	uint32_t idcode = 0;
-
-	if (!target_was_examined(target)) {
-		retval = mips_ejtag_get_idcode(ejtag_info, &idcode);
-		if (retval != ERROR_OK)
-			return retval;
-		ejtag_info->idcode = idcode;
-
-		if (((idcode >> 1) & 0x7FF) == 0x29) {
-			/* we are using a pic32mx so select ejtag port
-			 * as it is not selected by default */
-			mips_ejtag_set_instr(ejtag_info, MTAP_SW_ETAP);
-			LOG_DEBUG("PIC32MX Detected - using EJTAG Interface");
-			mips_m4k->is_pic32mx = true;
-		}
-	}
-
-	/* init rest of ejtag interface */
-	retval = mips_ejtag_init(ejtag_info);
-	if (retval != ERROR_OK)
-		return retval;
-
-	retval = mips32_examine(target);
-	if (retval != ERROR_OK)
-		return retval;
-
-	return ERROR_OK;
-}
-
-static int mips_m4k_bulk_write_memory(struct target *target, uint32_t address,
-		uint32_t count, const uint8_t *buffer)
-{
-	struct mips32_common *mips32 = target_to_mips32(target);
-	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
-	struct working_area *fast_data_area;
-	int retval;
-	int write_t = 1;
-
-	LOG_DEBUG("address: 0x%8.8" PRIx32 ", count: 0x%8.8" PRIx32 "", address, count);
-
-	/* check alignment */
-	if (address & 0x3u)
-		return ERROR_TARGET_UNALIGNED_ACCESS;
-
-	if (mips32->fast_data_area == NULL) {
-		/* Get memory for block write handler
-		 * we preserve this area between calls and gain a speed increase
-		 * of about 3kb/sec when writing flash
-		 * this will be released/nulled by the system when the target is resumed or reset */
-		retval = target_alloc_working_area(target,
-				MIPS32_FASTDATA_HANDLER_SIZE,
-				&mips32->fast_data_area);
-		if (retval != ERROR_OK) {
-			LOG_ERROR("No working area available");
-			return retval;
-		}
-
-		/* reset fastadata state so the algo get reloaded */
-		ejtag_info->fast_access_save = -1;
-	}
-
-	fast_data_area = mips32->fast_data_area;
-
-	if (address <= fast_data_area->address + fast_data_area->size &&
-			fast_data_area->address <= address + count) {
-		LOG_ERROR("fast_data (0x%8.8" PRIx32 ") is within write area "
-			  "(0x%8.8" PRIx32 "-0x%8.8" PRIx32 ").",
-			  fast_data_area->address, address, address + count);
-		LOG_ERROR("Change work-area-phys or load_image address!");
-		return ERROR_FAIL;
-	}
-
-	/* mips32_pracc_fastdata_xfer requires uint32_t in host endianness, */
-	/* but byte array represents target endianness                      */
-	uint32_t *t = NULL;
-	t = malloc(count * sizeof(uint32_t));
-	if (t == NULL) {
-		LOG_ERROR("Out of memory");
-		return ERROR_FAIL;
-	}
-
-	target_buffer_get_u32_array(target, buffer, count, t);
-
-	retval = mips32_pracc_fastdata_xfer(ejtag_info, mips32->fast_data_area, write_t, address,
-			count, t);
-
-	if (t != NULL)
-		free(t);
-
-	if (retval != ERROR_OK)
-		LOG_ERROR("Fastdata access Failed");
-
-	return retval;
-}
-
-static int mips_m4k_verify_pointer(struct command_context *cmd_ctx,
-		struct mips_m4k_common *mips_m4k)
-{
-	if (mips_m4k->common_magic != MIPSM4K_COMMON_MAGIC) {
-		command_print(cmd_ctx, "target is not an MIPS_M4K");
-		return ERROR_TARGET_INVALID;
-	}
-	return ERROR_OK;
-}
-
 COMMAND_HANDLER(mips_m4k_handle_cp0_command)
 {
-	int retval;
-	struct target *target = get_current_target(CMD_CTX);
-	struct mips_m4k_common *mips_m4k = target_to_m4k(target);
-	struct mips_ejtag *ejtag_info = &mips_m4k->mips32.ejtag_info;
-
-	retval = mips_m4k_verify_pointer(CMD_CTX, mips_m4k);
-	if (retval != ERROR_OK)
-		return retval;
-
-	if (target->state != TARGET_HALTED) {
-		command_print(CMD_CTX, "target must be stopped for \"%s\" command", CMD_NAME);
-		return ERROR_OK;
-	}
-
-	/* two or more argument, access a single register/select (write if third argument is given) */
-	if (CMD_ARGC < 2)
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	else {
-		uint32_t cp0_reg, cp0_sel;
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], cp0_reg);
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], cp0_sel);
-
-		if (CMD_ARGC == 2) {
-			uint32_t value;
-			retval = mips32_cp0_read(ejtag_info, &value, cp0_reg, cp0_sel);
-			if (retval != ERROR_OK) {
-				command_print(CMD_CTX,
-						"couldn't access reg %" PRIi32,
-						cp0_reg);
-				return ERROR_OK;
-			}
-			command_print(CMD_CTX, "cp0 reg %" PRIi32 ", select %" PRIi32 ": %8.8" PRIx32,
-					cp0_reg, cp0_sel, value);
-
-		} else if (CMD_ARGC == 3) {
-			uint32_t value;
-			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], value);
-			retval = mips32_cp0_write(ejtag_info, value, cp0_reg, cp0_sel);
-			if (retval != ERROR_OK) {
-				command_print(CMD_CTX,
-						"couldn't access cp0 reg %" PRIi32 ", select %" PRIi32,
-						cp0_reg,  cp0_sel);
-				return ERROR_OK;
-			}
-			command_print(CMD_CTX, "cp0 reg %" PRIi32 ", select %" PRIi32 ": %8.8" PRIx32,
-					cp0_reg, cp0_sel, value);
-		}
-	}
+	/* Call common code - maintaining backward compatibility */
+	return mips32_cp0_command(cmd);
 
-	return ERROR_OK;
 }
 
 COMMAND_HANDLER(mips_m4k_handle_smp_off_command)
@@ -1278,7 +84,7 @@ COMMAND_HANDLER(mips_m4k_handle_smp_off_command)
 			curr->smp = 0;
 			head = head->next;
 		}
-		/*  fixes the target display to the debugger */
+		/*	fixes the target display to the debugger */
 		target->gdb_service->target = target;
 	}
 	return ERROR_OK;
@@ -1316,7 +122,7 @@ COMMAND_HANDLER(mips_m4k_handle_smp_gdb_command)
 			target->gdb_service->core[1] = coreid;
 
 		}
-		command_print(CMD_CTX, "gdb coreid  %" PRId32 " -> %" PRId32, target->gdb_service->core[0]
+		command_print(CMD_CTX, "gdb coreid	%" PRId32 " -> %" PRId32, target->gdb_service->core[0]
 			, target->gdb_service->core[1]);
 	}
 	return ERROR_OK;
@@ -1324,25 +130,10 @@ COMMAND_HANDLER(mips_m4k_handle_smp_gdb_command)
 
 COMMAND_HANDLER(mips_m4k_handle_scan_delay_command)
 {
-	struct target *target = get_current_target(CMD_CTX);
-	struct mips_m4k_common *mips_m4k = target_to_m4k(target);
-	struct mips_ejtag *ejtag_info = &mips_m4k->mips32.ejtag_info;
-
-	if (CMD_ARGC == 1)
-		COMMAND_PARSE_NUMBER(uint, CMD_ARGV[0], ejtag_info->scan_delay);
-	else if (CMD_ARGC > 1)
-			return ERROR_COMMAND_SYNTAX_ERROR;
 
-	command_print(CMD_CTX, "scan delay: %d nsec", ejtag_info->scan_delay);
-	if (ejtag_info->scan_delay >= 20000000) {
-		ejtag_info->mode = 0;
-		command_print(CMD_CTX, "running in legacy mode");
-	} else {
-		ejtag_info->mode = 1;
-		command_print(CMD_CTX, "running in fast queued mode");
-	}
+	/* Call common code - maintaining backward compatibility */
+	return mips32_scan_delay_command(cmd);
 
-	return ERROR_OK;
 }
 
 static const struct command_registration mips_m4k_exec_command_handlers[] = {
@@ -1350,7 +141,7 @@ static const struct command_registration mips_m4k_exec_command_handlers[] = {
 		.name = "cp0",
 		.handler = mips_m4k_handle_cp0_command,
 		.mode = COMMAND_EXEC,
-		.usage = "regnum [value]",
+		.usage = "[[reg_name|regnum select] [value]]]",
 		.help = "display/modify cp0 register",
 	},
 	{
@@ -1381,6 +172,7 @@ static const struct command_registration mips_m4k_exec_command_handlers[] = {
 		.help = "display/set scan delay in nano seconds",
 		.usage = "[value]",
 	},
+
 	COMMAND_REGISTRATION_DONE
 };
 
@@ -1401,32 +193,32 @@ const struct command_registration mips_m4k_command_handlers[] = {
 struct target_type mips_m4k_target = {
 	.name = "mips_m4k",
 
-	.poll = mips_m4k_poll,
+	.poll = mips_common_poll,
 	.arch_state = mips32_arch_state,
 
-	.halt = mips_m4k_halt,
-	.resume = mips_m4k_resume,
-	.step = mips_m4k_step,
+	.halt = mips_common_halt,
+	.resume = mips_common_resume,
+	.step = mips_common_step,
 
-	.assert_reset = mips_m4k_assert_reset,
-	.deassert_reset = mips_m4k_deassert_reset,
+	.assert_reset = mips_common_assert_reset,
+	.deassert_reset = mips_common_deassert_reset,
 
 	.get_gdb_reg_list = mips32_get_gdb_reg_list,
 
-	.read_memory = mips_m4k_read_memory,
-	.write_memory = mips_m4k_write_memory,
+	.read_memory = mips_common_read_memory,
+	.write_memory = mips_common_write_memory,
 	.checksum_memory = mips32_checksum_memory,
 	.blank_check_memory = mips32_blank_check_memory,
 
 	.run_algorithm = mips32_run_algorithm,
 
-	.add_breakpoint = mips_m4k_add_breakpoint,
-	.remove_breakpoint = mips_m4k_remove_breakpoint,
-	.add_watchpoint = mips_m4k_add_watchpoint,
-	.remove_watchpoint = mips_m4k_remove_watchpoint,
+	.add_breakpoint = mips_common_add_breakpoint,
+	.remove_breakpoint = mips_common_remove_breakpoint,
+	.add_watchpoint = mips_common_add_watchpoint,
+	.remove_watchpoint = mips_common_remove_watchpoint,
 
 	.commands = mips_m4k_command_handlers,
 	.target_create = mips_m4k_target_create,
-	.init_target = mips_m4k_init_target,
-	.examine = mips_m4k_examine,
+	.init_target = mips_common_init_target,
+	.examine = mips_common_examine,
 };
diff --git b/src/target/mips_m4k.h a/src/target/mips_m4k.h
index de990599c..add34d71d 100644
--- b/src/target/mips_m4k.h
+++ a/src/target/mips_m4k.h
@@ -32,7 +32,7 @@ struct target;
 
 struct mips_m4k_common {
 	uint32_t common_magic;
-	bool is_pic32mx;
+	bool is_pic32;
 	struct mips32_common mips32;
 };
 
diff --git b/src/target/mips_mAptiv.c a/src/target/mips_mAptiv.c
new file mode 100644
index 000000000..fd9637b69
--- /dev/null
+++ a/src/target/mips_mAptiv.c
@@ -0,0 +1,102 @@
+/***************************************************************************
+ *   Copyright (C) 2008 by Spencer Oliver                                  *
+ *   spen@spen-soft.co.uk                                                  *
+ *                                                                         *
+ *   Copyright (C) 2008 by David T.L. Wong                                 *
+ *                                                                         *
+ *   Copyright (C) 2009 by David N. Claffey <dnclaffey@gmail.com>          *
+ *                                                                         *
+ *   Copyright (C) 2011 by Drasko DRASKOVIC                                *
+ *   drasko.draskovic@gmail.com                                            *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "breakpoints.h"
+#include "mips32.h"
+#include "mips_m4k.h"
+#include "mips_mAptiv.h"
+#include "mips_common.h"
+#include "mips32_dmaacc.h"
+#include "target_type.h"
+#include "register.h"
+
+static int mips_mAptiv_init_arch_info(struct target *target,
+		struct mips_mAptiv_common *mips_mAptiv, struct jtag_tap *tap)
+{
+	struct mips32_common *mips32 = &mips_mAptiv->mips32;
+
+	mips_mAptiv->common_magic = MIPSMAPTIV_COMMON_MAGIC;
+
+	/* initialize mips specific info */
+	mips32_init_arch_info(target, mips32, tap);
+	mips32->arch_info = mips_mAptiv;
+
+	return ERROR_OK;
+}
+
+static int mips_mAptiv_target_create(struct target *target, Jim_Interp *interp)
+{
+	struct mips_mAptiv_common *mips_mAptiv = calloc(1, sizeof(struct mips_mAptiv_common));
+
+	mips_mAptiv_init_arch_info(target, mips_mAptiv, target->tap);
+
+	return ERROR_OK;
+}
+
+const struct command_registration mips_mAptiv_command_handlers[] = {
+	{
+		.chain = mips32_command_handlers,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+struct target_type mips_mAptiv_target = {
+	.name = "mips_mAptiv",
+
+	.poll = mips_common_poll,
+	.arch_state = mips32_arch_state,
+
+	.halt = mips_common_halt,
+	.resume = mips_common_resume,
+	.step = mips_common_step,
+
+	.assert_reset = mips_common_assert_reset,
+	.deassert_reset = mips_common_deassert_reset,
+
+	.get_gdb_reg_list = mips32_get_gdb_reg_list,
+
+	.read_memory = mips_common_read_memory,
+	.write_memory = mips_common_write_memory,
+	.checksum_memory = mips32_checksum_memory,
+	.blank_check_memory = mips32_blank_check_memory,
+
+	.run_algorithm = mips32_run_algorithm,
+
+	.add_breakpoint = mips_common_add_breakpoint,
+	.remove_breakpoint = mips_common_remove_breakpoint,
+	.add_watchpoint = mips_common_add_watchpoint,
+	.remove_watchpoint = mips_common_remove_watchpoint,
+
+	.commands = mips_mAptiv_command_handlers,
+	.target_create = mips_mAptiv_target_create,
+	.init_target = mips_common_init_target,
+	.examine = mips_common_examine,
+};
diff --git b/src/target/mips_mAptiv.h a/src/target/mips_mAptiv.h
new file mode 100644
index 000000000..a18f29a4a
--- /dev/null
+++ a/src/target/mips_mAptiv.h
@@ -0,0 +1,47 @@
+/***************************************************************************
+ *   Copyright (C) 2008 by Spencer Oliver                                  *
+ *   spen@spen-soft.co.uk                                                  *
+ *                                                                         *
+ *   Copyright (C) 2008 by David T.L. Wong                                 *
+ *                                                                         *
+ *   Copyright (C) 2011 by Drasko DRASKOVIC                                *
+ *   drasko.draskovic@gmail.com                                            *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef MIPS_MAPTIV_H
+#define MIPS_MAPTIV_H
+
+struct target;
+
+#define MIPSMAPTIV_COMMON_MAGIC	0xB321B321
+
+struct mips_mAptiv_common {
+	uint32_t common_magic;
+	bool is_pic32;
+	struct mips32_common mips32;
+};
+
+inline struct mips_mAptiv_common *target_to_mAptiv(struct target *target)
+{
+	return container_of(target->arch_info,
+			struct mips_mAptiv_common, mips32);
+}
+
+extern const struct command_registration mips_mAptiv_command_handlers[];
+
+#endif	/*MIPS_MAPTIV_H*/
diff --git b/src/target/target.c a/src/target/target.c
index c2408b27c..a22b77e59 100644
--- b/src/target/target.c
+++ a/src/target/target.c
@@ -93,6 +93,8 @@ extern struct target_type cortexa_target;
 extern struct target_type cortexr4_target;
 extern struct target_type arm11_target;
 extern struct target_type mips_m4k_target;
+extern struct target_type mips_mAptiv_target;
+extern struct target_type mips_iAptiv_target;
 extern struct target_type avr_target;
 extern struct target_type dsp563xx_target;
 extern struct target_type dsp5680xx_target;
@@ -122,6 +124,8 @@ static struct target_type *target_types[] = {
 	&cortexr4_target,
 	&arm11_target,
 	&mips_m4k_target,
+	&mips_mAptiv_target,
+	&mips_iAptiv_target,
 	&avr_target,
 	&dsp563xx_target,
 	&dsp5680xx_target,
@@ -906,7 +910,7 @@ int target_run_flash_async_algorithm(struct target *target,
 		}
 
 		LOG_DEBUG("offs 0x%zx count 0x%" PRIx32 " wp 0x%" PRIx32 " rp 0x%" PRIx32,
-			(size_t) (buffer - buffer_orig), count, wp, rp);
+			(buffer - buffer_orig), count, wp, rp);
 
 		if (rp == 0) {
 			LOG_ERROR("flash write algorithm aborted by target");
@@ -1143,7 +1147,8 @@ int target_profiling(struct target *target, uint32_t *samples,
  * Reset the @c examined flag for the given target.
  * Pure paranoia -- targets are zeroed on allocation.
  */
-static void target_reset_examined(struct target *target)
+//static void target_reset_examined(struct target *target)
+void target_reset_examined(struct target *target)
 {
 	target->examined = false;
 }
@@ -2425,13 +2430,7 @@ static int handle_target(void *priv)
 			if (target->backoff.times > 0) {
 				LOG_USER("Polling target %s succeeded again, trying to reexamine", target_name(target));
 				target_reset_examined(target);
-				retval = target_examine_one(target);
-				/* Target examination could have failed due to unstable connection,
-				 * but we set the examined flag anyway to repoll it later */
-				if (retval != ERROR_OK) {
-					target->examined = true;
-					return retval;
-				}
+				target_examine_one(target);
 			}
 
 			target->backoff.times = 0;
@@ -3310,10 +3309,9 @@ static int handle_bp_command_set(struct command_context *cmd_ctx,
 		uint32_t addr, uint32_t asid, uint32_t length, int hw)
 {
 	struct target *target = get_current_target(cmd_ctx);
-	int retval;
 
 	if (asid == 0) {
-		retval = breakpoint_add(target, addr, length, hw);
+		int retval = breakpoint_add(target, addr, length, hw);
 		if (ERROR_OK == retval)
 			command_print(cmd_ctx, "breakpoint set at 0x%8.8" PRIx32 "", addr);
 		else {
@@ -3321,11 +3319,7 @@ static int handle_bp_command_set(struct command_context *cmd_ctx,
 			return retval;
 		}
 	} else if (addr == 0) {
-		if (target->type->add_context_breakpoint == NULL) {
-			LOG_WARNING("Context breakpoint not available");
-			return ERROR_OK;
-		}
-		retval = context_breakpoint_add(target, asid, length, hw);
+		int retval = context_breakpoint_add(target, asid, length, hw);
 		if (ERROR_OK == retval)
 			command_print(cmd_ctx, "Context breakpoint set at 0x%8.8" PRIx32 "", asid);
 		else {
@@ -3333,11 +3327,7 @@ static int handle_bp_command_set(struct command_context *cmd_ctx,
 			return retval;
 		}
 	} else {
-		if (target->type->add_hybrid_breakpoint == NULL) {
-			LOG_WARNING("Hybrid breakpoint not available");
-			return ERROR_OK;
-		}
-		retval = hybrid_breakpoint_add(target, addr, asid, length, hw);
+		int retval = hybrid_breakpoint_add(target, addr, asid, length, hw);
 		if (ERROR_OK == retval)
 			command_print(cmd_ctx, "Hybrid breakpoint set at 0x%8.8" PRIx32 "", asid);
 		else {
@@ -3520,12 +3510,14 @@ static void writeData(FILE *f, const void *data, size_t len)
 		LOG_ERROR("failed to write %zu bytes: %s", len, strerror(errno));
 }
 
-static void writeLong(FILE *f, int l, struct target *target)
+static void writeLong(FILE *f, int l)
 {
-	uint8_t val[4];
+	int i;
+	for (i = 0; i < 4; i++) {
+		char c = (l >> (i*8))&0xff;
+		writeData(f, &c, 1);
+	}
 
-	target_buffer_set_u32(target, val, l);
-	writeData(f, val, 4);
 }
 
 static void writeString(FILE *f, char *s)
@@ -3536,18 +3528,18 @@ static void writeString(FILE *f, char *s)
 typedef unsigned char UNIT[2];  /* unit of profiling */
 
 /* Dump a gmon.out histogram file. */
-static void write_gmon(uint32_t *samples, uint32_t sampleNum, const char *filename, bool with_range,
-			uint32_t start_address, uint32_t end_address, struct target *target)
+static void write_gmon(uint32_t *samples, uint32_t sampleNum, const char *filename,
+		bool with_range, uint32_t start_address, uint32_t end_address)
 {
 	uint32_t i;
 	FILE *f = fopen(filename, "w");
 	if (f == NULL)
 		return;
 	writeString(f, "gmon");
-	writeLong(f, 0x00000001, target); /* Version */
-	writeLong(f, 0, target); /* padding */
-	writeLong(f, 0, target); /* padding */
-	writeLong(f, 0, target); /* padding */
+	writeLong(f, 0x00000001); /* Version */
+	writeLong(f, 0); /* padding */
+	writeLong(f, 0); /* padding */
+	writeLong(f, 0); /* padding */
 
 	uint8_t zero = 0;  /* GMON_TAG_TIME_HIST */
 	writeData(f, &zero, 1);
@@ -3602,10 +3594,10 @@ static void write_gmon(uint32_t *samples, uint32_t sampleNum, const char *filena
 	}
 
 	/* append binary memory gmon.out &profile_hist_hdr ((char*)&profile_hist_hdr + sizeof(struct gmon_hist_hdr)) */
-	writeLong(f, min, target);			/* low_pc */
-	writeLong(f, max, target);			/* high_pc */
-	writeLong(f, numBuckets, target);	/* # of buckets */
-	writeLong(f, 100, target);			/* KLUDGE! We lie, ca. 100Hz best case. */
+	writeLong(f, min);			/* low_pc */
+	writeLong(f, max);			/* high_pc */
+	writeLong(f, numBuckets);	/* # of buckets */
+	writeLong(f, 100);			/* KLUDGE! We lie, ca. 100Hz best case. */
 	writeString(f, "seconds");
 	for (i = 0; i < (15-strlen("seconds")); i++)
 		writeData(f, &zero, 1);
@@ -3697,7 +3689,7 @@ COMMAND_HANDLER(handle_profile_command)
 	}
 
 	write_gmon(samples, num_of_samples, CMD_ARGV[1],
-		   with_range, start_address, end_address, target);
+			with_range, start_address, end_address);
 	command_print(CMD_CTX, "Wrote %s", CMD_ARGV[1]);
 
 	free(samples);
diff --git b/src/target/target.h a/src/target/target.h
index 0552b8f9b..9f1ee0b00 100644
--- b/src/target/target.h
+++ a/src/target/target.h
@@ -367,6 +367,8 @@ static inline void target_set_examined(struct target *target)
 	target->examined = true;
 }
 
+void target_reset_examined(struct target *target);
+
 /**
  * Add the @a breakpoint for @a target.
  *
@@ -633,6 +635,7 @@ void target_handle_event(struct target *t, enum target_event e);
 #define ERROR_TARGET_TRANSLATION_FAULT	(-309)
 #define ERROR_TARGET_NOT_RUNNING (-310)
 #define ERROR_TARGET_NOT_EXAMINED (-311)
+#define ERROR_TARGET_FAST_DOWNLOAD_FAILED (-312)
 
 extern bool get_target_reset_nag(void);
 
diff --git b/tcl/interface/mips_busblaster.cfg a/tcl/interface/mips_busblaster.cfg
new file mode 100644
index 000000000..7ccd09133
--- /dev/null
+++ a/tcl/interface/mips_busblaster.cfg
@@ -0,0 +1,20 @@
+#
+# Dangerous Prototyes - Bus Blaster v3
+# The Bus Blaster has a configurable buffer between the FTDI and the
+# JTAG header which allows it to emulate various debugger types.
+#
+# Bus Blaster V3c for MIPS Kit - http://www.seeedstudio.com/depot/Bus-Blaster-V3c-for-MIPS-Kit-p-2258.html
+# Manufacture - http://dangerousprototypes.com/docs/Bus_Blaster
+#
+interface ftdi
+transport select jtag
+#ftdi_device_desc "Dual RS232-HS"
+#ftdi_vid_pid 0x0403 0x6010
+ftdi_device_desc "BUSBLASTERv3c"
+ftdi_vid_pid 0x0403 0x7780
+
+ftdi_layout_init 0x0c08 0x0f1b
+ftdi_layout_signal nTRST -data 0x0100 -noe 0x0400
+ftdi_layout_signal nSRST -data 0x0200 -noe 0x0800
+
+adapter_khz 15000
\ No newline at end of file
diff --git b/tcl/interface/wifire-pob.cfg a/tcl/interface/wifire-pob.cfg
new file mode 100644
index 000000000..8567b4220
--- /dev/null
+++ a/tcl/interface/wifire-pob.cfg
@@ -0,0 +1,60 @@
+#
+# Digilent WiFIRE - Rev D
+# The WiFIRE has a digital switch to allow JTAG debug from
+# a MIPI 20-pin connector (default) or via FTDI chip which,
+# being initialized from the host running this configuration file,
+# programs the switch to use the FTDI JTAG control.
+#
+# Available at - http://www.digilentinc.com/wifire
+# Manufacture -  http://www.digilent.com
+#
+interface ftdi
+transport select jtag
+
+# look for the Digilent WiFIRE device
+ftdi_device_desc "Digilent WiFIRE"
+
+# the JTAG port is on channel 0 (A) of the FTDI chip
+ftdi_channel 0
+
+# The WiFIRE must use the FTDI PID/VID to load the
+# FTDI usb to serial driver without the need
+# for another signed .inf
+ftdi_vid_pid 0x0403 0x6010
+
+# The Pin layout is as follows
+# X - unused
+# XXXX XXX(nRSET) (OE)XXX (TMS)(TDO)(TDI)(TCK)
+# Pin Direction X- unused, O - output, I - input
+# XXXX XXXO OXXX OIOO => 0000 0001 1000 1011 => 0x018B
+# Pin state 0 - low, 1 - high
+# to select the FTDI chip for JTAG OE == Low
+# we want to keep MCLR == High
+# TMS == high, TDO is input, TDI == low, TCK == Low/Idle
+# 0000 0001 0000 1000 => 0x0108
+ftdi_layout_init 0x0108 0x018B
+
+# The WiFIRE has no nTRST
+# ftdi_layout_signal nTRST -data 0x0000
+
+# MCLR is on 0000 0001 0000 0000 => 0x0100shu
+# we are connected directly to the pin
+# the documentation says to specify -data and -oe identically
+# so all states, Hi/Low/Tri-State can be defined
+# there is a pull up resistor on the MCLR, so this works.
+ftdi_layout_signal nSRST -data 0x0100 -oe 0x0100
+
+# OE is on 0000 0000 1000 0000 => 0x0080
+ftdi_layout_signal GPIOL3 -data 0x0080
+
+# How fast TCK can run 
+# in theory we can run the MZ at 40nsTCK period or 25MHz
+# The closest value the FTDI will run at is 15MHz
+# adapter_khz 15000
+
+# set the device ID for this device so the target will find it
+set CPUTAPID 0x1720e053
+
+# we can run faster than the bus blaster, so set
+# the adaptor speed to 15000 KHz
+set ADPTSPEED 15000
diff --git b/tcl/target/altera_de2-115_mips.cfg a/tcl/target/altera_de2-115_mips.cfg
new file mode 100644
index 000000000..db6878c5a
--- /dev/null
+++ a/tcl/target/altera_de2-115_mips.cfg
@@ -0,0 +1,41 @@
+#
+# Altera cyclone IV SoC family
+#
+if { [info exists CHIPNAME] } {
+   set _CHIPNAME $CHIPNAME
+} else {
+   set _CHIPNAME mAup
+}
+
+if { [info exists ENDIAN] } {
+   set _ENDIAN $ENDIAN
+} else {
+   set _ENDIAN little
+}
+
+if { [info exists CPUTAPID] } {
+   set _CPUTAPID $CPUTAPID
+} else {
+   set _CPUTAPID 0x00000001
+}
+
+adapter_nsrst_delay 100
+jtag_ntrst_delay 100
+# Required change
+reset_config trst_and_srst separate srst_gates_jtag srst_open_drain connect_deassert_srst
+
+#jtag scan chain
+#format L IRC IRCM IDCODE (Length, IR Capture, IR Capture Mask, IDCODE)
+jtag newtap $_CHIPNAME cpu -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id $_CPUTAPID
+
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME mips_mAptiv -endian $_ENDIAN -chain-position $_TARGETNAME
+
+#
+#
+
+echo "Setting $_TARGETNAME's scratch space to 0 bytes at 0"
+$_TARGETNAME configure -work-area-phys 0xa0003ff00 -work-area-size 256 -work-area-backup 0
+
+mips32 scan_delay 20000
+
diff --git b/tcl/target/interAptiv.cfg a/tcl/target/interAptiv.cfg
new file mode 100644
index 000000000..172ff839f
--- /dev/null
+++ a/tcl/target/interAptiv.cfg
@@ -0,0 +1,96 @@
+if { [info exists CHIPNAME] } {
+   set _CHIPNAME $CHIPNAME
+} else {
+   set _CHIPNAME iA
+}
+
+
+if { [info exists ENDIAN] } {
+   set _ENDIAN $ENDIAN
+} else {
+   set _ENDIAN little
+}
+
+if { [info exists CPUTAPID] } {
+   set _CPUTAPID $CPUTAPID
+} else {
+   set _CPUTAPID 0x00000aab
+}
+
+if { [info exists WORKAREASIZE] } {
+   set _WORKAREASIZE $WORKAREASIZE
+} else {
+   set _WORKAREASIZE 0x0100 ;# 8-KBytes
+}
+
+
+if { [info exists WORKAREABASE] } {
+   set _WORKAREABASE $WORKAREABASE
+} else {
+#    set _WORKAREABASE 0xb0012000 ;# main SRAM 12Kbytes at 0x90000000
+#    set _WORKAREABASE 0xb001e000 ;# main SRAM 12Kbytes at 0x90000000
+#    set _WORKAREABASE 0x90100000 ;# main SRAM 12Kbytes at 0x90000000
+    set _WORKAREABASE 0xb0043d00 ;# main SRAM 12Kbytes at 0x90000000
+#    set _WORKAREABASE 0xA0780000 ;# main SRAM 12Kbytes at 0x90000000
+
+}
+
+adapter_nsrst_delay 100
+jtag_ntrst_delay 100
+
+# Required change
+reset_config trst_and_srst separate srst_gates_jtag srst_open_drain connect_deassert_srst
+
+#jtag scan chain
+#format L IRC IRCM IDCODE (Length, IR Capture, IR Capture Mask, IDCODE)
+#CM
+jtag newtap $_CHIPNAME.5 cpu -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id $_CPUTAPID
+
+#Core 1-VPE 0/1
+jtag newtap $_CHIPNAME.3 cpu -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id 0x00001889
+jtag newtap $_CHIPNAME.2 cpu -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id 0x00000889
+
+#Core 0-VPE 0/1
+jtag newtap $_CHIPNAME.1 cpu -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id 0x00001667
+jtag newtap $_CHIPNAME.0 cpu -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id 0x00000667
+
+
+#set _TARGETNAME0 $_CHIPNAME.0.cpu.0
+#set _TARGETNAME1 $_CHIPNAME.0.cpu.1
+#set _TARGETNAME2 $_CHIPNAME.1.cpu.0
+#set _TARGETNAME3 $_CHIPNAME.1.cpu.1
+set _TARGETNAME0 c0v0
+set _TARGETNAME1 c0v1
+set _TARGETNAME2 c1v0
+set _TARGETNAME3 c1v1
+
+#target create $_TARGETNAME mips_iAptiv -endian $_ENDIAN -chain-position $_TARGETNAME
+target create $_TARGETNAME0 mips_iAptiv -chain-position $_CHIPNAME.0.cpu -coreid 0 -endian $_ENDIAN
+target create $_TARGETNAME1 mips_iAptiv -chain-position $_CHIPNAME.1.cpu -coreid 1 -endian $_ENDIAN
+target create $_TARGETNAME2 mips_iAptiv -chain-position $_CHIPNAME.2.cpu -coreid 2 -endian $_ENDIAN
+target create $_TARGETNAME3 mips_iAptiv -chain-position $_CHIPNAME.3.cpu -coreid 3 -endian $_ENDIAN
+
+echo "Setting $_TARGETNAME0's scratch space to $_WORKAREASIZE bytes at $_WORKAREABASE"
+$_TARGETNAME0 configure -work-area-phys $_WORKAREABASE -work-area-size 256 -work-area-backup 0
+
+echo "Setting $_TARGETNAME1's scratch space to $_WORKAREASIZE bytes at $_WORKAREABASE"
+$_TARGETNAME1 configure -work-area-phys $_WORKAREABASE -work-area-size 256 -work-area-backup 0
+
+echo "Setting $_TARGETNAME2's scratch space to $_WORKAREASIZE bytes at $_WORKAREABASE"
+$_TARGETNAME2 configure -work-area-phys $_WORKAREABASE -work-area-size 256 -work-area-backup 0
+
+echo "Setting $_TARGETNAME3's scratch space to $_WORKAREASIZE bytes at $_WORKAREABASE"
+$_TARGETNAME3 configure -work-area-phys $_WORKAREABASE -work-area-size 256 -work-area-backup 0
+
+# Scan delay for each core
+targets $_TARGETNAME2
+mips32 scan_delay 20000
+
+targets $_TARGETNAME3
+mips32 scan_delay 20000
+
+targets $_TARGETNAME1
+mips32 scan_delay 20000
+
+targets $_TARGETNAME0
+mips32 scan_delay 20000
diff --git b/tcl/target/mAUC.cfg a/tcl/target/mAUC.cfg
new file mode 100644
index 000000000..29ed774e6
--- /dev/null
+++ a/tcl/target/mAUC.cfg
@@ -0,0 +1,52 @@
+if { [info exists CHIPNAME] } {
+   set _CHIPNAME $CHIPNAME
+} else {
+   set _CHIPNAME mAUC
+}
+
+if { [info exists ENDIAN] } {
+   set _ENDIAN $ENDIAN
+} else {
+   set _ENDIAN little
+}
+
+if { [info exists CPUTAPID] } {
+   set _CPUTAPID $CPUTAPID
+} else {
+   set _CPUTAPID 0x00000001
+}
+
+if { [info exists WORKAREASIZE] } {
+   set _WORKAREASIZE $WORKAREASIZE
+} else {
+   set _WORKAREASIZE 0x400 ;# 1 KBytes
+}
+
+
+if { [info exists WORKAREABASE] } {
+   set _WORKAREABASE $WORKAREABASE
+} else {
+    set _WORKAREABASE 0xb0012000 ;# main SRAM 12Kbytes at 0x90000000
+}
+
+adapter_nsrst_delay 100
+jtag_ntrst_delay 100
+# Required change
+reset_config trst_and_srst separate srst_gates_jtag srst_open_drain connect_deassert_srst
+
+
+#jtag scan chain
+#format L IRC IRCM IDCODE (Length, IR Capture, IR Capture Mask, IDCODE)
+jtag newtap $_CHIPNAME cpu -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id $_CPUTAPID
+
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME mips_mAptiv -endian $_ENDIAN -chain-position $_TARGETNAME
+
+#
+#
+
+#echo "Setting $_TARGETNAME's scratch space to $_WORKAREASIZE bytes at $_WORKAREABASE"
+$_TARGETNAME configure -work-area-phys $_WORKAREABASE -work-area-size $_WORKAREASIZE -work-area-backup 0
+
+mips32 scan_delay 20000
+source mAUC.tcl
diff --git b/tcl/target/mAUC.tcl a/tcl/target/mAUC.tcl
new file mode 100644
index 000000000..9f142b88c
--- /dev/null
+++ a/tcl/target/mAUC.tcl
@@ -0,0 +1,266 @@
+# ====================================================================================
+echo "mAUC.tcl(updated 20140508)"
+# ====================================================================================
+
+
+# ====================================================================================
+echo "    reb                         (Setup for an EJTAGBOOT indicated reset via Sharta-A S8.)"
+# ====================================================================================
+proc reb {} {
+    jtag_reset 1 0
+    irscan mAUC.cpu 0x0c ;# EJTAGBOOT
+    echo "Press and release SW8 (will result in system reset w/ mAUC EJTAGBOOT.)"
+}
+
+# ====================================================================================
+echo "    rnb                         (Setup for a NORMALBOOT indicated reset via Sharta-A S8.)"
+# ====================================================================================
+proc rnb {} {
+    jtag_reset 1 0
+        irscan mAUC.cpu 0x0d ;# NORMALBOOT
+    echo "Press and release SW8 (will result in system reset w/ mAUC NORMALBOOT.)"
+}
+
+# ====================================================================================
+echo "    fastq <mode>          (mode 0/1 disables/enables 'fast queued mode'.)"
+# ====================================================================================
+# Workaround: "fast queued" mode making faulty assumptions (but need it to expose use of FASTDATA.)
+proc fastq {mode} {
+    if {$mode} {
+        # FixMe: lower once error detection, propagation, and recovery are improved.
+        # mips32 scan_delay 50000 ;# 50 uS "wait and assume next access is pending." 
+        mips32 scan_delay 200000 ;# 200 uS "wait and assume next access is pending." 
+    } else {
+        # FixMe: Use of EJTAG FASTDATA support should independent of queued mode.)
+        mips32 scan_delay 2000000 ;# Legacy mode. Full/correct dmseg access handshake.
+    }
+}
+
+
+# ====================================================================================
+echo "    myload                      (Example of FASTDATA load, verify, invalidate.)"
+# ====================================================================================
+proc myload {vaddr} {
+
+    # FASTDATA download currently requires enable of "fast queued" mode.
+    # The current implementation of this functionality has assumptions which are not valid.
+    # The download speeds here will be graetly improved with OpenOCD source fixes...
+
+#    fastq 1
+
+    echo "loading..." ; update
+    load_image bin64kle $vaddr bin
+
+    echo "verifying..." ; update
+    verify_image bin64kle $vaddr bin
+
+#    fastq 0
+    # invalidate ;# Uncomment if download includes "code".
+    # reg pc $vaddr ;# Uncomment if "entry point" at first load address.
+}
+
+
+# Used for manually sizing memories including detecting block aliasing...
+proc pokepeek {addr offset count} {
+    
+    for {set i 0} {$i < $count} {incr i} {
+        set myaddr [expr $addr + ($offset * $i)]
+        mww $myaddr $myaddr
+        update
+    }
+    for {set i 0} {$i < $count} {incr i} {
+        set myaddr [expr $addr + ($offset * $i)]
+        mdw $myaddr
+        update
+    }
+}
+
+
+# Master CP0 register list.
+variable cp0_info
+array unset cp0_info
+array set cp0_info {
+    Index              {  0  0  0 per_vpe }
+    MVPControl         {  0  1  0 per_core MT_ASE }
+    MVPConf0           {  0  2  0 per_core MT_ASE }
+    MVPConf1           {  0  3  0 per_core MT_ASE }
+    Random             {  1  0  0 per_vpe }
+    VPEControl         {  1  1  0 per_vpe MT_ASE }
+    VPEConf0           {  1  2  0 per_vpe MT_ASE }
+    VPEConf1           {  1  3  0 per_vpe MT_ASE }
+    YQMask             {  1  4  0 per_vpe }
+    VPESchedule        {  1  5  0 per_vpe MT_ASE }
+    VPEScheFBack       {  1  6  0 per_vpe MT_ASE }
+    VPEOpt             {  1  7  0 per_vpe MT_ASE }
+    EntryLo0           {  2  0  0 per_vpe }
+    TCStatus           {  2  1  0 per_tc MT_ASE }
+    TCBind             {  2  2  0 per_tc MT_ASE }
+    TCRestart          {  2  3  0 per_tc MT_ASE }
+    TCHalt             {  2  4  0 per_tc MT_ASE }
+    TCContext          {  2  5  0 per_tc MT_ASE }
+    TCSchedule         {  2  6  0 per_tc MT_ASE }
+    TCScheFBack        {  2  7  0 per_tc MT_ASE }
+    EntryLo1           {  3  0  0 per_vpe }
+    TCOpt              {  3  7  0 per_tc MT_ASE }
+    Context            {  4  0  0 per_vpe }
+    ContextConfig      {  4  1  0 per_vpe SmartMIPS }
+    UserLocal          {  4  2 32 per_tc }
+    PageMask           {  5  0  0 per_vpe }
+    PageGrain          {  5  1  0 per_vpe }
+    SegCtl0            {  5  2  0 per_vpe }
+    SegCtl1            {  5  3  0 per_vpe }
+    SegCtl2            {  5  4  0 per_vpe }
+    PWBase             {  5  5  0 per_vpe }
+    PWField            {  5  6  0 per_vpe }
+    PWSize             {  5  7  0 per_vpe }
+    Wired              {  6  0  0 per_vpe }
+    SRSConf0           {  6  1  0 per_vpe }
+    SRSConf1           {  6  2  0 per_vpe }
+    SRSConf2           {  6  3  0 per_vpe }
+    SRSConf3           {  6  4  0 per_vpe }
+    SRSConf4           {  6  5  0 per_vpe }
+    PWCtl              {  6  6  0 per_vpe }
+    HWREna             {  7  0 32 per_vpe }
+    BadVAddr           {  8  0 32 per_vpe }
+    BadInstr           {  8  1  0 per_vpe }
+    BadInstrP          {  8  2  0 per_vpe }
+    Count              {  9  0 32 per_vpe }
+    EntryHi            { 10  0  0 per_tc }
+    GuestCtl1          { 10  4  0 per_vpe VZ_MOD }
+    GuestCtl2          { 10  5  0 per_vpe VZ_MOD }
+    GuestCtl3          { 10  6  0 per_vpe VZ_MOD }
+    Compare            { 11  0 32 per_vpe }
+    GuestCtl0Ext       { 11  4  0 per_vpe VZ_MOD }
+    Status             { 12  0 32 per_tc !DON'T USE! OpenOCD not updating cached copy!}
+    IntCtl             { 12  1 32 per_vpe }
+    SRSCtl             { 12  2 32 per_vpe }
+    SRSMap             { 12  3  0 per_vpe }
+    View_IPL           { 12  4 32 per_vpe MCU_ASE }
+    SRSMap2            { 12  5  0 per_vpe MCU_ASE }
+    GuestCtl0          { 12  6  0 per_vpe VZ_MOD }
+    GTOffset           { 12  7  0 per_vpe VZ_MOD }
+    Cause              { 13  0 32 per_vpe }
+    View_RIPL          { 13  4  0 per_vpe MCU_ASE }
+    NestedExc          { 13  5 32 per_vpe }
+    EPC                { 14  0 32 per_vpe }
+    NestedEPC          { 14  2 32 per_vpe }
+    PRId               { 15  0 32 per_vpe }
+    EBase              { 15  1 32 per_vpe }
+    CDMMBase           { 15  2 32 per_core }
+    CMGCRBase          { 15  3  0 per_cps }
+    Config             { 16  0 32 per_vpe }
+    Config1            { 16  1 32 per_vpe }
+    Config2            { 16  2 32 per_vpe }
+    Config3            { 16  3 32 per_vpe }
+    Config4            { 16  4 32 per_vpe Implementation}
+    Config5            { 16  5 32 per_vpe Implementation}
+    Config6            { 16  6  0 per_vpe Implementation}
+    Config7            { 16  7 32 per_vpe Implementation}
+    LLAddr             { 17  0 32 per_tc }
+    WatchLo            { 18  0  0 per_vpe }
+    WatchLo0           { 18  0  0 per_vpe }
+    WatchLo1           { 18  1  0 per_vpe }
+    WatchLo2           { 18  2  0 per_vpe }
+    WatchLo3           { 18  3  0 per_vpe }
+    WatchHi            { 19  0  0 per_vpe }
+    WatchHi0           { 19  0  0 per_vpe }
+    WatchHi1           { 19  1  0 per_vpe }
+    WatchHi2           { 19  2  0 per_vpe }
+    WatchHi3           { 19  3  0 per_vpe }
+    XContext           { 20  0  0 per_vpe }
+    SecurityCtrl       { 22  0  0 per_vpe Implementation }
+    SecuritySwPRNG     { 22  1  0 per_vpe Implementation }
+    SecurityHwPRNG     { 22  2  0 per_vpe Implementation }
+    SecurityScrambling { 22  3  0 per_vpe Implementation }
+    Debug              { 23  0 32 per_tc  EJTAG }
+    Debug2             { 23  6  0 per_tc  EJTAG }
+    TraceControl       { 23  1 32 per_vpe PDTrace }
+    TraceControl2      { 23  2 32 per_vpe PDTrace }
+    UserTraceData      { 23  3  0 per_vpe PDTrace }
+    UserTraceData1     { 23  3 32 per_vpe PDTrace }
+    TraceBPC           { 23  4 32 per_vpe PDTrace }
+    TraceIBPC          { 23  4  0 per_vpe PDTrace }
+    TraceDBPC          { 23  5  0 per_vpe PDTrace }
+    DEPC               { 24  0 32 per_vpe EJTAG }
+    TraceControl3      { 24  2  0 per_vpe PDTrace }
+    UserTraceData2     { 24  3 32 per_vpe PDTrace }
+    PerfCtl0           { 25  0 32 per_core }
+    PerfCnt0           { 25  1 32 per_core }
+    PerfCtl1           { 25  2 32 per_core }
+    PerfCnt1           { 25  3 32 per_core }
+    PerfCtl2           { 25  4  0 per_core }
+    PerfCnt2           { 25  5  0 per_core }
+    PerfCtl3           { 25  6  0 per_core }
+    PerfCnt3           { 25  7  0 per_core }
+    ErrCtl             { 26  0 32 per_vpe }
+    DErrCtl            { 26  0  0 per_vpe }
+    IErrCtl            { 26  1  0 per_vpe }
+    CacheErr           { 27  0  0 per_vpe }
+    TagLo              { 28  0  0 per_vpe }
+    ITagLo             { 28  0  0 per_vpe }
+    DataLo             { 28  1  0 per_vpe }
+    IDataLo            { 28  1  0 per_vpe }
+    DTagLo             { 28  2  0 per_vpe }
+    DDataLo            { 28  3  0 per_vpe }
+    L23TagLo           { 28  4  0 per_vpe }
+    L23DataLo          { 28  5  0 per_vpe }
+    TagHi              { 29  0  0 per_vpe }
+    ITagHi             { 29  0  0 per_vpe }
+    IDataHi            { 29  1  0 per_vpe }
+    DTagHi             { 29  2  0 per_vpe }
+    DDataHi            { 29  3  0 per_vpe }
+    L23DataHi          { 29  5  0 per_vpe }
+    DataHi             { 29  1  0 per_vpe }
+    ErrorEPC           { 30  0 32 per_vpe }
+    DESAVE             { 31  0 32 per_vpe EJTAG }
+    KScratch1          { 31  2  0 per_vpe }
+    KScratch2          { 31  3  0 per_vpe }
+    KScratch3          { 31  4  0 per_vpe }
+    KScratch4          { 31  5  0 per_vpe }
+    KScratch5          { 31  6  0 per_vpe }
+    KScratch6          { 31  7  0 per_vpe }
+}
+
+
+# ====================================================================================
+echo "    <CP0RegName> ?<new-value>?  (All CP0 registers now accessible by name.)"
+# ====================================================================================
+
+foreach { reg_name reg_info } [array get cp0_info] {
+    
+    # Note: using hard-coded info entry showing register size on this processor. (0 == does not exist.)
+    if {[lindex $reg_info 2] == 32} {
+        set procbody "
+            variable cp0_info
+            set reg_info \$cp0_info($reg_name)
+            if {\$args !=  {} } {
+                mips32 cp0 [lindex $reg_info 0] [lindex $reg_info 1] \$args
+            } else {
+                mips32 cp0 [lindex $reg_info 0] [lindex $reg_info 1]
+            }
+        "
+        proc $reg_name {args} $procbody
+    }
+}
+
+# ====================================================================================
+echo "    cp0                         (dump all CP0 registers.)"
+# ====================================================================================
+proc cp0x {} {
+
+    # Note: using hard-coded info entry showing register size on this processor. (0 == does not exist.)
+    variable cp0_info
+
+    foreach { reg_name reg_info } [array get cp0_info] {
+        if {[lindex $reg_info 2] == 32} {
+            echo -n "[format "%-16s" $reg_name]"
+            flush stdout
+            $reg_name
+        }
+    }
+}
+
+# ====================================================================================
+# echo "leaving 'mAUC.tcl'"
+# ====================================================================================
+return ""
diff --git b/tcl/target/mAUP.cfg a/tcl/target/mAUP.cfg
new file mode 100644
index 000000000..94b125e4a
--- /dev/null
+++ a/tcl/target/mAUP.cfg
@@ -0,0 +1,52 @@
+if { [info exists CHIPNAME] } {
+   set _CHIPNAME $CHIPNAME
+} else {
+   set _CHIPNAME mAUP
+}
+
+if { [info exists ENDIAN] } {
+   set _ENDIAN $ENDIAN
+} else {
+   set _ENDIAN little
+}
+
+if { [info exists CPUTAPID] } {
+   set _CPUTAPID $CPUTAPID
+} else {
+   set _CPUTAPID 0x00000001
+}
+
+if { [info exists WORKAREASIZE] } {
+   set _WORKAREASIZE $WORKAREASIZE
+} else {
+   set _WORKAREASIZE 0x0100 ;# 8-KBytes
+}
+
+
+if { [info exists WORKAREABASE] } {
+   set _WORKAREABASE $WORKAREABASE
+} else {
+    set _WORKAREABASE 0xb001e000 ;# main SRAM 12Kbytes at 0x90000000
+}
+
+adapter_nsrst_delay 100
+jtag_ntrst_delay 100
+# Required change
+reset_config trst_and_srst separate srst_gates_jtag srst_open_drain connect_deassert_srst
+
+#jtag scan chain
+#format L IRC IRCM IDCODE (Length, IR Capture, IR Capture Mask, IDCODE)
+jtag newtap $_CHIPNAME cpu -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id $_CPUTAPID
+
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME mips_mAptiv -endian $_ENDIAN -chain-position $_TARGETNAME
+
+#
+#
+
+echo "Setting $_TARGETNAME's scratch space to $_WORKAREASIZE bytes at $_WORKAREABASE"
+$_TARGETNAME configure -work-area-phys $_WORKAREABASE -work-area-size $_WORKAREASIZE -work-area-backup 0
+
+#mips32 scan_delay 20000
+mips32 scan_delay 30000
+source ./tcl/target/mAUP.tcl
diff --git b/tcl/target/mAUP.tcl a/tcl/target/mAUP.tcl
new file mode 100644
index 000000000..e1da73682
--- /dev/null
+++ a/tcl/target/mAUP.tcl
@@ -0,0 +1,164 @@
+# ====================================================================================
+echo "    reb                         (Setup for an EJTAGBOOT indicated reset via Sharta-A S8.)"
+# ====================================================================================
+proc reb {} {
+	halt
+    mww 0xbfc00000 0x1000ffff ;# branch-self
+    mww 0xbfc00004 0x00000000 ;# nop
+    irscan mAUP.cpu 0x0c ;# EJTAGBOOT
+    echo "Press and Hold SW2 then release SW6 (will result in system reset w/ mAUC EJTAGBOOT.)"
+}
+
+# ====================================================================================
+echo "    rnb                         (Setup for a NORMALBOOT indicated reset via Sharta-A S8.)"
+# ====================================================================================
+proc rnb {} {
+	irscan mAUP.cpu 0x0d ;# NORMALBOOT
+    echo "Press and release SW8 (will result in system reset w/ mAUC NORMALBOOT.)"
+}
+
+# ====================================================================================
+echo "    loaduP"
+# ====================================================================================
+proc loaduP {} {
+	load_image Native_Image;#load image
+	mips32 cp0 depc 0x90000000;# Set DEPC
+	reg pc 0x90000000;# Set PC
+    reg status 0x10400104;# BEV == ERL == 1
+	step
+	reg pc 0x90000011;# Set PC
+}
+
+# ====================================================================================
+echo "    fastq <mode>          (mode 0/1 disables/enables 'fast queued mode'.)"
+# ====================================================================================
+# Workaround: "fast queued" mode making faulty assumptions (but need it to expose use of FASTDATA.)
+proc fastq {mode} {
+    if {$mode} {
+        # FixMe: lower once error detection, propagation, and recovery are improved.
+        # mips32 scan_delay 50000 ;# 50 uS "wait and assume next access is pending." 
+        mips32 scan_delay 200000 ;# 200 uS "wait and assume next access is pending." 
+    } else {
+        # FixMe: Use of EJTAG FASTDATA support should independent of queued mode.)
+        mips32 scan_delay 2000000 ;# Legacy mode. Full/correct dmseg access handshake.
+    }
+}
+
+# ====================================================================================
+echo "    myload                      (Example of FASTDATA load, verify, invalidate.)"
+# ====================================================================================
+proc myload {vaddr} {
+
+    # FASTDATA download currently requires enable of "fast queued" mode.
+    # The current implementation of this functionality has assumptions which are not valid.
+    # The download speeds here will be graetly improved with OpenOCD source fixes...
+
+    fastq 1
+
+    echo "loading..." ; update
+    load_image bin64kle $vaddr bin
+
+    echo "verifying..." ; update
+    verify_image bin64kle $vaddr bin
+
+    fastq 0
+    # invalidate ;# Uncomment if download includes "code".
+    # reg pc $vaddr ;# Uncomment if "entry point" at first load address.
+}
+
+# ====================================================================================
+echo "    invalidate ?nowb?           (Invalidate caches.)"
+# ====================================================================================
+# Workaround: OpenOCD does not currently have command to invalidate all caches.
+proc invalidate {args} {
+
+    # This TEMPORARY WORKAROUND has the following issues:
+    # FixMe: don't clobber gpr (at and v0)
+    # FixMe: don't clobber cp0 (TagLo and "pc")
+    # FixMe: detect cache sizes including unified L2$
+    # FixMe: Broken core was in usermode when halted.
+
+    TagLo 0
+    reg at 0x80000000 ;# Start
+    reg v0 0x80002000 ;# 8 kbytes
+
+    # Index Store Tag (010) I$ (00) == cacheop 8
+    mww 0xa0000000  0xBC280000 ;#  cache     0x8,0(at)
+    if { [lindex $args 0] == "nowb" } {
+        # (option to not writeback dirty lines is useful when there is no bootcode to available to init caches.)
+        echo "    Discarding dirty D$ lines..."
+        # Index Store Tag (010) D$ (01) == cacheop 9
+        mww 0xa0000004  0xBC290000 ;#  cache     0x9,0(at)
+    } else {
+        # Index Writeback invalidate (000) D$ (01) == cacheop 1
+        mww 0xa0000004  0xBC210000 ;#  cache     0x1,0(at)
+    }
+    mww 0xa0000008  0x1422FFFD ;#  bne       at,v0,0x80000000
+    mww 0xa000000C  0x24210010 ;#  addiu     at,at,16
+    mww 0xa0000010  0x7000003F ;#  sdbbp
+
+    reg pc 0xa0000000
+    resume
+
+    halt 2000 ;# Wait up to 2 seconds to halt
+}
+
+# ====================================================================================
+echo "    s8rr                        (Recover from pressing Shastra-A switch S8.)"
+# ====================================================================================
+# Probe interface signal RST* does not reset a Shastra-A memory bus resulting in response skew.
+# Workaround: Press Shastra S8 (reset) button and then recover debug comms w/ mAUP.
+proc s8rr {} {
+
+    # S8 reset "recovery"
+    echo "    Waiting a few seconds for mAUC to power up mAUP..."
+    after 2000
+
+    echo "    Reseting targer TAP via TRST..."
+#    jtag_reset 1 0 ;# Make sure target TAP is in sync.
+
+    mAUP.cpu curstate
+    echo "    Halting target..."
+    halt
+
+    # FixMe: Delay slot is not set by mAUC firmware
+    # mww 0xbfc00000 0x1000ffff ;# branch-self
+    mww 0xbfc00004 0x00000000 ;# nop
+    mdw 0xbfc00000
+    mdw 0xbfc00004
+
+    reg status 0x00400004 ;# BEV == ERL == 1
+
+    # FixMe: Boot exception vectors not covered by mAUC firmware so cover with debugger.
+    # bp 0xbfc00200 4 hw
+    # bp 0xbfc00300 4 hw
+    # bp 0xbfc00380 4 hw
+
+    # invalidate nowb ;# No boot code or OpenOCD command to init caches so script it here.
+
+    # Wait for first source modificatios to clean up memory issues exposed by enabling caches.
+    # echo "    Marking kseg0 as cacheable..."
+    # FixMe: Unable to find workaround to cached memory access so don't enable until OpenOCD source fixed.
+    # Config 0x80200483 ;# FixMe: let boot code make kseg0 write-back/write-allocate
+    reg pc 0xbfc00000 ;# FixMe: Forcing pc back to reset vector.
+}
+
+# Used for manually sizing memories including detecting block aliasing...
+proc pokepeek {addr offset count} {
+    
+    for {set i 0} {$i < $count} {incr i} {
+        set myaddr [expr $addr + ($offset * $i)]
+        mww $myaddr $myaddr
+        update
+    }
+    for {set i 0} {$i < $count} {incr i} {
+        set myaddr [expr $addr + ($offset * $i)]
+        mdw $myaddr
+        update
+    }
+}
+
+# ====================================================================================
+# echo "leaving 'mAUP.tcl'"
+# ====================================================================================
+return ""
diff --git b/tcl/target/pic32mz.cfg a/tcl/target/pic32mz.cfg
new file mode 100644
index 000000000..5e005b043
--- /dev/null
+++ a/tcl/target/pic32mz.cfg
@@ -0,0 +1,111 @@
+if { [info exists CHIPNAME] } {
+   set _CHIPNAME $CHIPNAME
+} else {
+   set _CHIPNAME pic32mz
+}
+
+if { [info exists ENDIAN] } {
+   set _ENDIAN $ENDIAN
+} else {
+   set _ENDIAN little
+}
+
+if { [info exists CPUTAPID] } {
+   set _CPUTAPID $CPUTAPID
+} else {
+#   set _CPUTAPID 0x30938053
+   set _CPUTAPID 0x25127053
+}
+
+# default working area is 16384
+if { [info exists WORKAREASIZE] } {
+   set _WORKAREASIZE $WORKAREASIZE
+} else {
+   set _WORKAREASIZE 0x4000
+}
+adapter_nsrst_delay 1000
+jtag_ntrst_delay 1000
+reset_config srst_only
+
+#jtag scan chain
+#format L IRC IRCM IDCODE (Length, IR Capture, IR Capture Mask, IDCODE)
+jtag newtap $_CHIPNAME cpu -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id $_CPUTAPID
+
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME mips_mAptiv -endian $_ENDIAN -chain-position $_TARGETNAME
+
+#
+# At reset the pic32mz does not allow code execution from RAM
+# we have to setup the BMX registers to allow this.
+# One limitation is that we loose the first 2k of RAM.
+#
+
+global _PIC32MZ_DATASIZE
+global _WORKAREASIZE
+set _PIC32MZ_DATASIZE 0x800
+set _PIC32MZ_PROGSIZE [expr ($_WORKAREASIZE - $_PIC32MZ_DATASIZE)]
+
+$_TARGETNAME configure -work-area-phys 0xa0003200 -work-area-size 512 -work-area-backup 0
+
+#$_TARGETNAME configure -work-area-phys 0x80100000 -work-area-size 0x1000 -work-area-backup 0
+
+$_TARGETNAME configure -event reset-init {
+	#
+	# from reset the pic32 cannot execute code in ram - enable ram execution
+	# minimum offset from start of ram is 2k
+	#
+	global _PIC32MZ_DATASIZE
+	global _WORKAREASIZE
+#echo $_WORKAREASIZE
+
+	# BMXCON	set 0 wait state option by clearing BMXWSDRM bit, bit 6
+	mww 0xbf882000 0x001f0000
+	# BMXDKPBA: 2k kernel data @ 0xa0000000
+	mww 0xbf882010 $_PIC32MZ_DATASIZE
+	# BMXDUDBA: 14k kernel program @ 0xa0000800 - (BMXDUDBA - BMXDKPBA)
+	mww 0xbf882020 $_WORKAREASIZE
+	# BMXDUPBA: 0k user program - (BMXDUPBA - BMXDUDBA)
+	mww 0xbf882030 $_WORKAREASIZE
+
+	#
+	# Set system clock to 8Mhz if the default clock configuration is set
+	#
+
+	# SYSKEY register, make sure OSCCON is locked
+	mww 0xbf80f230 0x0
+	# SYSKEY register, write unlock sequence
+	mww 0xbf80f230 0xaa996655
+	mww 0xbf80f230 0x556699aa
+	# OSCCON register + 4, clear OSCCON FRCDIV bits: 24, 25 and 26, divided by 1
+	mww 0xbf80f004 0x07000000
+	# SYSKEY register, relock OSCCON
+	mww 0xbf80f230 0x0
+}
+
+set _FLASHNAME $_CHIPNAME.flash0
+flash bank $_FLASHNAME pic32mz 0x1fc00000 0 0 0 $_TARGETNAME
+
+# add virtual banks for kseg0 and kseg1
+flash bank vbank0 virtual 0xbfc00000 0 0 0 $_TARGETNAME $_FLASHNAME
+flash bank vbank1 virtual 0x9fc00000 0 0 0 $_TARGETNAME $_FLASHNAME
+
+set _FLASHNAME $_CHIPNAME.flash0_upper
+flash bank $_FLASHNAME pic32mz 0x1fc20000 0 0 0 $_TARGETNAME
+
+# add virtual banks for kseg0 and kseg1
+flash bank vbank0_upper virtual 0xbfc20000 0 0 0 $_TARGETNAME $_FLASHNAME
+flash bank vbank1_upper virtual 0x9fc20000 0 0 0 $_TARGETNAME $_FLASHNAME
+
+
+set _FLASHNAME $_CHIPNAME.flash1
+flash bank $_FLASHNAME pic32mz 0x1d000000 0 0 0 $_TARGETNAME
+
+# add virtual banks for kseg0 and kseg1
+flash bank vbank2 virtual 0xbd000000 0 0 0 $_TARGETNAME $_FLASHNAME
+flash bank vbank3 virtual 0x9d000000 0 0 0 $_TARGETNAME $_FLASHNAME
+#targets
+#tms_sequence
+#scan_chain
+#interface_list
+#help
+mips32 scan_delay 5000
diff --git b/tcl/target/wifire.cfg a/tcl/target/wifire.cfg
new file mode 100644
index 000000000..7f29412f5
--- /dev/null
+++ a/tcl/target/wifire.cfg
@@ -0,0 +1,113 @@
+if { [info exists CHIPNAME] } {
+   set _CHIPNAME $CHIPNAME
+} else {
+   set _CHIPNAME pic32mz
+}
+
+if { [info exists ENDIAN] } {
+   set _ENDIAN $ENDIAN
+} else {
+   set _ENDIAN little
+}
+
+if { [info exists CPUTAPID] } {
+   set _CPUTAPID $CPUTAPID
+} else {
+   set _CPUTAPID 0x4510e053
+}
+
+# default working area is 16384
+if { [info exists WORKAREASIZE] } {
+   set _WORKAREASIZE $WORKAREASIZE
+} else {
+   set _WORKAREASIZE 0x4000
+}
+adapter_nsrst_delay 100
+jtag_ntrst_delay 100
+reset_config srst_only
+
+#jtag scan chain
+#format L IRC IRCM IDCODE (Length, IR Capture, IR Capture Mask, IDCODE)
+jtag newtap $_CHIPNAME cpu -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id $_CPUTAPID
+
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME mips_m4k -endian $_ENDIAN -chain-position $_TARGETNAME
+
+#
+# At reset the pic32mz does not allow code execution from RAM
+# we have to setup the BMX registers to allow this.
+# One limitation is that we loose the first 2k of RAM.
+#
+
+global _PIC32MZ_DATASIZE
+global _WORKAREASIZE
+set _PIC32MZ_DATASIZE 0x800
+set _PIC32MZ_PROGSIZE [expr ($_WORKAREASIZE - $_PIC32MZ_DATASIZE)]
+
+$_TARGETNAME configure -work-area-phys 0xA007F800 -work-area-size 0x800 -work-area-backup 0
+$_TARGETNAME configure -work-area-phys 0xa0000800 -work-area-size $_PIC32MZ_PROGSIZE -work-area-backup 0
+
+#$_TARGETNAME configure -work-area-phys 0x80100000 -work-area-size 0x1000 -work-area-backup 0
+
+$_TARGETNAME configure -event reset-init {
+	#
+	# from reset the pic32 cannot execute code in ram - enable ram execution
+	# minimum offset from start of ram is 2k
+	#
+	global _PIC32MZ_DATASIZE
+	global _WORKAREASIZE
+#echo $_WORKAREASIZE
+
+	# BMXCON	set 0 wait state option by clearing BMXWSDRM bit, bit 6
+	mww 0xbf882000 0x001f0000
+	# BMXDKPBA: 2k kernel data @ 0xa0000000
+	mww 0xbf882010 $_PIC32MZ_DATASIZE
+	# BMXDUDBA: 14k kernel program @ 0xa0000800 - (BMXDUDBA - BMXDKPBA)
+	mww 0xbf882020 $_WORKAREASIZE
+	# BMXDUPBA: 0k user program - (BMXDUPBA - BMXDUDBA)
+	mww 0xbf882030 $_WORKAREASIZE
+
+	#
+	# Set system clock to 8Mhz if the default clock configuration is set
+	#
+
+	# SYSKEY register, make sure OSCCON is locked
+	mww 0xbf80f230 0x0
+	# SYSKEY register, write unlock sequence
+	mww 0xbf80f230 0xaa996655
+	mww 0xbf80f230 0x556699aa
+	# OSCCON register + 4, clear OSCCON FRCDIV bits: 24, 25 and 26, divided by 1
+	mww 0xbf80f004 0x07000000
+	# SYSKEY register, relock OSCCON
+	mww 0xbf80f230 0x0
+}
+
+set _FLASHNAME $_CHIPNAME.flash0
+flash bank $_FLASHNAME pic32mz 0xbfc00000 0 0 0 $_TARGETNAME
+
+# add virtual banks for kseg0 and kseg1
+# flash bank vbank0 virtual 0xbfc00000 0 0 0 $_TARGETNAME $_FLASHNAME
+# flash bank vbank1 virtual 0x9fc00000 0 0 0 $_TARGETNAME $_FLASHNAME
+
+set _FLASHNAME $_CHIPNAME.flash0_upper
+flash bank $_FLASHNAME pic32mz 0xbfc20000 0 0 0 $_TARGETNAME
+
+# add virtual banks for kseg0 and kseg1
+# flash bank vbank0_upper virtual 0xbfc20000 0 0 0 $_TARGETNAME $_FLASHNAME
+# flash bank vbank1_upper virtual 0x9fc20000 0 0 0 $_TARGETNAME $_FLASHNAME
+
+set _FLASHNAME $_CHIPNAME.flash1
+flash bank $_FLASHNAME pic32mz 0xbd000000 0 0 0 $_TARGETNAME
+
+# add virtual banks for kseg0 and kseg1
+# flash bank vbank2 virtual 0xbd000000 0 0 0 $_TARGETNAME $_FLASHNAME
+# flash bank vbank3 virtual 0x9d000000 0 0 0 $_TARGETNAME $_FLASHNAME
+
+if { [info exists ADPTSPEED] } {
+   set _ADPTSPEED $ADPTSPEED
+} else {
+   set _ADPTSPEED 5000
+}
+adapter_khz $_ADPTSPEED
+mips32 scan_delay 1500
+source [find target/wifire.tcl]
diff --git b/tcl/target/wifire.tcl a/tcl/target/wifire.tcl
new file mode 100755
index 000000000..08c1451cc
--- /dev/null
+++ a/tcl/target/wifire.tcl
@@ -0,0 +1,13 @@
+# ====================================================================================
+echo "    reb                         (Setup for an EJTAGBOOT indicated reset.)"
+# ====================================================================================
+proc reb {} {
+    jtag_reset 0 1;irscan pic32mz.cpu 5;jtag_reset 0 0;irscan pic32mz.cpu 0x0c;
+}
+
+# ====================================================================================
+echo "    rnb                         (Setup for a NORMALBOOT indicated reset.)"
+# ====================================================================================
+proc rnb {} {
+    jtag_reset 0 1;	irscan pic32mz.cpu 5;jtag_reset 0 0;irscan pic32mz.cpu 0x0d;
+}
diff --git b/tcl/target/xilinx_nexys4_mips.cfg a/tcl/target/xilinx_nexys4_mips.cfg
new file mode 100644
index 000000000..2f668a269
--- /dev/null
+++ a/tcl/target/xilinx_nexys4_mips.cfg
@@ -0,0 +1,60 @@
+if { [info exists CHIPNAME] } {
+   set _CHIPNAME $CHIPNAME
+} else {
+   set _CHIPNAME mAUP
+}
+
+if { [info exists ENDIAN] } {
+   set _ENDIAN $ENDIAN
+} else {
+   set _ENDIAN little
+}
+
+if { [info exists CPUTAPID] } {
+   set _CPUTAPID $CPUTAPID
+} else {
+   set _CPUTAPID 0x00000001
+}
+
+if { [info exists WORKAREASIZE] } {
+   set _WORKAREASIZE $WORKAREASIZE
+} else {
+   set _WORKAREASIZE 0x100 ;# 256 KBytes
+}
+
+
+if { [info exists WORKAREABASE] } {
+   set _WORKAREABASE $WORKAREABASE
+} else {
+    set _WORKAREABASE 0x80000000 ;
+}
+
+adapter_nsrst_delay 100
+
+# Required change
+#reset_config [none|trst_only|srst_only|trst_and_srst]
+#          [srst_pulls_trst|trst_pulls_srst|combined|separate]
+#          [srst_gates_jtag|srst_nogate] [trst_push_pull|trst_open_drain]
+#          [srst_push_pull|srst_open_drain]
+#          [connect_deassert_srst|connect_assert_srst]
+
+reset_config trst_and_srst separate srst_gates_jtag trst_open_drain srst_open_drain connect_deassert_srst
+
+#jtag scan chain
+#format L IRC IRCM IDCODE (Length, IR Capture, IR Capture Mask, IDCODE)
+jtag newtap $_CHIPNAME cpu -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id $_CPUTAPID
+
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME mips_mAptiv -endian $_ENDIAN -chain-position $_TARGETNAME
+
+#
+#
+
+#echo "Setting $_TARGETNAME's scratch space to $_WORKAREASIZE bytes at $_WORKAREABASE"
+$_TARGETNAME configure -work-area-phys $_WORKAREABASE -work-area-size $_WORKAREASIZE -work-area-backup 0
+
+# Change Adapter for Nexys4
+echo "Change MIPS Bus Blaster Default Adapter speed"
+adapter_khz 14000
+
+mips32 scan_delay 20000
diff --git b/testing/build.test1/Makefile a/testing/build.test1/Makefile
deleted file mode 100644
index 7271bf2c6..000000000
--- b/testing/build.test1/Makefile
+++ /dev/null
@@ -1,98 +0,0 @@
-# -*- mode: makefile -*-
-#
-default: _complain_
-include ./local.uses
-
-%: _complain_
-
-
-_complain_:
-	@echo ""
-	@echo " Try the target: cygwin.buildtest or linux.buildtest "
-	@echo ""
-
-remove.install:
-	rm -rf ${INSTALL_DIR}
-
-.PHONY: remove.install
-
-cygwin.buildtest:
-	${MAKE} -f Makefile.ftd2xx clean all
-	${MAKE} -f Makefile.openocd cygwin.easy.permutations
-	${MAKE} -f Makefile.openocd mingw32.easy.permutations
-	${MAKE} -f Makefile.libftdi all
-	${MAKE} -f Makefile.openocd cygwin.libftdi
-
-linux.buildtest: 
-	${MAKE} linux.easy.buildtest
-	${MAKE} linux.ftd2xx_installed 
-	${MAKE} linux.ft2232_libftdi
-	@echo ""
-	@echo ""
-	@echo "========================================"
-	@echo " Linux Build Tests Complete "
-	@echo "========================================"
-	@echo ""
-	@echo ""
-
-
-linux.easy.buildtest:
-	@test -d openocd || (echo "Where the source to openocd?" && exit 1)
-	${MAKE} -f Makefile.openocd bootstrap
-	${MAKE} -f Makefile.ftd2xx  all
-	${MAKE} -f Makefile.openocd linux.easy.permutations
-
-linux.ftd2xx_installed: 
-	${MAKE} remove.install
-	${MAKE} linux.ftd2xx_installed.setup
-	${MAKE} -f Makefile.openocd $@
-
- linux.ft2232_libftdi:
-	${MAKE} remove.install 
-	${MAKE} -f Makefile.libusb  all
-	${MAKE} -f Makefile.confuse all
-	${MAKE} -f Makefile.libftdi all
-	${MAKE} -f Makefile.openocd $@
-
-# This target is used to "install" files from
-# the FTDICHIP.COM tar.gz unpack directory
-# into "a proper place" - where they should be found.
-linux.ftd2xx_installed.setup:
-	mkdir -p ${INSTALL_DIR}/include
-	mkdir -p ${EXEC_PREFIX}/lib
-	@#
-	@# Sanity check - make sure the .H file is findable
-	@#
-	@f=$(FTD2XX_LINUX_DIR)/ftd2xx.h && \
-	test -f $$f || (echo "Error: $$f not found" ; exit 1)
-	@#
-	@# Header files are simple... just copy them.
-	@#
-	cp $(FTD2XX_LINUX_DIR)/ftd2xx.h   $(PREFIX)/include/.
-	cp $(FTD2XX_LINUX_DIR)/WinTypes.h $(PREFIX)/include/.
-	@#
-	@# .SO files are harder.
-	@#     (1) copy them, (2) make links
-	@#
-	cp $(FTD2XX_LINUX_DIR)/libftd2xx.so.$(FTD2XX_LINUX_VERSION) $(EXEC_PREFIX)/lib/.
-	cd $(EXEC_PREFIX)/lib && rm -f libftd2xx.so.0
-	cd $(EXEC_PREFIX)/lib && ln -s libftd2xx.so.$(FTD2XX_LINUX_VERSION) libftd2xx.so.0
-	cd $(EXEC_PREFIX)/lib && rm -f libftd2xx.so
-	cd $(EXEC_PREFIX)/lib && ln -s libftd2xx.so.$(FTD2XX_LINUX_VERSION) libftd2xx.so
-
-
-all.download:
-	mkdir -p ${VIRGINS}
-	${MAKE} -f Makefile.confuse download
-	${MAKE} -f Makefile.libftdi download
-	${MAKE} -f Makefile.ftd2xx  download
-	${MAKE} -f Makefile.libusb  download
-
-.PHONY: linux.buildtest \
-	linux.easy.buildtest \
-	linux.ftd2xx_installed \
-	linux.ft22232_libftdi \
-	linux.ftd2xx_installed.setup
-
-
-
diff --git b/testing/build.test2/Makefile a/testing/build.test2/Makefile
deleted file mode 100644
index d4c428edd..000000000
--- b/testing/build.test2/Makefile
+++ /dev/null
@@ -1,193 +0,0 @@
-# -*- mode: makefile -*-
-#========================================
-# DO NOT DELETE THE LINE BELOW
-_default: default
-# DO NOT DELETE THE LINE_ABOVE
-#========================================
-
-#========================================
-#
-# There are no user configurable options here.
-#
-# All user configurable options are in local.uses
-#
-include ./local.uses
-#
-#========================================
-
-#========================================
-# This is the USB driver for the FTDI2XX chips.
-# It is a "closed" solution from FTDICHIP.COM
-# Some claim it is faster then the open/free
-# solution:  win32-libusb+libftdi.
-# 
-ftd2xx.download:
-	mkdir -p ${VIRGINS}
-	wget -O ${FTD2XX_ZIPFILE_LOCAL} \
-		 ${FTD2XX_ZIPFILE_URL}
-
-ftd2xx.unpack:
-	rm -rf ${FTD2XX_WIN32_DIR}
-	mkdir -p ${FTD2XX_WIN32_DIR}
-	cd ${FTD2XX_WIN32_DIR} && unzip \
-		${FTD2XX_ZIPFILE_LOCAL}
-
-ftd2xx.build:
-	@echo "Nothing to do for: $@"
-
-ftd2xx.configure:
-	@echo "Nothing to do for: $@"
-
-ftd2xx.install:
-	@echo "Nothing to do for: $@"
-
-clean::
-	rm -rf ${FTD2XX_WIN32_DIR}
-
-ftd2xx.all: ftd2xx.unpack ftd2xx.configure \
-	ftd2xx.build ftd2xx.install
-
-
-#========================================-
-# LIBFTDI - requires LIBCONFUSE..
-#   So we handle it here :-(
-
-libconfuse.download: 
-	mkdir -p virgins
-	wget -O ${LIBCONFUSE_TARFILE_LOCAL} \
-		${LIBCONFUSE_TARFILE_URL}
-
-libconfuse.unpack:
-	tar xfz ${LIBCONFUSE_TARFILE_LOCAL}
-
-clean::
-	rm -rf ${LIBCONFUSE_SRC_DIR}
-
-libconfuse.configure:
-	rm -rf ${LIBCONFUSE_BUILD_DIR}
-	mkdir -p ${LIBCONFUSE_BUILD_DIR}
-	cd ${LIBCONFUSE_BUILD_DIR} && \
-		${LIBCONFUSE_SRC_DIR}/configure \
-		--prefix=${PREFIX}
-
-clean::
-	rm -rf ${LIBCONFUSE_BUILD_DIR}
-
-libconfuse.build:
-	cd ${LIBCONFUSE_BUILD_DIR} && ${MAKE}
-
-libconfuse.install:
-	cd ${LIBCONFUSE_BUILD_DIR} && ${MAKE} install
-
-libconfuse.all: libconfuse.unpack libconfuse.configure \
-	 libconfuse.build libconfuse.install
-
-#========================================
-# LIBFTDI - the open source (and free)
-# alternative to (closed) FTD2XX drivers.
-
-libftdi.download: 
-	mkdir -p virgins
-	wget -O ${LIBFTDI_TARFILE_LOCAL} \
-		${LIBFTDI_TARFILE_URL}
-
-libftdi.unpack:
-	tar xfz ${LIBFTDI_TARFILE_LOCAL}
-
-clean::
-	rm -rf ${LIBFTDI_SRC_DIR}
-
-libftdi.configure:
-	rm -rf ${LIBFTDI_BUILD_DIR}
-	mkdir -p ${LIBFTDI_BUILD_DIR}
-	cd ${LIBFTDI_BUILD_DIR} && \
-		${LIBFTDI_SRC_DIR}/configure \
-		--prefix=${PREFIX}
-
-clean::
-	rm -rf ${LIBFTDI_BUILD_DIR}
-
-libftdi.build:
-	cd ${LIBFTDI_BUILD_DIR} && ${MAKE}
-
-libftdi.install:
-	cd ${LIBFTDI_BUILD_DIR} && ${MAKE} install
-
-libftdi.all: libftdi.unpack libftdi.configure \
-	libftdi.build libftdi.install
-
-#========================================
-# Openocd...
-
-openocd.bootstrap:
-	cd ${OPENOCD_SRC_DIR} && bash ./bootstrap
-
-openocd.configure:
-	rm -rf ${OPENOCD_BUILD_DIR}
-	mkdir -p ${OPENOCD_BUILD_DIR}
-	cd ${OPENOCD_BUILD_DIR} && ${OPENOCD_SRC_DIR}/configure \
-		--prefix=${INSTALL_DIR} \
-		${OPENOCD_CONFIG_OPTIONS}
-
-openocd.build:
-	cd ${OPENOCD_BUILD_DIR} && ${MAKE}
-
-openocd.docs:
-	cd ${OPENOCD_BUILD_DIR}/docs && ${MAKE}
-
-openocd.docs.pdf:
-	cd ${OPENOCD_BUILD_DIR}/docs && ${MAKE} pdf
-
-openocd.docs.html:
-	cd ${OPENOCD_BUILD_DIR}/docs && ${MAKE} html
-
-# fixme:
-#   need to add a "make one huge html file target"
-
-openocd.install:
-	cd ${OPENOCD_BUILD_DIR} && ${MAKE} install
-
-#========================================
-# The world...
-
-# Manual step.
-download.all: \
-	ftd2xx.download		\
-	libconfuse.download	\
-	libftdi.download
-
-ifeq (x"${FT2232_DRIVER}",x"ftd2xx")
-prebuild: ftd2xx.all
-endif
-
-ifeq (x"${FT2232_DRIVER}",x"libftdi")
-prebuild: libconfuse.all libftdi.all
-endif
-
-remake: \
-	openocd.bootstrap \
-	openocd.configure \
-	openocd.build     \
-	openocd.install
-
-initial.build : download.all prebuild remake
-
-all: 
-	@echo ""
-	@echo " This makefile does not support an 'all' target"
-	@echo ""
-	@echo " If this is your *FIRST* time building... "
-	@echo " Then use this command: \"make initial.build\""
-	@echo ""
-	@echo " The \"default\" target is for openocd developers"
-	@echo " and rebuilds openocd completely.."
-	@echo ""
-
-default: 
-	test -d ${OPENOCD_SRC_DIR} || (echo "Where is: The OPENOCD source?"; exit 1)
-	${MAKE} remake
-
-whatis_%:
-	@echo ""
-	@echo "Makevariable: $*  => ${${*}}"
-	@echo ""
diff --git b/testing/examples/ledtest-imx27ads/Makefile a/testing/examples/ledtest-imx27ads/Makefile
deleted file mode 100644
index 4009c41b2..000000000
--- b/testing/examples/ledtest-imx27ads/Makefile
+++ /dev/null
@@ -1,42 +0,0 @@
-# This will make the test program for a Freescale iMX27 ADS Board with a 
-# FreeScale iMX27 CPU 
-
-PROC=arm
-TYPE=926ejs-linux
-LDSCRIPT=ldscript
-
-PATH:=/opt/freescale/usr/local/gcc-4.1.1-glibc-2.4-nptl-sf-1/arm-926ejs-linux/bin/:$(PATH)
-CC=$(PROC)-$(TYPE)-gcc
-AS=$(PROC)-$(TYPE)-as
-AR=$(PROC)-$(TYPE)-ar
-LD=$(PROC)-$(TYPE)-ld
-NM=$(PROC)-$(TYPE)-nm
-OBJDUMP=$(PROC)-$(TYPE)-objdump
-CFLAGS= -g -c -mcpu=arm920t
-
-all: test.elf
-
-# Make a little endian image:
-# In Eclipse, add the line :
-#    source gdbinit 
-# to : Run -> Debug... (menu) -> Commands (tab): Commands (listbox)
-# To start gdb from a window use : arm-elf-gdb --command=gdbinit
-test.elf: test.c Makefile ldscript crt0.S
-	$(CC) $(CFLAGS) -o crt0.o crt0.S
-	$(CC) $(CFLAGS) -o test.o test.c
-	$(LD) -g -v -T$(LDSCRIPT) -o test.elf crt0.o test.o 
-	$(NM) test.elf
-
-
-dump:
-	$(OBJDUMP) --all-headers test.elf
-
-dump_test:
-	$(OBJDUMP) --disassemble test.elf
-
-dump_full:
-	$(OBJDUMP) --full-contents test.elf
-
-clean:
-	-/bin/rm -f *.o *~ test.elf
-
diff --git b/testing/examples/ledtest-imx31pdk/Makefile a/testing/examples/ledtest-imx31pdk/Makefile
deleted file mode 100644
index 74e2fc23f..000000000
--- b/testing/examples/ledtest-imx31pdk/Makefile
+++ /dev/null
@@ -1,42 +0,0 @@
-# $Header: $
-# This will make the test program for ARM.
-
-PROC=arm
-TYPE=none-linux-gnueabi
-LDSCRIPT=ldscript
-
-PATH:=/opt/freescale/usr/local/gcc-4.1.2-glibc-2.5-nptl-3/arm-none-linux-gnueabi/bin/:$(PATH)
-CC=$(PROC)-$(TYPE)-gcc
-AS=$(PROC)-$(TYPE)-as
-AR=$(PROC)-$(TYPE)-ar
-LD=$(PROC)-$(TYPE)-ld
-NM=$(PROC)-$(TYPE)-nm
-OBJDUMP=$(PROC)-$(TYPE)-objdump
-CFLAGS= -g -c -mcpu=arm1136j-s
-
-all: test.elf
-
-# Make a little endian image:
-# In Eclipse, add the line :
-#    source gdbinit 
-# to : Run -> Debug... (menu) -> Commands (tab): Commands (listbox)
-# To start gdb from a window use : arm-elf-gdb --command=gdbinit
-test.elf: test.c Makefile ldscript crt0.S
-	$(CC) $(CFLAGS) -o crt0.o crt0.S
-	$(CC) $(CFLAGS) -o test.o test.c
-	$(LD) -g -v -T$(LDSCRIPT) -o test.elf crt0.o test.o 
-	$(NM) test.elf
-
-	
-dump:
-	$(OBJDUMP) --all-headers test.elf
-
-dump_test:
-	$(OBJDUMP) --disassemble test.elf
-
-dump_full:
-	$(OBJDUMP) --full-contents test.elf
-
-clean:
-	-/bin/rm -f *.o *~ test.elf
-
diff --git b/tools/git2cl a/tools/git2cl
deleted file mode 160000
index 8373c9f74..000000000
--- b/tools/git2cl
+++ /dev/null
@@ -1 +0,0 @@
-Subproject commit 8373c9f74993e218a08819cbcdbab3f3564bbeba
