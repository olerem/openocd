# Notes:
# - TRST is not available.
# - EJTAG PPRST signal is not supported
# - RESET_L pin B56 on the SoC will reset internal JTAG logic. So
# If RST is available on JTAG, then fallowing configuration is recommended:
#
#	reset_config srst_only srst_pulls_trst srst_gates_jtag
#
# If RST is not available, then you can try to use soft reset. This option
# is not guaranteed to work always properly:
#
#	$_TARGETNAME configure -event reset-assert {
#		halt
#		catch "mww 0xb806001C 0x11010000"
#	}

# In this case, SRST quirk is SoC specific, so it should be in the target cfg.
reset_config srst_only srst_pulls_trst

# For ETH part the reset should be asserted at least for 10ms
# Since there is no other information let's take 100ms to be sure.
adapter_nsrst_assert_width 100

# according to the SoC documentation it should take at least 5ms from
# reset end till bootstrap end. In the practice we need 8ms to get JTAG back
# to live.
adapter_nsrst_delay 8

if { [info exists CHIPNAME] } {
	set _CHIPNAME $_CHIPNAME
} else {
	set _CHIPNAME qca4531
}

if { [info exists CPUTAPID] } {
	set _CPUTAPID $CPUTAPID
} else {
	set _CPUTAPID 0x00000001
}

jtag newtap $_CHIPNAME cpu -irlen 5 -expected-id $_CPUTAPID

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME mips_m4k -endian big -chain-position $_TARGETNAME

proc disable_watchdog { } {
	;# disable watchdog
	mww 0xb8060008 0x0
}

#$_TARGETNAME configure -event reset-end { disable_watchdog }
$_TARGETNAME configure -event halted { disable_watchdog }
