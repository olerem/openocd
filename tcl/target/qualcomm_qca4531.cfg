# Notes:
# - TRST is not available.
# - EJTAG PPRST signal is not supported
# - RESET_L pin B56 on the SoC will reset internal JTAG logic. So
# If RST is available on JTAG, then fallowing configuration is recommended:
#
#	reset_config srst_only srst_pulls_trst srst_gates_jtag
#
# If RST is not available, then you can try to use soft reset. This option
# is not guaranteed to work always properly:
#
#	$_TARGETNAME configure -event reset-assert {
#		halt
#		catch "mww 0xb806001C 0x11010000"
#	}

# In this case, SRST quirk is SoC specific, so it should be in the target cfg.
reset_config srst_only srst_pulls_trst

# For ETH part the reset should be asserted at least for 10ms
# Since there is no other information let's take 100ms to be sure.
adapter_nsrst_assert_width 100

# according to the SoC documentation it should take at least 5ms from
# reset end till bootstrap end. In the practice we need 8ms to get JTAG back
# to live.
adapter_nsrst_delay 8

if { [info exists CHIPNAME] } {
	set _CHIPNAME $_CHIPNAME
} else {
	set _CHIPNAME qca4531
}

#jtag newtap $_CHIPNAME tap -irlen 4 -expected-id 0x00000000
jtag newtap $_CHIPNAME cpu -irlen 5 -expected-id 0x00000001

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME mips_m4k -endian big -chain-position $_TARGETNAME

proc disable_watchdog { } {
	;# disable watchdog
	mww 0xb8060008 0x0
}

$_TARGETNAME configure -event halted { disable_watchdog }

$_TARGETNAME configure -event reset-assert {
	halt
	catch "mww 0xb806001C 0x01000000"
}

# Section with helpers which can be used by boards

proc qca4531_ddr2_550_550_init {} {
	mww 0xb806001c 0xfeceffff
	mww 0xb806001c 0xeeceffff
	mww 0xb806001c 0xe6ceffff
	mww 0xb8116c40 0x633c8176
	mww 0xb8116c44 0x10200000
	mww 0xb81162c0 0x4b962100
	mww 0xb81162c4 0x480
	mww 0xb81162c8 0x04000144
	mww 0xb81161c4 0x54086000
	mww 0xb8116244 0x54086000

	# PLL init
	mww 0xb8050008 0x0131001c
	mww 0xb8050000 0x40001580
	mww 0xb8050004 0x40015800
	mww 0xb8050008 0x0131001c
	mww 0xb8050000 0x00001580
	mww 0xb8050004 0x00015800
	mww 0xb8050008 0x01310000
	mww 0xb8050044 0x781003ff
	mww 0xb8050048 0x003c103f

	# DDR2 init
	mww 0xb8000108 0x401f0042
	mww 0xb80000b8 0x0000166d
	mww 0xb8000000 0xcfaaf33b
	mww 0xb800015c 0x0000000f
	mww 0xb8000004 0xa272efa8
	mww 0xb8000018 0x0000ffff
	mww 0xb80000c4 0x74444444
	mww 0xb80000c8 0x00000444
	mww 0xb8000004 0xa210ee28
	mww 0xb8000004 0xa2b2e1a8
	mww 0xb8000010 0x8
	mww 0xb80000bc 0x0
	mww 0xb8000010 0x10
	mww 0xb80000c0 0x0
	mww 0xb8000010 0x40 
	mww 0xb800000c 0x2
	mww 0xb8000010 0x2
	mww 0xb8000008 0xb43
	mww 0xb8000010 0x1
	mww 0xb8000010 0x8
	mww 0xb8000010 0x4
	mww 0xb8000010 0x4
	mww 0xb8000008 0xa43
	mww 0xb8000010 0x1
	mww 0xb800000c 0x382
	mww 0xb8000010 0x2
	mww 0xb800000c 0x402
	mww 0xb8000010 0x2
	mww 0xb8000014 0x40be
	mww 0xb800001C 0x20
	mww 0xb8000020 0x20
	mww 0xb80000cc 0xfffff
	mww 0xb8040000 0xff30b
	mww 0xb8040044 0x908
	mww 0xb8040034 0x160000
}

proc test_qca4531_uart0_tx {} {
	echo "configuring uart0.."
	mww 0xb802000c 0x87
	mww 0xb8020000 0x87
	mww 0xb8020004 0
	mww 0xb802000c 7
	mww 0xb8020004 0

	echo "send message: hallo world"
	mww 0xb8020000 0x68
	mww 0xb8020000 0x65
	mww 0xb8020000 0x6c
	mww 0xb8020000 0x6c
	mww 0xb8020000 0x6f
	mww 0xb8020000 0x20
	mww 0xb8020000 0x77
	mww 0xb8020000 0x6f
	mww 0xb8020000 0x72
	mww 0xb8020000 0x6c
	mww 0xb8020000 0x64
	mww 0xb8020000 0x0a
}

